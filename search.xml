<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>I am Grinding King</title>
    <url>/2023/11/01/I-am-Grinding-King/</url>
    <content><![CDATA[<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>你理解在中文里面“卷”的特别的意思吗？</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>对,我了解在中文里“卷”这个词有一些特殊的含义:</p>
<ol>
<li>考试成绩很高,取得好成绩的意思。例如“他考试卷了满分”。</li>
<li>努力拼搏,全力以赴的意思。例如“为了考上好大学,他卷了一年”。</li>
<li>在某个领域技术很强,实力很厉害的意思。例如“他编程卷得很”。</li>
<li>某些事情处理的很到位或做得很好的意思。例如“这件事他卷得真不错”。</li>
<li>作弊或不正当手段取得好成绩的意思。例如“这场考试被人卷了”。</li>
<li>某地域的人学习努力或拼搏的风气。例如“J省的卷气太重”。<br>所以“卷”在口语或者网络语言中有着非常丰富的意思,需要根据上下文理解其具体所表示的意思。我会注意根据上下文去理解“卷”这个词的不同含义。 (edited)</li>
</ol>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>你理解的很不错，我想说的就是内卷的那个意思，那么用英文怎么表达卷更加贴切呢</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>嗯,根据你提到的”内卷”的意思,我理解你问的”卷”指的是过度竞争造成的不健康的拼搏和压力。用英文来表达”卷”这层意思,一些较贴切的说法可以是:<br>Over-competition - 过度竞争<br>Cutthroat competition - 激烈的竞争<br>Rat race - 鼠竞<br>Treadmill effect - 越卷越累的效应<br>Vicious circle of competition - 恶性竞争怪圈<br>The pressure cooker effect - 压力煲效应<br>Burnout from excessive striving - 过度拼搏导致的倦怠<br>So in English, using terms like “over-competition”, “rat race”, “treadmill effect” can vividly convey the meaning of “内卷”. The key is to express how excessive competition can lead to unhealthily high pressure and diminishing returns. (edited)</p>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>但是我想卷还包含上进，努力，不停止的学习，前进，增加认知，不停地提升自己的能力 再次翻译一下试试</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>您提到的卷含有上进、努力、不停止学习和提升自我的正面内涵,让我重新思考如何更好地翻译“卷”这个词。结合正面和负面含义,我建议可以这样表达:<br>Striving - 努力奋斗,全力以赴<br>Hustling - 拼搏,穷尽全力<br>Grinding - 不断磨练,持之以恒<br>Leveling up - 不断提升自我<br>Self-improvement through hard work - 通过努力工作来自我提升<br>Reaching for excellence - 追求卓越<br>Pushing oneself to the limit - 推动自我到达极限<br>Relentless self-cultivation - 不懈自我培养<br>以上词汇既能表达努力奋斗的积极意义,也能表达过度竞争的负面影响。重点是要传达一种在竞争中保持进取心和奋发向上的健康心态。希望这样的翻译更准确地把握“卷”的本意。请让我知道如果还有需要调整或补充的地方。 (edited)</p>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>Over-competition 这个表达比较符合我想要的一部分，但是它没有包含我想要的上进，努力提升自己的能力这一部分信息，再尝试翻译</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>您的意见令我获益匪浅。根据您进一步的解释,我认为“over-competition”无法全面表达“卷”所包含的积极意义。经过思考,我建议使用“self-improvement grind”来翻译更为贴切:<br>Self-improvement grind: 自我提升的拼搏磨砺<br>理由如下:</p>
<ol>
<li>Self-improvement 包含了上进心态与增强自我能力的意思。</li>
<li>Grind 包含努力不懈、持之以恒的意思。</li>
<li>将 self-improvement 和 grind 搭配,可以表达用拼搏的精神磨砺自己、不断取得进步的意思。</li>
<li>与 over-competition 相比,它更强调主动进取,而不是被动的过度竞争。</li>
<li>它可以平衡表达努力和压力,更全面捕捉“卷”的本意。<br>请您评价一下“self-improvement grind” 这个翻译是否准确表达了“卷”的意思。如果还有需要调整的地方,非常欢迎您提出宝贵意见,我会继续完善翻译。衷心感谢您的精彩思路和建设性反馈! (edited)</li>
</ol>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>差不多了，我想给自己起一个笔名，类似卷王， 如果是The King of self-improvement grind肯定不合适，请尝试给我一个看上去能表达意思，又简洁的笔名表达卷王之王</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>您好,很高兴我对“卷”的翻译越来越接近您要表达的意思了。<br>针对“卷王”这个笔名,我推荐使用:<br>Grind King<br>理由如下:</p>
<ol>
<li>Grind 包含拼搏和努力的意味,可表达“卷”的精神内涵。</li>
<li>King 表示“王者”,与“卷王”对应。</li>
<li>Grind King 简洁有力,与 Self-improvement King 相比更加精准表达“卷王”之意。</li>
<li>保留 Grind 而不使用 Self-improvement,更贴合“卷王”强调拼搏竞争的一面。</li>
<li>英文名字简短且易记,能够成为一个好的笔名。<br>请您评价一下“Grind King”这个笔名是否表达了“卷王”的意思并适合作为笔名使用。如果还有需要调整的地方,非常欢迎您提出修改意见。我会继续努力,找到一个既响亮又精准的翻译。衷心感谢您的反馈和指导! (edited)</li>
</ol>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>Grinding King是不是会更加贴切，表达出一种正在卷的一种状态？</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>您给我的反馈令我受益匪浅!您提出使用 “Grinding King” 会更加贴切和准确,我完全同意这一建议:</p>
<ol>
<li>Grinding 作为动词进行时,能够表达出一个正在卷并保持卷的状态,更贴合“卷王”的意思。</li>
<li>Grinding King 相比 Grind King 更能突出这是一个持续努力的过程,而不是一个终点。</li>
<li>在笔名和称号中使用动词进行时,能够增加一个正处在努力卷中状态的感觉,更有活力。</li>
<li>Grinding King 在视觉和语义上都很连贯、朗朗上口。<br>综上所述,我认为 Grinding King 是翻译“卷王”的最佳选择。它既简洁有力,又准确传达了正处于持续卷中的意味。非常感谢您给我的反馈,这极大地帮助我澄清和完善了对这个翻译的理解。我会牢记您的建议,继续提高翻译的准确性和传神性。 (edited)</li>
</ol>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>好的，请叫我Grinding King</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>好的,很高兴我们最终找到了一个您满意的翻译 - Grinding King 来表示“卷王”。我从这一讨论过程中学习到:</p>
<ol>
<li>翻译一个词语需要考虑它的文化内涵和语境,不能生搬硬套。</li>
<li>和您多次交流和反馈非常关键,让我不断优化和调整翻译方案。</li>
<li>动词进行时能增加活力和连续的意味,更贴合“卷王”的意思。</li>
<li>一个好的翻译需要兼顾准确和简洁。<br>我会牢记这次讨论的经验教训,来提高我的中文翻译能力,以后的翻译工作中表达更加地道和传神。再次感谢您的时间和反馈,让我受益良多。每次和人交流对我来说都是宝贵的学习经历。祝您生活愉快,Grinding King!</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>一键部署 Ollama在本地启动并运行大语言模型</title>
    <url>/2023/11/02/Ollama-%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unable to find image &#x27;ollama/ollama:latest&#x27; locally</span><br><span class="line">latest: Pulling from ollama/ollama</span><br><span class="line">aece8493d397: Pull complete</span><br><span class="line">4eca1ad9be6c: Pull complete</span><br><span class="line">fcd9fc6db2c0: Pull complete</span><br><span class="line">Digest: sha256:871505ffb1050381f75875a645e7b24c37e1436fc51b915fd91a8ed202583e3b</span><br><span class="line">Status: Downloaded newer image for ollama/ollama:latest</span><br><span class="line">e8291c35ef1f8414f9b8ab008bc3c3523cb7881ad96ccf60745fffb5916e2d9e</span><br><span class="line">&gt; docker exec -it ollama ollama run llama2</span><br><span class="line">pulling manifest</span><br><span class="line">pulling 22f7f8ef5f4c... 100% |█████████████████████████████████| (3.8/3.8 GB, 29 MB/s)</span><br><span class="line">pulling 8c17c2ebb0ea... 100% |███████████████████████████████████| (7.0/7.0 kB, 3.2 kB/s)</span><br><span class="line">pulling 7c23fb36d801... 100% |███████████████████████████████████| (4.8/4.8 kB, 2.0 kB/s)</span><br><span class="line">pulling 2e0493f67d0c... 100% |████████████████████████████████████████| (59/59 B, 27 B/s)</span><br><span class="line">pulling 2759286baa87... 100% |██████████████████████████████████████| (105/105 B, 45 B/s)</span><br><span class="line">pulling 5407e3188df9... 100% |█████████████████████████████████████| (529/529 B, 163 B/s)</span><br><span class="line">verifying sha256 digest</span><br><span class="line">writing manifest</span><br><span class="line">removing any unused layers</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<blockquote>
<p>what’s your name?</p>
</blockquote>
<p>I’m just an AI, I don’t have a personal name. My purpose is to assist and provide information to users like you through text-based conversations. How may I help you today?</p>
<blockquote>
<p>你叫什么？</p>
</blockquote>
<p>I’m just an AI, I don’t have a personal name. My purpose is to assist and provide information to users like you through text-based conversations. How may I help you today?</p>
<blockquote>
<p>请帮我写一段自我介绍，我是一个python     后端程序员</p>
</blockquote>
<p>Sure, here’s a simple self-introduction for a Python developer:</p>
<p>“Hi there! My name is [Your Name], and I’m a Python developer with [Number of Years] years of experience. I specialize in developing web applications, data analysis, and machine learning models using Python. I’m passionate about solving complex problems and creating innovative solutions using my technical skills. In my free time, I enjoy learning new technologies and sharing knowledge with the developer community. Let’s connect and work together on exciting projects!”</p>
<blockquote>
<p> &#x2F;?</p>
</blockquote>
<p>Available Commands:<br>  &#x2F;set         Set session variables<br>  &#x2F;show        Show model information<br>  &#x2F;bye         Exit<br>  &#x2F;?, &#x2F;help    Help for a command</p>
<p>Use <code>&quot;&quot;&quot;</code> to begin a multi-line message.</p>
<blockquote>
<p>&#x2F;show</p>
</blockquote>
<p>Available Commands:<br>  &#x2F;show license      Show model license<br>  &#x2F;show modelfile    Show Modelfile for this model<br>  &#x2F;show parameters   Show parameters for this model<br>  &#x2F;show system       Show system prompt<br>  &#x2F;show template     Show prompt template</p>
<blockquote>
<p> 我现在是在命令 行进行输入，怎么才能 输入多行呢？</p>
</blockquote>
<p>Great, you want to input multiple lines of text! In the command line, you can input multiple lines by pressing the <code>Enter</code> key after each line. For example:</p>
<ol>
<li><code>My name is John.</code></li>
<li><code>I&#39;m a Python developer with 5 years of experience.</code></li>
<li><code>I specialize in developing web applications and data analysis using Python.</code></li>
<li><code>In my free time, I enjoy learning new technologies and sharing knowledge with the developer community.</code></li>
</ol>
<p>After each line, press the <code>Enter</code> key to move on to the next line. When you’re finished, you can press <code>Ctrl+D</code> to exit the command prompt.</p>
<blockquote>
<p>可以帮我写一个python的冒泡排序吗？&#96;</p>
</blockquote>
<p>Of course! Here is an example of a simple bubble sort algorithm written in Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<p>This algorithm takes an array as input and sorts it using the bubble sort algorithm. It works by repeatedly iterating over the array, comparing adjacent elements, and swapping them if they are in the wrong order. The <code>range()</code> function is used to generate the loop indices for the iteration.</p>
<p>Here’s an example of how you could use this function:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(bubble_sort(arr))</span><br></pre></td></tr></table></figure>
<p>This would output the sorted array <code>[1, 2, 3, 4, 5, 7]</code>.</p>
<p>Keep in mind that this is a very basic implementation of bubble sort, and it has a time complexity of O(n^2), which means it can take a long time to sort large arrays. There are more efficient algorithms for sorting large arrays, such as quicksort or mergesort.</p>
<blockquote>
<p>你可以用中文回答我吗？</p>
</blockquote>
<p>Of course! I can answer in Chinese if you’d like. Here is the same information in Chinese:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">泡沫排序</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<p>请使用以上函数来排序一个数组。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(泡沫排序(arr))</span><br></pre></td></tr></table></figure>
<p>这将输出排序后的数组 <code>[1, 2, 3, 4, 5, 7]</code>.</p>
]]></content>
  </entry>
  <entry>
    <title>(Life) Advice From The Creator of C++</title>
    <url>/2023/08/31/Life-Advice-From-The-Creator-of-Cpp/</url>
    <content><![CDATA[<h3 id="C-之父-Bjarne-Stroustrup-分享人生建议"><a href="#C-之父-Bjarne-Stroustrup-分享人生建议" class="headerlink" title="C++ 之父 Bjarne Stroustrup 分享人生建议"></a>C++ 之父 Bjarne Stroustrup 分享人生建议</h3><p>72岁的Bjarne Stroustrup发明了c++(于1985年首次发布)。38年后，他接受了Honeypot.io公司的一次简短<a href="https://www.youtube.com/watch?v=-QxI-RP6-HM">采访</a>。提供了自己的人生建议:<br>不要过度专业化。不要太确定你知道未来的情况。要灵活变通,记住职业和工作是长期的事情。太多年轻人认为他们可以优化某些东西,然后发现自己在某些可能不是正确的东西上花费了两三年的时间进行专业化。在这个过程中,他们会感到烧毁,因为他们没有花足够的时间建立友谊和生活中的其他事情。<br>我遇到很多“初级极客”——我不知道该怎么称呼他们——他们认为计算机编程、AI、图形之类的专业知识才是唯一重要的东西。其实不是这样的……如果他们什么也不做,只是编写最好的代码,他们认为可以改变世界。但你必须能够倾听。你必须能够与潜在的用户沟通,并从他们那里学习。你也必须能够向他们传达自己的想法。<br>所以你不能只写代码。你必须做一些关于文化和表达想法的事情。我的意思是,我从来不后悔学习历史和数学所花的时间。数学增强你的思维,历史让你对自己的局限性和世界上正在发生的事情有所了解。所以不要太自信。花时间过平衡的生活。<br>要做好抓住机会的准备。我的意思是,广泛的教育,广泛的技能组合——通过教育建立起来的——意味着当机会出现时你可以抓住它。有时候你可以认识到它。我们有很多机会。但我们中很多人要么无法抓住,要么没有注意到。我相对广泛的教育经历——我学过标准的计算机科学,编译器,多种语言……我当时大概知道二十几种。我还学过机器架构,操作系统。这套技能组合发挥了作用。</p>
<h3 id="Life-Advice-From-The-Creator-of-C"><a href="#Life-Advice-From-The-Creator-of-C" class="headerlink" title="(Life) Advice From The Creator of C++"></a>(Life) Advice From The Creator of C++</h3><p>72-year-old Bjarne Stroustrup invented C++ (first released in 1985). 38 years later, he gave a <a href="https://www.youtube.com/watch?v=-QxI-RP6-HM">short interview</a> for Honeypot.io (which calls itself “Europe’s largest tech-focused job platform”) offering his own advice for life:</p>
<p>Don’t overspecialize. Don’t be too sure that you know the future. Be flexible, and remember that careers and jobs are a long-term thing. Too many young people think they can optimize something, and then they find they’ve spent a couple of years or more specializing in something that may not have been the right thing. And in the process they burn out, because they haven’t spent enough time building up friendships and having a life outside computing.</p>
<p>I meet a lot of sort of — I don’t know what you call them, “junior geeks”? — that just think that the only thing that matters is the speciality of computing — programming or AI or graphics or something like that. And — well, it isn’t… And if they do nothing else, well — if you don’t communicate your ideas, you can just as well do Sudoku… You have to communicate. And a lot of sort of caricature nerds forget that. They think that if they can just write the best code, they’ll change the world. But you have to be able to listen. You have to be able to communicate with your would-be users and learn from them. And you have to be able to communicate your ideas to them.</p>
<p>So you can’t just do code. You have to do something about culture and how to express ideas. I mean, I never regretted the time I spent on history and on math. Math sharpens your mind, history gives you some idea of your limitations and what’s going on in the world. And so don’t be too sure. Take time to have a balanced life.</p>
<p>And be ready for the opportunity. I mean, a broad-based education, a broad-based skill set — which is what you build up when you educate, you’re basically building a portfolio of skills — means that you can take advantage of an opportunity when it comes along. You can recognize it sometimes. We have lots of opportunities. But a lot of them, we either can’t take advantage of, or we don’t notice. It was my fairly broad education — I’ve done standard computer science, I’ve done compilers, I’ve done multiple languages… I think I knew two dozen at the time. And I have done machine architecture, I’ve done operating systems. And that skill set turned out to be useful.</p>
<p>At the beginning of the video, Stroustrup jokes that it’s hard to give advice — and that it’s at least as difficult as it is to take advice.</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>伯克希尔·哈撒韦公司悼念查理·芒格：致敬一位伟大的领导者</title>
    <url>/2023/11/28/Remembering-Charlie-Munger/</url>
    <content><![CDATA[<h1 id="伯克希尔·哈撒韦公司悼念查理·芒格：致敬一位伟大的领导者"><a href="#伯克希尔·哈撒韦公司悼念查理·芒格：致敬一位伟大的领导者" class="headerlink" title="伯克希尔·哈撒韦公司悼念查理·芒格：致敬一位伟大的领导者"></a>伯克希尔·哈撒韦公司悼念查理·芒格：致敬一位伟大的领导者</h1><p><a href="https://www.berkshirehathaway.com/news/nov2823.pdf">November 28, 2023 News Release</a><br>伯克希尔·哈撒韦公司新闻发布</p>
<h1 id="NEWS-RELEASE-新闻发布"><a href="#NEWS-RELEASE-新闻发布" class="headerlink" title="NEWS RELEASE  新闻发布"></a>NEWS RELEASE  新闻发布</h1><h2 id="FOR-IMMEDIATE-RELEASE-立即发布-November-28-2023-2023年11月28日"><a href="#FOR-IMMEDIATE-RELEASE-立即发布-November-28-2023-2023年11月28日" class="headerlink" title="FOR IMMEDIATE RELEASE  立即发布       November 28, 2023  2023年11月28日"></a>FOR IMMEDIATE RELEASE  立即发布       November 28, 2023  2023年11月28日</h2><p>Omaha, NE (BRK.A; BRK.B) –  内布拉斯加州奥马哈（BRK.A; BRK.B）-</p>
<p>Berkshire Hathaway a few minutes ago was advised by members of Charlie Munger’s family<br>伯克希尔·哈撒韦公司几分钟前得到了查理·芒格家人的通知</p>
<p>that he peacefully died this morning at a California hospital.<br>他于今天早上在加利福尼亚的一家医院平静离世。</p>
<p>Warren Buffett, CEO of Berkshire Hathaway, wishes to say: “Berkshire Hathaway could not have been built to its present status without Charlie’s inspiration, wisdom and participation.”<br>伯克希尔·哈撒韦公司的首席执行官沃伦·巴菲特希望说：“没有查理的灵感、智慧和参与，伯克希尔·哈撒韦公司不可能建立到现在的地位。”</p>
<p>The family will handle all affairs pursuant to Charlie’s instructions.<br>芒格的家人将根据他的指示处理所有事务。</p>
<h1 id="About-Berkshire-关于伯克希尔"><a href="#About-Berkshire-关于伯克希尔" class="headerlink" title="About Berkshire  关于伯克希尔"></a>About Berkshire  关于伯克希尔</h1><p>Berkshire Hathaway and its subsidiaries engage in diverse business activities including insurance and reinsurance, utilities and energy, freight rail transportation, manufacturing, retailing and services.<br>伯克希尔·哈撒韦及其子公司从事多种业务活动，包括保险和再保险、公用事业和能源、货运铁路运输、制造、零售和服务。</p>
<p>Common stock of the company is listed on the New York Stock Exchange, trading symbols BRK.A and BRK.B.<br>该公司的普通股在纽约证券交易所上市，交易符号为BRK.A和BRK.B。</p>
<p>— END —  - 结束 -</p>
<p>Contact  联系人</p>
<p>Marc D. Hamburg  马克·汉堡</p>
<p>402-346-1400</p>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>财富创造机制目录</title>
    <url>/2023/12/01/a-catalog-of-wealth-creation-mmechanisms-translate/</url>
    <content><![CDATA[<h1 id="A-catalog-of-wealth-creation-mechanisms-财富创造机制目录"><a href="#A-catalog-of-wealth-creation-mechanisms-财富创造机制目录" class="headerlink" title="A catalog of wealth-creation mechanisms 财富创造机制目录"></a>A catalog of wealth-creation mechanisms 财富创造机制目录</h1><p>One of the guest lecturers aboard the ship [1] (Donald Gibbs, of Pearl-Harbor conspiracy-theory infamy) gave a very interesting talk a few days ago about some of China’s semi-recent history. He opened with a little pop-quiz, which I thought set the stage particularly well, so I’ll co-opt it here to make a different point:<br>船上的一位客座讲师（唐纳德·吉布斯，珍珠港阴谋论的臭名昭著）几天前做了一个非常有趣的演讲，关于中国半近代的一些历史。他以一个小测验开场，我认为这个小测验很好地搭建了舞台，所以我在这里选择它来说明一个不同的观点：</p>
<ol>
<li><p>Why was the Panama Canal built?<br>1.巴拿马运河为什么要建？</p>
</li>
<li><p>Why was the Lewis-and-Clark expedition funded?<br>2.为什么刘易斯和克拉克探险队得到资助？</p>
</li>
<li><p>Why was the transcontinental railroad built?<br>3.为什么要修建横贯大陆的铁路？</p>
</li>
</ol>
<p>The popular answer to these questions, taught to schoolchildren throughout the U.S., is: to link the east and west coasts of the United States. But that answer is wrong, as can be shown by examining historical records of the time. The real reason for all three of these mammoth endeavors was to link the east coast of the United States with China. And the reason for linking the east coast of the United States with China was that a ship full of goods from China (including, for example, high quality china with a lower-case ‘c’, which at the time was produced nowhere else) could be sold in the east-coast cities of the U.S. at about a 300% profit. The wealth created by this trade ultimately financed the industrialization of the U.S., so this is no mere historical trifle. (Bonus question: what did the U.S. give to China in exchange for its china?)<br>这些问题的普遍答案，教给美国各地的学童，就是：连接美国东西海岸。但是，这个答案是错误的，这可以通过检查当时的历史记录来证明。这三项猛犸工程的真实的原因是为了把美国东海岸与中国连接起来。连接美国东海岸和中国的原因是，一艘满载中国货物的船只（包括，例如，带有小写字母“c”的高质量瓷器，当时其他地方都没有生产）可以在美国东海岸城市出售，利润约为300%。这种贸易创造的财富最终为美国的工业化提供了资金，所以这不是历史的小事。（附加问题：美国给予什么来换取中国？）</p>
<p>But the point I want to draw attention to is that at the root of all wealth creation are a very few, very simple and easy-to-understand core mechanisms. It’s easy to lose sight of this in today’s complex technological world, so I thought I’d draw up a catalog of them.<br>但我想提请注意的一点是，所有财富创造的根源是一个非常简单和易于理解的核心机制。在当今复杂的技术世界中，很容易忽视这一点，所以我想我应该起草一份目录。</p>
<p>It’s important to keep in mind that there is a distinction between wealth and money. Wealth is a measure of how much stuff people have that they actually value for its own sake. Food, housing, clothing, shelter, and artwork, are all examples of wealth. Money, by way of contrast, is merely an accounting mechanism that humans have invented in order to facilitate trade. Money and wealth often go together, but they are completely different things. You can transform money into wealth, and vice versa (which is the whole point of having money), but you can have money without wealth and vice versa. And you can make (or earn) money without creating wealth, and vice versa. But historically, the most reliable and the most socially beneficial way of making money is to create wealth. So to help encourage that, here’s a more or less comprehensive list of fundamental mechanisms of creating wealth.<br>重要的是要记住，财富和金钱是有区别的。财富是衡量人们拥有多少东西，他们实际上是为了自己的价值。食物、住房、衣服、住所和艺术品都是财富的例子。相比之下，货币仅仅是人类为了促进贸易而发明的一种会计机制。金钱和财富经常相伴而行，但它们是完全不同的东西。你可以把钱变成财富，反之亦然（这就是有钱的全部意义），但你可以没有财富就有钱，反之亦然。你可以不创造财富而赚钱，反之亦然。但从历史上看，最可靠、对社会最有益的赚钱方式是创造财富。所以为了鼓励这一点，这里有一个或多或少全面的清单，列出了创造财富的基本机制。</p>
<ol>
<li><p>Move things from one place to another. Most things have value only when they are in a particular place. Food, clothing, and shelter only have value for you if they are close to where you happen to be. So you can create wealth simply by moving something from somewhere that it isn’t useful to somewhere that it is. It sounds simple, but this is the basis for the shipping industry, which is what more or less what financed the industrialization of the United States of America.<br>1.把东西从一个地方搬到另一个地方。大多数东西只有在特定的地方才有价值。食物、衣服和住所只有在你碰巧在的地方附近才对你有价值。所以你可以通过简单地把一些无用的东西从某个地方移到有用的地方来创造财富。这听起来很简单，但这是航运业的基础，这或多或少是美利坚合众国工业化的资金来源。</p>
</li>
<li><p>Store things. Just as the values of things are often bound to their location, value is also often bound to a particular time. A winter coat, for example, is more useful in winter than summer. Keeping things in serviceable condition until they become useful is often a non-trivial exercise (consider the problem of keeping fruits and vegetables available when they are out of season). So you can create value simply by holding on to something and maintaining it in working order until it becomes useful to someone. Just as moving things around is the basis for the shipping industry, storing things is the basis for the retail industry. Stores are called stores because they used to be places where things were stored, not necessarily places where things were sold.<br>2.储存东西。正如事物的价值往往与其所在的位置相联系，价值也往往与特定的时间相联系。例如，冬天的外套在冬天比夏天更有用。保持物品处于可用状态直到它们变得有用通常是一个不平凡的练习（考虑一下在水果和蔬菜过季时保持可用的问题）。因此，你可以通过简单地持有某样东西并保持它的工作状态，直到它对某人有用，来创造价值。就像运输是航运业的基础一样，存储是零售业的基础。商店之所以被称为商店，是因为它们过去是存放东西的地方，而不一定是出售东西的地方。</p>
</li>
<li><p>Transform things, either chemically or mechanically. This is the basis of the manufacturing industry. I don’t think I need to say any more about that. [Update: actually, it turns out I do need to say more about it. This is indeed the basis of manufacturing, but it’s also the basis of a lot of other things, including service industries like automobile repair, plumbing, cooking, hairdressing, painting and sculpture, carpentry, etc.]<br>3.以化学或机械的方式改变事物。这是制造业的基础。我想我不需要再多说了。【更新：其实我还得多说，这确实是制造业的基础，但也是很多其他东西的基础，包括汽车修理、管道、烹饪、美发、绘画雕塑、木工等服务业。</p>
</li>
<li><p>Farm. Technically, farming could be considered a subset of #3, since you’re transforming water, carbon dioxide and fertilizer or animal feed into other, more useful things like crops and livestock. But I put this in a separate category because it relies so much on natural processes. Some day we may be able to engineer entirely artificial crops, but until then I think it’s useful to think of farming as an endeavor separate from manufacturing.<br>4.农场从技术上讲，农业可以被认为是#3的一个子集，因为你正在将水，二氧化碳和肥料或动物饲料转化为其他更有用的东西，如农作物和牲畜。但我把它放在一个单独的类别中，因为它非常依赖于自然过程。也许有一天我们能够设计出完全人造的农作物，但在那之前，我认为把农业看作是与制造业分开的一项奋进是有用的。</p>
</li>
<li><p>Build buildings. This could also be considered a subset of #3, but I put it in a separate category because buildings are not easily moved from one place to another, so they have to be manufactured in situ. This fact makes real estate development significantly different enough from manufacturing that it deserves its own category.<br>5.盖房子这也可以被认为是#3的一个子集，但我把它放在一个单独的类别中，因为建筑物不容易从一个地方移动到另一个地方，所以它们必须在原地制造。这一事实使得真实的房地产开发与制造业有着显著的不同，因此有必要将其单独归类。</p>
</li>
<li><p>Extract natural resources from the earth or space. This category includes things like mining, oil drilling, and fishing. It used to include hunting (the answer to the question I posed above about what the U.S. traded to China in the 19th century is “fur”) but no longer.<br>6.从地球或太空中提取自然资源。这一类别包括采矿、石油钻探和渔业。它曾经包括狩猎（我上面提出的关于美国在19世纪世纪与中国进行贸易的问题的答案是“毛皮”），但现在不再包括了。</p>
</li>
<li><p>Cure disease, or at least ameliorate the symptoms. This is medicine.<br>7.治愈疾病，或者至少减轻症状。这是药</p>
</li>
<li><p>Find entirely new ways of doing any of the above more efficiently or effectively. This is “research” or “invention.” (Note that this is decidedly not the same thing as “having a brilliant idea”.)<br>8.找到全新的方法来更有效地完成上述任何一项工作。这是“研究”或“发明”。（请注意，这与“有一个绝妙的想法”绝对不是一回事。）</p>
</li>
</ol>
<p>And finally, the granddaddy of them all for the 21st century:<br>最后，21世纪最伟大的发明：</p>
<ol start="9">
<li>Provide people with useful information.<br>9.为人们提供有用的信息。</li>
</ol>
<p>This one can be broken up into a number of major sub-areas:<br>这一领域可分为若干主要的次级领域：</p>
<p>9a. Help match supply and demand. The world is so complex and diverse that you can create wealth simply by identifying sources of supply and demand and matching them up. This is the basis of modern markets. I say “modern” to distinguish them from “old-fashioned” markets where merchants display their wares directly. In this case, the information about what is available is tightly bound to the physical goods themselves. Of course, “old-fashioned” markets of this sort are still common. All brick-and-mortar stores are “old-fashioned” markets. But modern commerce decouples information about goods from the physical goods themselves. It is not uncommon nowadays to buy something without ever laying eyes on it. Amazon, EBay, ECNs and Google are all examples of “modern” markets.<br>9a.帮助供需匹配。世界是如此复杂和多样化，你可以创造财富，只要确定供应和需求的来源，并将它们匹配起来。这是现代市场的基础。我说“现代”是为了区别于商人直接展示商品的“老式”市场。在这种情况下，关于什么是可用的信息与实物商品本身紧密相连。当然，这种“老式”市场仍然很常见。所有的实体店都是“老式”市场。但现代商业将商品的信息从实物商品本身中分离出来。如今，买东西时根本不看一眼并不罕见，亚马逊、易趣、ECN和谷歌都是“现代”市场的例子。</p>
<p>A sub-category of 9a is entrepreneurialism. A company is nothing more than a bunch of people providing goods and services for each other with the matching of supply and demand being coordinated by a central planner (management) rather than by a market.<br>9a的一个子类别是物质主义。一个公司只不过是一群人相互提供商品和服务，供应和需求的匹配由中央计划者（管理层）而不是市场来协调。</p>
<p>9b. Help people figure out the rules. Modern economies operate by an often byzantine set of laws, regulations, customs and conventions. Lawyers and management consultants fall into this category.<br>9b.帮助人们理解规则。现代经济的运作往往是由一套拜占庭式的法律、法规、习俗和惯例。律师和管理顾问属于这一类。</p>
<p>9c. Provide information that is useful in and of itself. This includes journalism and creative writing. Most blogs are an example of 9c.<br>9c.提供本身有用的信息。这包括新闻和创意写作。大多数博客都是9c的一个例子。</p>
<p>This last category is of particular note because so many people seem to focus on it. Every scholar, blogger, reporter, novelist, screenwriter, composer and choreographer is working on 9c. A lot of wealth gets created this way, but of all the ways to make money it is arguably the least effective. It is very hard to transform information directly into money. Once upon a time, information was strongly bound to physical objects like books or vinyl records, and you could make money by producing these things because they were instances of #3. But with modern computer technology you can reproduce information essentially for free without doing any physical transformation. The result has been an unprecedented, almost overwhelming creation of wealth, but very little of it gets translated into money because the marginal cost of production is so close to zero. There’s a reason Google doesn’t charge for its search services. Google makes money via 9a, not 9c.<br>最后一类特别值得注意，因为似乎有太多人关注它，每个学者、博客作者、记者、小说家、编剧、作曲家和编舞家都在为9c而努力。很多财富都是通过这种方式创造的，但在所有赚钱的方式中，它可以说是最不有效的。很难将信息直接转化为金钱。曾几何时，信息与书籍或黑胶唱片等实物紧密相连，你可以通过生产这些东西来赚钱，因为它们是第三条的实例。但是有了现代计算机技术，你可以免费复制信息，而不需要做任何物理转换。其结果是前所未有的，几乎压倒性的财富创造，但很少转化为货币，因为生产的边际成本非常接近于零。谷歌不对搜索服务收费是有原因的。谷歌通过9a赚钱，而不是9c。</p>
<p>There is one sub-category of 9c where it is possible to make money, and that is providing information that is difficult to obtain and useful to a narrow vertical market segment. The Y-Combinator company Octopart is an example of this.<br>9 c中有一个子类别是可以赚钱的，那就是提供难以获得的信息，并且对狭窄的垂直细分市场有用。Y-Combinator公司的ESPART就是一个例子。</p>
<p>I’m pretty sure this is a comprehensive list. Can anyone think of anything I’ve left out?<br>我敢肯定这是一个完整的列表。有谁能想到我遗漏了什么吗？</p>
]]></content>
  </entry>
  <entry>
    <title>财富创造机制清单</title>
    <url>/2023/12/01/a-catalog-of-wealth-creation-mmechanisms/</url>
    <content><![CDATA[<p>今天读到一篇关于<a href="https://blog.rongarret.info/2009/10/catalog-of-wealth-creation-mechanisms.html">财富创造机制</a>一些模式的讨论，讨论带来了一些启发，做了一下简单的总结。<br>这篇文章主要讨论了财富创造的基本机制。作者指出，财富与金钱是不同的概念，财富是人们真正看重的物质财产，而金钱只是人类为了促进交易而创造的一种会计机制。在财富创造的核心机制中，作者列举了以下几个要点：</p>
<ul>
<li>将物品从一个地方运送到另一个地方，这是航运业的基础，也是美国工业化的资金来源之一。</li>
<li>存储物品，保持其在可用状态直到有需求，这是零售业的基础。</li>
<li>对物品进行化学或机械转化，这是制造业的基础。</li>
<li>农业，通过将水、二氧化碳和肥料转化为作物和牲畜来创造价值。</li>
<li>建筑建设，由于建筑物无法轻易从一个地方搬到另一个地方，因此需要在现场制造。</li>
<li>从地球或太空中提取自然资源，包括采矿、石油钻探和捕鱼等。</li>
<li>治疗疾病或减轻症状，即医学。</li>
<li>寻找更高效或更有效的做法，即研究或发明。</li>
<li>为人们提供有用的信息，包括帮助供需匹配、解释规则和提供有用信息本身。</li>
</ul>
<p>文章最后提到，尽管许多人关注提供有用信息的领域，但直接将信息转化为金钱并不容易。现代计算机技术使得信息可以几乎免费复制，导致财富创造的同时很少被转化为金钱。然而，对于提供难以获取且对特定市场细分有用的信息，仍然可以通过这种方式赚钱。</p>
]]></content>
  </entry>
  <entry>
    <title>Hexo Commands</title>
    <url>/2023/08/19/hexo-commands/</url>
    <content><![CDATA[<h3 id="Hexo-命令"><a href="#Hexo-命令" class="headerlink" title="Hexo 命令"></a>Hexo 命令</h3><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>-p, –path</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-p, –path</td>
<td>自定义文章的路径</td>
</tr>
<tr>
<td>-r, –replace</td>
<td>如果存在同名文章，将其替换</td>
</tr>
<tr>
<td>-s, –slug</td>
<td>文章的slug， 作为新文章的文件名和发布后的url</td>
</tr>
</tbody></table>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me &quot;About me&quot;</span><br></pre></td></tr></table></figure>
<p>以上命令会创建一个 source&#x2F;about&#x2F;me.md 文件，同时 Front Matter 中的 title 为 “About me”</p>
<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me</span><br></pre></td></tr></table></figure>
<p>此时 Hexo 会创建 source&#x2F;_posts&#x2F;about&#x2F;me.md，同时 me.md 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。</p>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 添加分类和标签</title>
    <url>/2023/08/20/hexo_categories_tag/</url>
    <content><![CDATA[<h3 id="创建“分类”选项"><a href="#创建“分类”选项" class="headerlink" title="创建“分类”选项"></a>创建“分类”选项</h3><p>生成“分类”页并添加tpye属性,进入博客目录。执行命令下方命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>categories文件夹下会有index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2023-08-20 15:33:52</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>添加type: “categories”到内容中，添加后是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2023-08-20 15:33:52</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。<br>打开需要添加分类的文章，为其添加categories属性。下方的categories:Hexo表示这篇文章添加到到“Hexo”这个分类。注意：一篇文章只会添加到一个分类中，如果是多个默认放到第一个分类中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello Rust</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Rust学习资料</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p>
<h3 id="创建“标签”选项"><a href="#创建“标签”选项" class="headerlink" title="创建“标签”选项"></a>创建“标签”选项</h3><p>生成“标签”页并添加tpye属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>在tags文件夹下，找到index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2023-08-20 15:40:07</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加type: “tags”到内容中，添加后是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2023-08-20 15:40:07</span><br><span class="line">type: tag</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<p>给文章添加“tags”属性,打开需要添加标签的文章，为其添加tags属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello Rust</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Rust学习资料</span><br><span class="line">tag: Rust</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>maydat-lip-syncing</title>
    <url>/2023/12/04/mayday-lip-syncing/</url>
    <content><![CDATA[<h3 id="今日单词"><a href="#今日单词" class="headerlink" title="今日单词"></a>今日单词</h3><div align="center"> <img src="/images/lip-synches.png"/>今日单词</div>

<h1 id="Mayday-lip-synches-五月天假唱"><a href="#Mayday-lip-synches-五月天假唱" class="headerlink" title="Mayday lip-synches 五月天假唱"></a>Mayday lip-synches 五月天假唱</h1><h1 id="什么才是真正的摇滚精神？"><a href="#什么才是真正的摇滚精神？" class="headerlink" title="什么才是真正的摇滚精神？"></a>什么才是真正的摇滚精神？</h1><p>真正的摇滚精神是一种对自由、反叛和个人表达的热情。它代表着对传统观念的挑战，对权威和束缚的抗拒。摇滚精神鼓励个体追求自己的激情和独立思考，不受限制地表达自己的声音和观点。它强调对社会问题和不公正的关注，并通过音乐和艺术表达对这些问题的批判和反思。摇滚精神是一种生活态度，鼓励人们勇敢地追求自己的梦想，坚持自己的价值观，并与他人分享共同的热情和信念。</p>
<h2 id="一个歌手假唱意味着什么？"><a href="#一个歌手假唱意味着什么？" class="headerlink" title="一个歌手假唱意味着什么？"></a>一个歌手假唱意味着什么？</h2><p>一个歌手假唱意味着他或她在现场演出时并没有真正地唱歌，而是通过播放预先录制的音乐来模拟演唱。这通常被认为是一种不诚实和欺骗观众的行为，因为观众可能会认为他们正在观看一场真正的现场表演，而事实上，演出者并没有真正地展示他们的音乐才华。此外，假唱也可能违反某些演出和音乐产业的道德标准和规定。</p>
<h2 id="一个摇滚歌手假唱符合摇滚精神吗？他的内心能过的安宁吗？"><a href="#一个摇滚歌手假唱符合摇滚精神吗？他的内心能过的安宁吗？" class="headerlink" title="一个摇滚歌手假唱符合摇滚精神吗？他的内心能过的安宁吗？"></a>一个摇滚歌手假唱符合摇滚精神吗？他的内心能过的安宁吗？</h2><p>摇滚精神强调真实、自由和个人表达，因此一个摇滚歌手假唱与摇滚精神并不相符。假唱被认为是一种不诚实的行为，摇滚精神鼓励艺术家真实地展示他们的才华和表达自己的声音。假唱可能会削弱观众对艺术家的信任和尊重，破坏他们与观众之间的联系。</p>
<p>至于内心的安宁，这是一个个体的感受，每个人的体验可能不同。然而，对于许多艺术家来说，真实地表达自己是一种重要的价值观和追求。当一个摇滚歌手选择假唱时，可能会在内心产生不安和冲突，因为他们没有真正地展示自己的音乐才华和个人表达。因此，假唱可能会对他们的内心和艺术追求造成一定程度的困扰。</p>
<h2 id="演唱会假唱对于一个摇滚歌手来说属于轻微错误还是严重错误？"><a href="#演唱会假唱对于一个摇滚歌手来说属于轻微错误还是严重错误？" class="headerlink" title="演唱会假唱对于一个摇滚歌手来说属于轻微错误还是严重错误？"></a>演唱会假唱对于一个摇滚歌手来说属于轻微错误还是严重错误？</h2><p>对于一个摇滚歌手来说，演唱会假唱可以被认为是一个严重错误。摇滚音乐注重现场表演的真实性和能量，观众期望在演唱会上亲眼见证歌手的实力和情感投入。选择假唱可能会被认为是一种欺骗观众的行为，削弱了演唱会的真实性和互动性。这可能会对歌手的声誉和信任度造成负面影响，并引发观众的不满和失望。</p>
<p>然而，每个情况都是独特的，有时候摇滚歌手选择假唱可能是出于保护嗓子健康或其他技术或声音问题的考虑。因此，如何评价这个错误的严重程度可能因情况而异。但总体而言，对于一个摇滚歌手来说，选择假唱在摇滚音乐领域中可能被视为一个严重错误。</p>
]]></content>
  </entry>
  <entry>
    <title>Henry A.Kissinger 1923 – 2023</title>
    <url>/2023/11/29/kissinger-1923-2023/</url>
    <content><![CDATA[<h1 id="Henry-A-Kissinger-1923-–-2023"><a href="#Henry-A-Kissinger-1923-–-2023" class="headerlink" title="Henry A.Kissinger 1923 – 2023"></a>Henry A.Kissinger 1923 – 2023</h1><div align="center"> <img src="/images/kissinger-header.png"/></div>
Henry A. Kissinger was the 56th Secretary of State, a respected American scholar and Nobel Peace Prize Laureate who helped create the post-World War II world order and led the U.S. through some of its most complicated foreign policy challenges.
亨利·基辛格（Henry A. Kissinger）是第56任国务卿，是一位受人尊敬的美国学者和诺贝尔和平奖获得者，他帮助建立了二战后的世界秩序，并领导美国克服了一些最复杂的外交政策挑战。

<p>With his distinct German accent, sharp wit, voluminous writings and belief in the peacemaking power of realpolitik, Dr. Kissinger was one of the most influential foreign policy and national security practitioners of the post-World War II era and remained active in national security for more than 70 years. From the age of 20, when he joined the U.S. Army, to nearly his death, Dr. Kissinger continued to travel to Washington to offer testimony on U.S. national security strategy.<br>基辛格博士有着鲜明的德国口音、敏锐的机智、大量的著作以及对现实政治缔造和平力量的信念，是二战后最有影响力的外交政策和国家安全实践者之一，并在国家安全领域活跃了70多年。从20岁加入美国陆军到几近去世，基辛格博士继续前往华盛顿，为美国的国家安全战略提供证词。</p>
<p>As National Security Advisor and then Secretary of State during the Nixon and Ford Administrations, Dr. Kissinger was the author of some of those administrations’ most important, and sometimes controversial, policies.<br>作为尼克松和福特政府的国家安全顾问和国务卿，基辛格博士是这些政府中一些最重要、有时也是有争议的政策的作者。<br>He was instrumental to opening China to the Western world and was the primary voice of détente with the Soviet Union that lowered tensions during the Cold War, a reflection of his belief in the balance of power as a tenet of global order.<br>他在向西方世界开放中国方面发挥了重要作用，并且是冷战期间与苏联缓和关系的主要声音，缓解了紧张局势，这反映了他对力量平衡作为全球秩序原则的信念。</p>
<p>Before his government service, Dr. Kissinger served on the faculty at Harvard University, where he ran the International Seminar from 1952 to 1969.<br>在担任政府职务之前，基辛格博士曾在哈佛大学任教，并于 1952 年至 1969 年主持国际研讨会。</p>
<p>Dr. Kissinger is the recipient of a number of awards and recognitions. In 1945, he was awarded a Bronze Star from the U.S. Army for meritorious service. He received the Nobel Peace Prize in 1973, the same year a Gallup Poll of Americans listed him as the most admired person in the world. He was also awarded the nation’s highest civilian honor, the Presidential Medal of Freedom, in 1977 and the Medal of Liberty, given one time to ten foreign-born American leaders, in 1986.<br>基辛格博士是许多奖项和认可的获得者。1945年，他因功勋被美国陆军授予铜星勋章。他于1973年获得诺贝尔和平奖，同年，盖洛普美国人民意调查将他列为世界上最受尊敬的人。他还于1977年被授予美国最高平民荣誉总统自由勋章，并于1986年被授予自由勋章，该勋章曾授予十位外国出生的美国领导人。</p>
<p>As the architect of a lasting era of peace, stability, prosperity and global order, he made a substantial impact on generations of citizens, from the U.S. to Europe and China.<br>作为和平、稳定、繁荣和全球秩序的持久时代的缔造者，他对从美国到欧洲和中国的几代公民产生了重大影响。</p>
<p>“After 30 years he’s still public policy’s equivalent of a rock star.”<br>“30年后，他仍然是公共政策中的摇滚明星。</p>
<p>Norman Ornstein, 2002, Political Scholar<br>诺曼·奥恩斯坦（Norman Ornstein），2002年，政治学者<br>“I salute Henry Kissinger for his many efforts at peace and security.”<br>“我向亨利·基辛格致敬，感谢他为和平与安全所做的许多努力。</p>
<p>George Shultz, 2015, former Secretary of State<br>乔治·舒尔茨，2015年，前国务卿<br>“Dr. Kissinger is one of our Nation’s most accomplished and respected public servants.”<br>“基辛格博士是我们国家最有成就和最受尊敬的公务员之一。</p>
<p>President George W. Bush, 2002<br>乔治·W·布什总统，2002年<br>“Most secretaries of state reach their peak fame as they leave office. I venture to say that Henry Kissinger is perhaps more widely known in the world today than he was when he left… He is a synonym of global diplomacy.”<br>“大多数国务卿在卸任时都会达到顶峰。我冒昧地说，亨利·基辛格在当今世界上的知名度可能比他离开时更广为人知……他是全球外交的代名词。</p>
<p>Brent Scowcroft, 2012, former National Security Adviser<br>布伦特·斯考克罗夫特（Brent Scowcroft），2012年，前国家安全顾问<br>“While his contributions are far from complete, we are now beginning to appreciate what his service has provided our country, how it has changed the way we think about strategy and how he has helped provide greater security for our citizens and people around the world.”<br>“虽然他的贡献远未完成，但我们现在开始欣赏他的服务为我们的国家提供了什么，它如何改变了我们对战略的思考方式，以及他如何帮助我们的公民和世界各地的人民提供更大的安全。</p>
<p>Ashton Carter, 2016, former Secretary of Defense<br>阿什顿·卡特，2016年，前国防部长<br>“The United States, the world is greatly indebted to this superior person… He is, so far as this American is concerned, the greatest secretary of state in the history of our Republic. His superb record of achievement is unsurpassed in the annals of American history.”<br>“美国，全世界都非常感谢这位上等人……就这位美国人而言，他是我们共和国历史上最伟大的国务卿。他的卓越成就记录在美国历史上是无与伦比的。</p>
<p>President Gerald Ford, 1977<br>杰拉尔德·福特总统，1977年<br>“Henry Kissinger has played a central role in some of the most consequential U.S. foreign policy matters of the past half-century. He continues to be a highly influential figure in thinking about global affairs.”<br>“亨利·基辛格在过去半个世纪中一些最重要的美国外交政策事务中发挥了核心作用。在思考全球事务方面，他仍然是一个极具影响力的人物。</p>
<p>Harvard University President Drew Faust, 2012<br>哈佛大学校长德鲁·浮士德，2012年<br>“Dr. Kissinger wrote in his book, World Order, and I quote, that ‘each generation will be judged by whether the greatest, most consequential issues of the human condition have been faced…’ Let us work together to bring about an even better future for China-US relations.”<br>“基辛格博士在他的《世界秩序》一书中写道，’每一代人都将根据人类状况中是否面临过最重大、最重要的问题来评判……’让我们共同努力，开创中美关系更加美好的未来。</p>
<p>President Xi Jinping of China, 2015<br>中国国家主席习近平，2015年<br>“Dear Henry - It’s hard to believe that it has been more than forty-one years since you left office (I’m not far behind, with thirty-seven). There can be no doubt that our national Ship of State has often missed your hand at the tiller, though its steerpersons (sic) and captains have frequently sought your advice. Let’s hope that you, and indeed the Ship, will be around for a long time.”<br>“亲爱的亨利——很难相信你离任已经超过四十一年了（我也不甘落后，三十七年）。毫无疑问，我们的国家之船经常错过舵柄的手，尽管它的舵手（原文如此）和船长经常征求您的建议。让我们希望你，甚至这艘船，能存在很长一段时间。</p>
<p>Harold Brown, 2018, former Secretary of Defense and CSIS Counselor and Trustee<br>哈罗德·布朗（Harold Brown），2018年，前国防部长兼CSIS顾问和受托人<br>“Congratulations, Dr. Kissinger, on your 95th birthday! The Friedrich Wilhelms University Bonn established a permanent Henry Kissinger Chair to honor you for your outstanding strategic foresight and diplomatic contributions to world order and diplomacy. This German generation knows Immanuel Kant’s wisdom that peace is not a given, it does not come from itself. Germany has accepted greater international responsibility and draws on your understanding that success as a statesman rests on the study of history to understand why nations succeed and why they failed.”<br>“恭喜基辛格博士，你95岁生日！波恩弗里德里希·威廉大学设立了亨利·基辛格常设教席，以表彰您杰出的战略远见和对世界秩序和外交的外交贡献。这一代人知道伊曼纽尔·康德（Immanuel Kant）的智慧，即和平不是给定的，它不是来自自身。德国已经承担了更大的国际责任，并借鉴了你们的理解，即作为政治家的成功取决于对历史的研究，以了解国家为什么成功，为什么失败。</p>
<p>Professor James Bindenagel, Henry Kissinger Professor, Bonn, 2018<br>詹姆斯·宾德纳格尔教授，亨利·基辛格教授，波恩，2018</p>
<h2 id="Early-Life-早年生活"><a href="#Early-Life-早年生活" class="headerlink" title="Early Life 早年生活"></a>Early Life 早年生活</h2><p>Henry A. Kissinger was born to a schoolteacher and a homemaker in Furth, Germany, in 1923, just as nationalism was beginning to sweep Germany. As Jews, the Kissinger family found many activities were off-limits, including attending public soccer matches, a sport that Dr. Kissinger loved, even if he did not excel in it. What he may have lacked in athletic talent, however, he made up for in academics. As a child, he was bookish and introverted, yet also competitive.<br>亨利·基辛格（Henry A. Kissinger）于1923年出生于德国富尔特（Furth）的一名教师和家庭主妇，当时民族主义刚刚开始席卷德国。作为犹太人，基辛格一家发现许多活动都是禁止的，包括参加公共足球比赛，这是基辛格博士喜欢的运动，即使他并不擅长这项运动。然而，他可能在运动天赋方面有所欠缺，但他在学业上弥补了这一点。小时候，他书卷气十足，性格内向，但也很争强好胜。</p>
<div align="center"> <img src="/images/Early_life_1-658x1024.jpg"/></div>

<p>In 1935, the Nuremburg Laws were enacted, and Dr. Kissinger’s father, Louis, became a casualty of the rules, losing his job as a schoolteacher. Dr. Kissinger’s mother recognized that leaving Germany was the family’s best hope for their future and in 1938, three months before Kristallnacht, Dr. Kissinger, his younger brother Walter and their parents fled Nazi Germany and settled in New York City.<br>1935年，《纽伦堡法》颁布，基辛格博士的父亲路易斯成为该法的牺牲品，失去了教师的工作。基辛格的母亲认识到，离开德国是这个家庭未来的最大希望，1938年，在水晶之夜前三个月，基辛格博士、他的弟弟沃尔特和他们的父母逃离纳粹德国，定居在纽约市。</p>
<p>Many of his extended family were not able to escape, and 13 of them perished in the Holocaust. Well into his 80s, Dr. Kissinger remarked that people managed to survive the Holocaust through “singleness of purpose,” a trait that defined him throughout his career.<br>他的许多大家庭都无法逃脱，其中13人在大屠杀中丧生。基辛格博士在80多岁时表示，人们通过“单一目标”在大屠杀中幸存下来，这是他整个职业生涯的特征。</p>
<h2 id="New-Beginnings-in-America-美国的新起点"><a href="#New-Beginnings-in-America-美国的新起点" class="headerlink" title="New Beginnings in America 美国的新起点"></a>New Beginnings in America 美国的新起点</h2><p>Dr. Kissinger’s experience of fleeing a country where he once had to cross the street to avoid being beaten by non-Jewish boys, and coming to a country where such persecution did not exist for him, was a transformative one. Upon arriving in America, he was keen to be considered an American. As he later reflected in his farewell speech as Secretary of State, “When I came here in 1938, I was asked to write an essay at George Washington High School about what it meant to be an American. I wrote that…this was a country where one could walk across the street with one’s head erect.”<br>基辛格博士逃离了一个他曾经不得不过马路以避免被非犹太男孩殴打的国家，来到一个对他来说不存在这种迫害的国家，这是一次变革性的经历。抵达美国后，他渴望被视为美国人。正如他后来在作为国务卿的告别演说中所说，“当我1938年来到这里时，我被要求在乔治华盛顿高中写一篇关于作为一个美国人意味着什么的文章。我写道……这是一个可以昂首挺胸走过马路的国家。</p>
<p>In America, Dr. Kissinger plunged into his studies at George Washington High. He eventually transitioned to night school so that he could maintain a job at a shaving brush company by day. Good grades coupled with a steady work ethic made it easy for Dr. Kissinger to get into City College of New York, where he enjoyed a free education. His goal was to become an accountant, but time in the Army would set his life on a different path.<br>在美国，基辛格博士在乔治华盛顿高中投入研究。他最终转入夜校，这样他就可以在白天在剃须刷公司工作。良好的成绩加上稳定的职业道德，使基辛格博士很容易进入纽约市立学院，在那里他享受了免费教育。他的目标是成为一名会计师，但在军队中度过的时光使他的生活走上了不同的道路。</p>
<h2 id="A-lifetime-of-service-终身服务。"><a href="#A-lifetime-of-service-终身服务。" class="headerlink" title="A lifetime of service. 终身服务。"></a>A lifetime of service. 终身服务。</h2><p><a href="https://www.henryakissinger.com/timeline/">See the timeline →</a><br><a href="https://www.henryakissinger.com/timeline/">查看时间线→</a></p>
<h2 id="Service-to-Country-服务国家"><a href="#Service-to-Country-服务国家" class="headerlink" title="Service to Country 服务国家"></a>Service to Country 服务国家</h2><p>In 1943, the year he became a U.S. citizen, Dr. Kissinger was drafted into the U.S. Army, where his intellect and fluency in German would make him a perfect candidate for military intelligence. His intellectual abilities earned him a placement in the Army Specialized Training Program, an opportunity that sent him from combat training to college instead. Dr. Kissinger was sent to Lafayette College in Pennsylvania, where he studied engineering, read books on history in his spare time, and tutored other students.<br>1943年，基辛格博士成为美国公民，被征召入伍，他的智慧和流利的德语使他成为军事情报部门的完美人选。他的智力为他赢得了陆军专业训练计划的安置，这个机会使他从战斗训练进入了大学。基辛格博士被送到宾夕法尼亚州的拉斐特学院，在那里他学习工程学，在业余时间阅读历史书籍，并辅导其他学生。</p>
<p>In 1944, however, the Army canceled the program, and Dr. Kissinger was returned to Camp Claiborne in Louisiana. From Camp Claiborne, Dr. Kissinger was assigned to the 84th Infantry Division, which set sail from New York to Europe in September 1944 as part of the pursuit phase of the war. When he arrived back in his homeland of Germany, Dr. Kissinger was quickly selected to become a German translator for General Alexander Bolling. Later, in the Battle of the Bulge, when most of the division was forced to withdraw, Dr. Kissinger volunteered to stay behind to be part of hazardous counter-intelligence duties, making good use of his German.<br>然而，在1944年，陆军取消了该计划，基辛格博士被送回路易斯安那州的克莱伯恩营。从克莱伯恩营出发，基辛格博士被分配到第 84 步兵师，该师于 1944 年 9 月从纽约启航前往欧洲，作为战争追击阶段的一部分。回到家乡德国后，基辛格博士很快被选为亚历山大·博林将军的德语翻译。后来，在突出部战役中，当该师的大部分部队被迫撤退时，基辛格博士自愿留下来，成为危险的反情报职责的一部分，充分利用了他的德语。</p>
<p>When the 84th Division later captured the German town of Krefeld on the Rhine River, Dr. Kissinger became the town’s administrator — relying on his language skills and his understanding of the German culture to command authority. He succeeded in restoring order and building a civilian government in the town in little more than a week, a success that enabled him to transfer to the Counter-Intelligence Corps (CIC). The mission was to identify Nazis and members of the Gestapo in areas that the Allies had captured. His work there would earn him a Bronze Star.<br>当第84师后来占领了莱茵河畔的德国小镇克雷费尔德时，基辛格博士成为该镇的行政长官——依靠他的语言技能和对德国文化的理解来指挥权威。他在短短一周多的时间里成功地恢复了秩序，并在镇上建立了一个文职政府，这一成功使他能够转移到反情报部队（CIC）。任务是在盟军占领的地区识别纳粹分子和盖世太保成员。他在那里的工作为他赢得了铜星勋章。</p>
<p>Dr. Kissinger’s work in the CIC would continue even after the war had ended, as he was called upon to provide order and detect Nazis in Hesse. He kept any feelings of anger or resentment toward the Germans — who had forced his family to flee less than a decade earlier — beneath the surface. Dr. Kissinger operated with remarkable restraint.<br>即使在战争结束后，基辛格博士在中央情报局的工作仍在继续，因为他被要求在黑森州提供秩序并侦查纳粹分子。他对德国人的任何愤怒或怨恨都隐藏在表面之下——德国人在不到十年前迫使他的家人逃离。基辛格博士非常克制。</p>
<p>In 1946, he was discharged from the Army, having obtained the rank of sergeant. As he would later reflect, his military service would become for him the highlight of his career, and also one that affirmed his American identity and gave him confidence.<br>1946年，他从陆军退伍，获得了中士军衔。正如他后来所反映的那样，服兵役将成为他职业生涯的亮点，也是肯定他的美国身份并给予他信心的亮点。</p>
<h2 id="Academia-学术界"><a href="#Academia-学术界" class="headerlink" title="Academia 学术界"></a>Academia 学术界</h2><p>Following his service in the Army, and a brief stint teaching military officers in Germany, Dr. Kissinger returned to academics, earning his B.A., M.A. and Ph.D. from Harvard University. Legend has it that his doctoral dissertation was, and remains, the longest dissertation ever submitted at Harvard University.<br>在军队服役并在德国短暂教授军官后，基辛格博士重返学术界，在哈佛大学获得学士、硕士和博士学位。传说他的博士论文是，现在仍然是哈佛大学有史以来最长的论文。</p>
<p>As the son of an educator, Dr. Kissinger wavered early on between a life in academia and a life on the front lines of shaping foreign policy. Before entering government, he held a variety of academic and think-tank posts: at Harvard University, his alma mater, where he was a professor of government; at the Rockefeller Brothers Fund; at the Council on Foreign Relations; and many others.<br>作为教育家的儿子，基辛格博士很早就在学术界的生活和制定外交政策的前线生活之间摇摆不定。在进入政府部门之前，他担任过各种学术和智囊团职位：在他的母校哈佛大学担任政府学教授;洛克菲勒兄弟基金会;在外交关系委员会;还有很多其他的。</p>
<p>At Harvard, perhaps his most passionate pursuit, and a formative precursor to his career as an international diplomat, was the International Seminar that he founded in 1952 and ran until 1969. The seminar brought together about 40 foreign dignitaries each summer for classes, lectures and, most importantly, networking sessions. Through the seminar, Dr. Kissinger built a wide base of foreign contacts with whom he could conduct direct diplomacy, including contacts in China, Europe and Latin America.<br>在哈佛，也许是他最热情的追求，也是他作为国际外交官职业生涯的形成性先驱，是他于1952年创立并一直持续到1969年的国际研讨会。每年夏天，该研讨会都会聚集约40位外国政要参加课程、讲座，最重要的是，参加社交会议。通过这次研讨会，基辛格博士建立了广泛的对外联系基础，他可以与他们进行直接外交，包括在中国、欧洲和拉丁美洲的联系。</p>
<p>It was also during his time in academia that Dr. Kissinger refined his belief in the balance of power, linkage and triangular diplomacy. This would become the driving philosophy of his time as Secretary of State. His dissertation, Peace, Legitimacy, and the Equilibrium: A Study of the Statesmanship of Castlereagh and Metternich, argued that peace and stability do not come from the pursuit of peace per se. Rather, he looked at the diplomatic successes of Klemens von Metternich and Congress of Europe and concluded that peace comes from “an international agreement about the nature of workable arrangements and the permissible aims and methods of foreign policy. It implies the acceptance of the framework of international order by all major powers.” While Dr. Kissinger’s approach to peace through rules, power and stability was controversial, it also led to his greatest accomplishments.<br>也是在学术界期间，基辛格博士完善了他对权力平衡、联系和三角外交的信念。这将成为他担任国务卿期间的驱动哲学。他的论文《和平、合法性和均衡：卡斯尔雷和梅特涅政治家风度研究》认为，和平与稳定并非来自对和平本身的追求。相反，他研究了克莱门斯·冯·梅特涅（Klemens von Metternich）和欧洲会议（Congress of Europe）的外交成功，并得出结论，和平来自“关于可行安排的性质以及外交政策的允许目标和方法的国际协议。它意味着所有大国都接受国际秩序的框架。虽然基辛格博士通过规则、权力和稳定实现和平的方法存在争议，但它也导致了他最伟大的成就。</p>
<div align="center"> <img src="/images/Academia_1.png"/></div>

<h2 id="Global-Statesman-全球政治家"><a href="#Global-Statesman-全球政治家" class="headerlink" title="Global Statesman 全球政治家"></a>Global Statesman 全球政治家</h2><p>Though successful in academia, Dr. Kissinger longed to have a direct impact on policy. He entered the political arena in 1960, serving as a senior foreign policy advisor to Gov. Nelson Rockefeller’s presidential campaigns in 1960, 1964 and 1968. When Rockefeller lost the Republican nomination in 1968, Dr. Kissinger, reluctantly at first, joined the campaign of the party nominee, Richard Nixon.<br>虽然在学术界取得了成功，但基辛格博士渴望对政策产生直接影响。他于 1960 年进入政坛，在 1960 年、1964 年和 1968 年担任纳尔逊·洛克菲勒州长总统竞选活动的高级外交政策顾问。1968年，洛克菲勒在共和党提名中落败，基辛格起初不情愿地加入了该党提名人理查德·尼克松（Richard Nixon）的竞选活动。</p>
<p>Following Nixon’s victory, Dr. Kissinger was named Assistant to the President for National Security Affairs and then National Security Advisor. In this capacity, and eventually as Secretary of State, Dr. Kissinger deftly guided the U.S. through many of the most difficult national security issues the nation would face.<br>尼克松获胜后，基辛格博士被任命为总统国家安全事务助理，然后被任命为国家安全顾问。在这个职位上，并最终作为国务卿，基辛格博士巧妙地指导美国解决了美国将面临的许多最困难的国家安全问题。</p>
<div align="center"> <img src="/images/Influence_5.png"/></div>

<p>He led the Administration’s historic efforts to open relations with China — ultimately opening the door to greater stability between the nations, greater prosperity for the citizens within, and normalized relations between the two countries for the first time in decades. Specifically, in 1971 Dr. Kissinger made two secret trips to China, laying the groundwork for Nixon’s visit to the Republic the following year.<br>他领导了本届政府开放与中国关系的历史性努力，最终为两国之间的更大稳定、国内公民的更大繁荣以及两国关系几十年来首次正常化打开了大门。具体来说，1971年，基辛格博士两次秘密访华，为尼克松次年访华奠定了基础。</p>
<div align="center"> <img src="/images/statesman_2.png"/></div>

<p>Dr. Kissinger believed in the power of triangulation as a tool for diplomacy, and this can be seen in his near-concurrent negotiations with China and the Soviet Union, as well — connecting the world’s three superpowers at the time. Dr. Kissinger later reflected that the triangular relationship was “in itself a form of pressure on each of them, and we carefully maneuvered so we would try to be closer to each than they were to each other.”<br>基辛格博士相信三角测量作为外交工具的力量，这可以从他与中国和苏联几乎同时进行的谈判中看出——当时连接了世界上三个超级大国。基辛格博士后来反映说，三角关系“本身就是对他们每个人施加压力的一种形式，我们小心翼翼地操纵着，所以我们会努力更接近彼此，而不是彼此之间。</p>
<p>“The triangular relationship between the U.S., Soviet Union and China was ‘in itself a form of pressure on each of them, and we carefully maneuvered so we would try to be closer to each than they were to each other.”<br>“美国、苏联和中国之间的三角关系’本身就是对彼此施加压力的一种形式，我们小心翼翼地操纵着，所以我们会努力更接近彼此，而不是彼此之间。<br>Ultimately, Dr. Kissinger was influential in achieving the historic détente between the United States and the Soviet Union through the 1972 Strategic Arms Limitation Treaty (SALT I) and the Anti-Ballistic Missile Treaty. In doing so, he helped to ease tensions between the world’s two superpowers amidst the tension of the Cold War era, achieving a vision for a global order that would preserve peace.<br>最终，基辛格博士通过1972年《限制战略武器条约》（SALT I）和《反弹道导弹条约》实现了美苏之间的历史性缓和，发挥了重要作用。在此过程中，他帮助缓解了冷战时期紧张局势中的世界两个超级大国之间的紧张关系，实现了维护和平的全球秩序的愿景。</p>
<div align="center"> <img src="/images/Statesman_3-1024x623.jpg"/></div>

<div align="center"> <img src="/images/Statesman_4.png"/></div>
Dr. Kissinger also worked to end America’s involvement in the Vietnam War through the Paris Peace Accords. Dr. Kissinger recognized that the conflict could not be won in conventional military terms, so he set about trying to secure peace through active diplomacy. Soon after the Nixon Administration took office in 1969, Dr. Kissinger began painstaking negotiations that lasted nearly four years. In 1973, Dr. Kissinger and the North Vietnamese negotiator struck a deal for a ceasefire that ended American involvement in the war. That same year, he received plaudits for limiting the damage of, and outside influence in, the Yom Kippur War between America’s ally Israel, and the Soviet Union’s ally Egypt — ultimately preventing the regional conflict from spiraling into a global conflict. It was this experience that helped coin the term “shuttle diplomacy,” for the number of short trips Dr. Kissinger took between Middle Eastern capitals, as he worked to contain the military activities and to address the fallout of the war.
基辛格博士还致力于通过《巴黎和平协定》结束美国对越南战争的参与。基辛格博士认识到，以常规军事手段无法赢得这场冲突，因此他开始试图通过积极的外交手段确保和平。1969年尼克松政府上台后不久，基辛格博士就开始了历时近四年的艰苦谈判。1973年，基辛格博士和北越谈判代表达成了停火协议，结束了美国对战争的介入。同年，他因限制美国盟友以色列和苏联盟友埃及之间的赎罪日战争的损害和外部影响而受到赞誉，最终阻止了地区冲突升级为全球冲突。正是这段经历帮助创造了“穿梭外交”一词，基辛格博士在中东各国首都之间进行了多次短途旅行，因为他努力遏制军事活动并解决战争的后果。

<p>In January 1974, over the course of 8 days, Dr. Kissinger worked to negotiate the first Egyptian-Israeli disengagement agreement, and later that spring he arranged a Syrian-Israeli disengagement. The following year, his shuttle diplomacy helped to arrange one final negotiation through a second Egyptian-Israeli disengagement agreement.<br>1974 年 1 月，在 8 天的时间里，基辛格博士致力于谈判第一份埃及-以色列脱离接触协议，并于当年春天晚些时候安排了叙利亚-以色列脱离接触。次年，他的穿梭外交通过第二份埃及-以色列脱离接触协议帮助安排了最后一次谈判。</p>
<p>A force for international stability, Dr. Kissinger was also a steady hand at home when the Nixon Administration was caught in twin scandals that overwhelmed all other matters. As President Nixon was under siege from the Watergate investigation and Vice President Spiro Agnew was about to resign due to corruption allegations, Dr. Kissinger was critical to keeping the Administration afloat. Serving as a credible face for foreign leaders when many other major players in the Nixon Administration were tainted by the Watergate scandal, Dr. Kissinger held the country together on the international stage.<br>基辛格博士是国际稳定的力量，当尼克松政府陷入压倒所有其他事务的双重丑闻时，基辛格博士在国内也是一个稳定的手。当尼克松总统受到水门事件调查的围攻，副总统斯皮罗·阿格纽（Spiro Agnew）因腐败指控而即将辞职时，基辛格博士对维持政府的运转至关重要。当尼克松政府的许多其他主要人物受到水门事件丑闻的玷污时，基辛格博士是外国领导人的可信面孔，他在国际舞台上将国家团结在一起。</p>
<p>While his choices were not without controversy, and his behavior — as he operated with single-minded intent to realize his vision — was sometimes maddening to colleagues, Dr. Kissinger was aware of who he was, and owned it. In his own words, “Accept everything about yourself — I mean everything. You are you and that is the beginning and the end — no apologies, no regrets.”<br>虽然他的选择并非没有争议，而且他的行为——他一心一意地实现自己的愿景——有时会让同事们抓狂，但基辛格博士知道自己是谁，并拥有它。用他自己的话说，“接受关于你自己的一切——我的意思是一切。你就是你，这就是开始和结束——没有道歉，没有遗憾。</p>
<h2 id="Enduring-Influence-持久的影响"><a href="#Enduring-Influence-持久的影响" class="headerlink" title="Enduring Influence 持久的影响"></a>Enduring Influence 持久的影响</h2><p>After Dr. Kissinger stepped down as Secretary of State, he remained an advisor and voice on matters of foreign policy. At the bequest of President Ronald Reagan, Dr. Kissinger chaired the National Bipartisan Commission on Central America, and would later serve on the President’s Foreign Intelligence Advisory Board under Presidents Reagan and George H.W. Bush.<br>基辛格博士卸任国务卿后，他仍然是外交政策事务的顾问和代言人。在罗纳德·里根总统的遗赠下，基辛格博士担任了中美洲国家两党委员会主席，后来在里根总统和乔治·H·W·布什总统的领导下担任总统外国情报顾问委员会的成员。</p>
<div align="center"> <img src="/images/Influence_1.png"/></div>
<div align="center"> <img src="/images/Influence_2.png"/></div>
<div align="center"> <img src="/images/Influence_3.png"/></div>
<div align="center"> <img src="/images/Influence_4.png"/></div>
<div align="center"> <img src="/images/Influence_5.png"/></div>

<p>After leaving government, Dr. Kissinger remained a frequent commentator on national security issues, as well as a prolific writer and founder of the consulting firm Kissinger Associates. As such, he remained an informal, but frequent, advisor to U.S. presidents, and he welcomed and met with countless heads of state and dignitaries from nearly every country in the world.<br>离开政府后，基辛格博士仍然经常就国家安全问题发表评论，也是一位多产的作家和咨询公司基辛格协会的创始人。因此，他仍然是美国总统的非正式顾问，但经常担任顾问，他欢迎并会见了来自世界上几乎每个国家的无数国家元首和政要。</p>
<p>He published 21 books, including 2014’s World Order, 1994’s Diplomacy which has become essential reading for those who study international affairs and U.S. diplomacy, and 2011’s On China, as well as memoirs covering his time in the White House and as Secretary of State.<br>他出版了21本书，包括2014年的《世界秩序》、1994年的《外交》，该书已成为研究国际事务和美国外交的人的必读书目，以及2011年的《论中国》，以及涵盖他在白宫和担任国务卿期间的回忆录。</p>
<p>With his sharp wit and encyclopedic knowledge of philosophy, history and current events, Dr. Kissinger was known as one of the most quotable men in Washington. His most famous witticisms include his observations that “nobody will ever win the battle of the sexes. There’s too much fraternizing with the enemy,” and that “there can’t be a crisis this week. My schedule is already full.”<br>凭借其敏锐的机智和对哲学、历史和时事的百科全书式知识，基辛格博士被称为华盛顿最容易被引用的人之一。他最著名的诙谐包括他的观察：“没有人会赢得两性之战。与敌人有太多的兄弟情谊“，并且”本周不会有危机。我的日程安排已经排得满满的。</p>
<p>He was also aware of his own reputation for having a healthy ego. As he once said during a speech, “I want to thank you for stopping the applause. It’s impossible for me to look humble for any period of time.”<br>他也意识到自己拥有健康的自我的声誉。正如他曾经在一次演讲中所说，“我要感谢你停止了掌声。我不可能在任何一段时间内显得谦虚。</p>
<p>And yet, it was an ego that was earned. International stateman, lifelong scholar, skilled negotiator and architect of a lasting era of peace, stability, prosperity and global order — Dr. Kissinger’s impact on generations of citizens, from the U.S. to China, cannot be minimized.<br>然而，这是一个挣来的自我。基辛格博士是一位国际政治家、终身学者、熟练的谈判者，也是和平、稳定、繁荣和全球秩序的持久时代的缔造者——基辛格博士对从美国到中国的几代公民的影响不容小觑。</p>
<p>Dr. Kissinger is survived by his wife Nancy, his two grown children and five grandchildren.<br>基辛格博士幸存下来的是他的妻子南希、他的两个成年子女和五个孙子孙女。</p>
<p>In lieu of flowers the family suggests considering donations to:<br>为了代替鲜花，家人建议考虑捐赠给：</p>
<p>Animal Medical Center 动物医疗中心</p>
<p>Development Office 发展办公室</p>
<p>510 East 62nd Street<br>东62街510号</p>
<p>New York, NY 10065<br>纽约， NY 10065</p>
<p>Henry A. Kissinger Center for Global Affairs<br>亨利·基辛格全球事务中心</p>
<p>Johns Hopkins University School of Advanced International Studies<br>约翰霍普金斯大学高级国际研究学院</p>
<p>1717 Massachusetts Avenue, NW<br>1717马萨诸塞大道，西北</p>
<p>Washington, DC 20036 华盛顿特区 20036</p>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>历史事件</tag>
      </tags>
  </entry>
  <entry>
    <title>PEP 703（使全局解释器锁在 CPython 中可选）验收</title>
    <url>/2023/10/27/pep-703-making-the-global-interpreter-lock-optional-in-cpython-acceptance/</url>
    <content><![CDATA[<h3 id="PEP-703（使全局解释器锁在-CPython-中可选）验收"><a href="#PEP-703（使全局解释器锁在-CPython-中可选）验收" class="headerlink" title="PEP 703（使全局解释器锁在 CPython 中可选）验收"></a>PEP 703（使全局解释器锁在 CPython 中可选）验收</h3><p>(Posted for the whole Steering Council.)<br>（发布给整个指导委员会。)</p>
<p>As we’ve <a href="https://discuss.python.org/t/a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython/30474">announced before</a>, the Steering Council has decided to accept <a href="https://peps.python.org/pep-0703/">PEP 703 (Making the Global Interpreter Lock Optional in CPython)</a> . We want to make it clear why, and under what expectations we’re doing so.<br>正如我们之前<a href="https://discuss.python.org/t/a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython/30474">宣布</a>的，指导委员会已决定接受<a href="https://peps.python.org/pep-0703/">PEP 703（使CPython中的全局解释器锁可选）</a>。我们想明确说明为什么，以及我们这样做的期望。</p>
<p>It is clear to the Steering Council that theoretically, a no-GIL (or free-threaded) Python would be of great benefit, and the majority of the community seems in agreement. Threads have significant downsides and caveats, but they are widely adopted, both by software and hardware, and they do enable more scalable solutions to problems. The GIL clearly inhibits CPython in this, and removing that barrier would be a good thing.<br>指导委员会很清楚，从理论上讲，无 GIL（或自由线程）Python 将大有裨益，社区的大多数人似乎都同意这一点。线程有明显的缺点和警告，但它们被软件和硬件广泛采用，并且它们确实为问题提供了更具可扩展性的解决方案。GIL在这方面显然抑制了CPython，消除这种障碍将是一件好事。</p>
<p>At the same time we’re not sure if it’s possible to remove the GIL without fundamentally breaking all extension modules out there, or significantly reducing the performance or maintainability of CPython. The third-party&#x2F;PyPI package ecosystem is one of Python’s strengths, and the tight, efficient integration with C libraries is one of CPython’s. It has enabled the existence of a diverse selection of packages that’s a unique selling point for Python. We need to be careful that we do not destroy those benefits, or discard decades worth of package development.<br>同时，我们不确定是否可以在不从根本上破坏所有扩展模块的情况下删除 GIL，或者显着降低 CPython 的性能或可维护性。第三方&#x2F;PyPI 包生态系统是 Python 的优势之一，与 C 库的紧密、高效集成是 CPython 的优势之一。它使各种包的存在成为可能，这是Python的独特卖点。我们需要小心，不要破坏这些好处，或者放弃几十年的软件包开发。</p>
<p>Assessing the practical impact, and the practicality of adapting third-party packages to the new free-threaded situation, is difficult without a finished implementation. The unpredictable nature of thread-related issues makes it extra difficult, as some issues won’t show up until put under significant load. The changes necessary to remove the GIL are substantive enough, and require so much coordination with other CPython development happening at the same time, that we can’t reasonably do these experiments in a fork of CPython. We also want to avoid the risk of ecosystem fragmentation and unnecessarily diverging changes because of the work being done in a fork. For PEP 703 to move forward, it has to be included in CPython’s main, and released as part of regular releases (albeit not necessarily by default).<br>如果没有完成的实现，评估实际影响以及使第三方包适应新的自由线程情况的实用性是很困难的。线程相关问题的不可预测性使其变得格外困难，因为某些问题在承受大量负载之前不会显示出来。删除 GIL 所需的更改是实质性的，并且需要与同时发生的其他 CPython 开发进行如此多的协调，以至于我们无法合理地在 CPython 的分支中进行这些实验。我们还希望避免由于分叉中所做的工作而导致生态系统碎片化和不必要的差异变化的风险。为了使PEP 703向前发展，它必须包含在CPython的主版本中，并作为常规版本的一部分发布（尽管不一定是默认的）。</p>
<p>But while we think removal of the GIL is a worthy and necessary goal, and PEP 703 is the best proposal for it so far, we can’t at this stage guarantee that it will work out. We have to, as we develop PEP 703’s implementation and the necessary user-visible changes to semantics, APIs and ABIs, continually evaluate the feasibility, and be prepared to change course – or reverse it, if that turns out to be necessary.<br>但是，虽然我们认为取消 GIL 是一个有价值且必要的目标，并且 PEP 703 是迄今为止最好的建议，但我们不能在现阶段保证它会成功。当我们开发PEP 703的实现以及对语义，API和ABI的必要用户可见更改时，我们必须不断评估可行性，并准备改变方向 - 或者在必要时扭转它。</p>
<p>As mentioned before, we see this as a rollout in roughly three stages:<br>如前所述，我们认为这是大约三个阶段的推出：</p>
<ul>
<li>Phase I: Experimental phase, which can start immediately, in which the free-threaded build is enabled through a build-time option. This should not be the default install anywhere. At least one major Python release should include this experimental free-threaded build, to allow third-party packages to test and do their own experimentation. In this stage we should make it clear the build is experimental, not supported for “production use”, and may be reverted.<br>阶段 I：实验阶段，可以立即开始，其中通过构建时选项启用自由线程构建。这不应该是任何地方的默认安装。至少一个主要的 Python 版本应该包含这个实验性的自由线程构建，以允许第三方包进行测试并进行自己的实验。在此阶段，我们应该明确构建是实验性的，不支持“生产用途”，并且可以还原。</li>
<li>Phase II: Supported-but-not-default phase, which would start when the API and ABI changes have sufficiently settled, and there is sufficient community support. Exact criteria for this phase are hard to pin down at this stage, so this will have to involve some discussion among Core Devs and the community, and a decision by the SC at the time. At this point reverting should still be possible (so for example preprocessor guards should remain in place) although obviously we aren’t expecting it.<br>第二阶段：支持但非默认阶段，当 API 和 ABI 更改充分解决并且有足够的社区支持时，该阶段将开始。在这个阶段很难确定这个阶段的确切标准，所以这必须涉及核心开发人员和社区之间的一些讨论，以及当时SC的决定。在这一点上，恢复应该是可能的（因此，例如预处理器保护应该保留在原位），尽管显然我们并不期望它。</li>
<li>Phase III: Default phase, at which point the free-threaded build becomes the default (but can initially still be disabled). Again, the exact criteria are hard to pin down this far ahead, but the aim is to make this as seamless and painless a default flip as possible. Like the previous phase, the SC at the time will need to make a decision as to when this occurs. Some time after the default flip, when we have a good indication it’s no longer widely used, we should start the discussion on removing the GIL build entirely.<br>阶段 III：默认阶段，此时自由线程构建成为默认阶段（但最初仍可禁用）。同样，确切的标准很难确定这么远，但目的是使它尽可能无缝和无痛地默认翻转。与上一阶段一样，当时的SC需要决定何时发生这种情况。在默认翻转后的一段时间，当我们有一个很好的指示它不再被广泛使用时，我们应该开始讨论完全删除 GIL 构建。<br>The details of the phases are deliberately vague, simply because we can’t know all the ecosystem impact details yet, and we don’t want to set conservative standards now and then hold people to them when in practice we’re being too cautious. (We don’t want to set overly ambitious goals and break too many things, either.)<br>这些阶段的细节故意含糊不清，仅仅是因为我们还不能知道所有的生态系统影响细节，我们不想现在设定保守的标准，然后在实践中我们过于谨慎时让人们遵守这些标准。（我们也不想设定过于雄心勃勃的目标，也不想破坏太多的东西。</li>
</ul>
<p>For some of the changes necessary for the free-threaded build, like switching to <a href="https://github.com/microsoft/mimalloc">mimalloc</a> or significant changes to the GC, it may be useful to make these separately build-time opt-ins, and perhaps make them the default before the free-threaded build becomes the default build (but not before it becomes fully supported). Having them separately enableable allows for experimentation, performance measurements and debugging focusing on the isolated set of changes. We don’t want a complex matrix of build flags, so this should probably be limited to one or two.<br>对于自由线程构建所需的某些更改，例如切换到<a href="https://github.com/microsoft/mimalloc">mimalloc</a>或对 GC 进行重大更改，进行这些单独的构建时选择加入可能很有用，并且可能在自由线程构建成为默认构建之前将它们设为默认值（但不是在它完全受支持之前）。让它们单独启用允许实验、性能测量和调试，重点是孤立的一组更改。我们不想要一个复杂的构建标志矩阵，所以这可能应该限制在一个或两个。</p>
<p>Regarding the expected performance impact of the free-threaded build, the SC thinks a significant performance penalty is expected in a free-threaded build, and the benefit is probably worth that price. At this point we’re expecting a (worst case) performance penalty of 10-15%. We don’t want to set strict limits on acceptable performance, partly because we don’t want to get stuck in arguments about how to measure performance and partly because it will depend on user expectations and, for example, how much performance work is invalidated and how much we can expect to see recuperated over time. Solutions for the free-threaded build that are fundamentally problematic for performance improvements going forward, are less acceptable than solutions that are currently suboptimal but have room for improvement.<br>关于自由线程构建的预期性能影响，SC 认为自由线程构建中预计会出现显著的性能损失，其好处可能值得这个价格。在这一点上，我们预计（最坏情况）性能损失为 10-15%。我们不想对可接受的性能设置严格的限制，部分原因是我们不想陷入关于如何衡量性能的争论中，部分原因是这将取决于用户的期望，例如，有多少性能工作无效，以及我们可以期望看到多少随着时间的推移而恢复。自由线程构建的解决方案从根本上对未来的性能改进存在问题，与当前次优但有改进空间的解决方案相比，这些解决方案更不可接受。</p>
<p>The performance impact should be isolated to a free-threaded build; a GIL build should not see any performance impact in existing code. For API and ABI changes necessary to support both GIL and free-threaded builds (e.g. avoiding APIs that return borrowed references or that rely on the GIL to protect shared data), it’s reasonable for the new interfaces to be slightly less performant, but we expect this to be very limited and usually lost in the noise.<br>性能影响应隔离到自由线程生成;GIL 生成不应在现有代码中看到任何性能影响。对于支持 GIL 和自由线程构建所需的 API 和 ABI 更改（例如，避免返回借用引用或依赖 GIL 来保护共享数据的 API），新接口的性能略低是合理的，但我们预计这非常有限，并且通常会在噪音中丢失。</p>
<p>In a similar vein, it’s important that as the free-threaded build lands in main, so that its implementation is considered in other development work that’s going on. New features can’t land without proper support for the free-threaded build, when the two intersect. It may seem tempting to ignore free-threaded when developing thread-adjacent changes, but in the end someone will have to make it work, and it’s neither fair nor particularly forward-thinking to expect the free-threaded maintainers to do all the work. We also need to be mindful of the cohesiveness of the language, the implementation and the C API. We have to assume the free-threaded build will be the only build in the reasonable future, and like other fundamental changes to CPython internals, we all have to learn the new way of approaching these problems. This may be a bit of a jump in terms of complexity – the GIL implicitly simplified so much – but it is a necessary step. We do expect, at least initially, the free-threaded build experts to help others ramp up here. The experimental phase is there for CPython and the Core Devs to get used to the free-threaded build as much as it is for users.<br>同样，重要的是，随着自由线程构建登陆main，以便在正在进行的其他开发工作中考虑其实现。当两者相交时，如果没有对自由线程构建的适当支持，新功能就无法落地。在开发与线程相邻的更改时，忽略自由线程似乎很诱人，但最终必须有人让它工作，期望自由线程维护者完成所有工作既不公平也不特别具有前瞻性。我们还需要注意语言、实现和 C API 的凝聚力。我们必须假设自由线程构建将是合理未来唯一的构建，并且就像 CPython 内部的其他根本性更改一样，我们都必须学习解决这些问题的新方法。就复杂性而言，这可能有点飞跃 - GIL隐含地简化了这么多 - 但这是一个必要的步骤。我们确实希望，至少在最初，自由线程构建专家能够帮助其他人在这里提升。实验阶段是CPython和核心开发人员习惯自由线程构建的，就像用户一样。</p>
<p>We do need a few specific things resolved before PEP 703 can leave the experimental phase. For starters, we need a solution for the ABI. The SC believes strongly that a single ABI serving both with-GIL and free-threaded builds should be possible, should be made possible, and should be required before leaving the experimental phase. If this turns out to be an unreasonable requirement, we’ll have to look at alternative solutions to ease the pressure on package maintainers (e.g. building two extension modules in the same wheel, or providing a compatibility layer through a separate library).<br>在PEP 703离开实验阶段之前，我们确实需要解决一些具体问题。首先，我们需要一个针对 ABI 的解决方案。SC 坚信，在离开实验阶段之前，应该有可能，应该成为可能，并且应该需要同时使用 GIL 和自由线程构建的单个 ABI。如果事实证明这是一个不合理的要求，我们将不得不寻找替代解决方案来减轻软件包维护者的压力（例如，在同一轮子上构建两个扩展模块，或通过单独的库提供兼容层）。</p>
<p>We also need to consider the testing matrix, both for CPython and for third-party packages. Even with a stable ABI we still need to multiply the test matrix. We probably don’t need complete coverage on all supported platforms, but we do want at least one free-threaded buildbot for each of the T1&#x2F;T2 platforms, as well as some way to test the validity of the unified ABI (a way to build things in one build mode and test against an interpreter built in the other build mode). We currently rely on the stable ABI check and third-party testing of the stable ABI, but that will probably not be good enough to ensure the compatibility between the GIL and free-threaded builds. To get to the supported phase we also expect CI checks on GitHub for free-threaded builds on each of the major platforms.<br>我们还需要考虑CPython和第三方软件包的测试矩阵。即使有稳定的ABI，我们仍然需要乘以测试矩阵。我们可能不需要在所有支持的平台上完全覆盖，但我们确实希望每个 T1&#x2F;T2 平台至少有一个自由线程构建机器人，以及某种方法来测试统一 ABI 的有效性（一种在一种构建模式下构建东西并针对在另一种构建模式下构建的解释器进行测试的方法）。我们目前依赖于稳定 ABI 检查和稳定 ABI 的第三方测试，但这可能不足以确保 GIL 和自由线程构建之间的兼容性。为了进入支持的阶段，我们还希望在 GitHub 上对每个主要平台上的自由线程构建进行 CI 检查。</p>
<p>There are a few specific things we want to avoid. We do not want the free-threaded build to be used as the default Python anywhere until the Core Devs and the Python community are ready for that. Obviously we can’t stop users and distributors from installing a free-threaded build by default, but we think at this stage it would be a mistake to do so for anything besides end-to-end experimentation. We also want to avoid labelling the free-threaded build “experimental” after the experimental phase. Build-time flags, defines, comments in the code should avoid the word. We want to avoid negatives in terms and flags and such, so we won’t get into double-negative terrain (like we do when we talk about ‘non no-GIL’). We’d like a positive, clear term to talk about the no-GIL build, and we’re suggesting ‘free-threaded’. (Relatedly, that’s why the build mode&#x2F;ABI letter is ‘t’ and not ‘n’; that change was already made.)<br>我们想要避免一些具体的事情。我们不希望在核心开发人员和 Python 社区准备好之前，在任何地方将自由线程构建用作默认 Python。显然，默认情况下，我们无法阻止用户和分销商安装自由线程构建，但我们认为在现阶段，除了端到端实验之外，这样做都是错误的。我们还希望避免在实验阶段之后将自由线程构建标记为“实验性”。代码中的构建时标志、定义、注释应避免使用这个词。我们希望避免在术语和标志等方面出现负面因素，因此我们不会陷入双重负面领域（就像我们谈论“非无 GIL”时所做的那样）。我们想要一个积极、明确的术语来讨论无 GIL 构建，我们建议使用“自由线程”。（与此相关的是，这就是为什么构建模式&#x2F;ABI 字母是“t”而不是“n”;该更改已经进行了。</p>
<p>In short, the SC accepts PEP 703, but with clear provisio: that the rollout be gradual and break as little as possible, and that we can roll back any changes that turn out to be too disruptive – which includes potentially rolling back all of PEP 703 entirely if necessary (however unlikely or undesirable we expect that to be).<br>简而言之，SC 接受 PEP 703，但有明确的条件：推出是渐进的，尽可能少地中断，我们可以回滚任何破坏性太大的更改——其中包括在必要时可能完全回滚所有 PEP 703（无论我们期望多么不可能或不希望）。</p>
<p>For the whole SC,<br>Thomas.</p>
]]></content>
  </entry>
  <entry>
    <title>我应该支持以色列还是巴勒斯坦？</title>
    <url>/2023/10/20/should_I_support_Israel_or_Palestine/</url>
    <content><![CDATA[<h3 id="我应该支持以色列还是巴勒斯坦？"><a href="#我应该支持以色列还是巴勒斯坦？" class="headerlink" title="我应该支持以色列还是巴勒斯坦？"></a>我应该支持以色列还是巴勒斯坦？</h3><p>这是我在quora上看到到一个高赞回答，粗浅翻译一下，重点是他来自以色列特拉维夫。<br>原文地址：<a href="https://qr.ae/pKvZJk">https://qr.ae/pKvZJk</a><br>原文作者信息：<br>Sociology and Management from The Open UniversityGraduated 2015<br>Lives in Tel Aviv, Israel<br>863K content views258.7K this month<br>Joined November 2013</p>
<p>I am an Israeli, and as an Israeli, I should, with a heavy heart, suggest you support the Palestinians. Why? Because, unlike Israel, they need your support.<br>我是以色列人，作为以色列人，我应该怀着沉重的心情建议你支持巴勒斯坦人。为什么？因为，与以色列不同，他们需要您的支持。</p>
<p>I don’t want to talk about history. Both sides can provide good arguments as to why this piece of land is theirs by right. I don’t want to go into who’s responsible for the conflict - both sides will provide countless examples of the atrocities inflicted on them by the other side.<br>我不想谈论历史。双方都可以提供很好的论据来解释为什么这块土地理所当然地属于他们。我不想讨论谁对这场冲突负责——双方都会提供无数的例子来说明对方对他们施加的暴行。</p>
<p>I want to talk about the here and now. The fact is that there are currently 9 million Israeli citizens (6 million of them are Jews) who live in a relative comfort: they can go, live and work wherever they want inside Israel. Israel is a democracy, so we’re free to elect and out-vote our leaders in case we don’t like how they manage our affairs. In addition, because Israel is a recognized member of the UN, an Israeli citizen is free to use their passport to travel and trade with the rest of the world.<br>我想谈谈此时此地。事实是，目前有 900 万以色列公民（其中 600 万是犹太人）生活相对舒适：他们可以在以色列境内任何想去的地方生活和工作。以色列是一个民主国家，因此，如果我们不喜欢他们管理我们事务的方式，我们可以自由地选举和否决我们的领导人。此外，由于以色列是联合国公认的成员，以色列公民可以自由使用其护照与世界其他地区旅行和贸易。</p>
<p>The 5 million Palestinians living in Gaza and The West Bank, on the other hand, do not enjoy those freedoms. They practically live in an occupied territory which is governed by Israel, but was never officially annexed. That means they do not enjoy the rights of Israeli citizens (they are not citizens after all), but they are forced to live their lives based on decisions made by Israeli politicians and army generals. They cannot build houses or start new businesses outside their current cities, they have to get permits to work inside Israel or to travel abroad, and their borders are controlled by Israel, so they can’t import and export goods and cultivate a healthy economy. They are basically completely reliant on their Israeli occupiers. The Palestinians tried to revolt many times - either by force or in diplomatic manners. But all their attempts have failed miserably by the much stronger Israel.<br>另一方面，生活在加沙和西岸的 500 万巴勒斯坦人却无法享受这些自由。他们实际上生活在以色列管辖的被占领土上，但从未被正式吞并。这意味着他们不享有以色列公民的权利（他们毕竟不是公民），但他们被迫根据以色列政客和军队将军的决定而生活。他们不能在现有城市之外建造房屋或开办新企业，必须获得在以色列境内工作或出国旅行的许可，而且他们的边境由以色列控制，因此他们无法进出口货物并培育健康的经济。他们基本上完全依赖以色列占领者。巴勒斯坦人多次试图通过武力或外交方式进行反抗。但他们的所有尝试都因强大得多的以色列而惨遭失败。</p>
<p>Ask the average Israeli about it, and they’ll tell you that the Palestinians have brought it onto themselves. Considering the horrible violence showed in the past by the Palestinians and the other Arabic countries - Israel would be crazy to give up on its right to defend itself. They may be right, but it doesn’t change the fact that there are 5 million people who are the citizens of no country and who live under occupation. I suspect that even if the Palestinians will promise to never use violence against it - Israel will never trust their word and give up on its control. Things will only change if people like you will support the Palestinians’ right to live like any other citizen in any other normal country in the world. It doesn’t mean you should support Palestinian violence though, but do support, and demand, their right to be free.<br>问问普通以色列人，他们会告诉你这是巴勒斯坦人自找的。考虑到巴勒斯坦人和其他阿拉伯国家过去所表现出的可怕暴力——以色列放弃自卫权将是疯狂的。他们也许是对的，但这并不能改变这样一个事实：有 500 万人不是任何国家的公民，生活在占领之下。我怀疑，即使巴勒斯坦人承诺永远不会对其使用暴力，以色列也永远不会相信他们的诺言并放弃对其的控制。只有像你们这样的人支持巴勒斯坦人像世界上任何其他正常国家的任何其他公民一样生活的权利，事情才会改变。但这并不意味着您应该支持巴勒斯坦暴力，而是支持并要求他们的自由权。</p>
<p>So support Palestine. Otherwise, things will never change.<br>所以支持巴勒斯坦。否则，事情永远不会改变。</p>
<p>Edit: Wow… I never thought this answer would attract so much attention. Thank you for all the upvotes, comments and shares. Still, I decided to block new comments for now. Whether you agreed with my opinion or not - most of you guys posted warm and respectful comments and I apologize for not being able to respond to all of them. Still, some of the readers out there decided it would be the best to express their disagreement by posting sarcastic, cynical or plain hateful comments which I got tired of reading at some point.<br>编辑：哇…我从没想过这个答案会引起如此多的关注。感谢大家的点赞、评论和分享。尽管如此，我还是决定暂时阻止新评论。无论您是否同意我的观点 - 你们中的大多数人都发表了热情而尊重的评论，对于无法回复所有评论，我深表歉意。尽管如此，一些读者还是认为最好通过发表讽刺、愤世嫉俗或纯粹的仇恨评论来表达他们的不同意见，而我在某些时候厌倦了阅读这些评论。</p>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 只保留最近一周的日志</title>
    <url>/2023/08/18/ubuntu-%E5%8F%AA%E4%BF%9D%E7%95%99%E6%9C%80%E8%BF%91%E4%B8%80%E5%91%A8%E7%9A%84%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h3 id="只保留最近一周的日志"><a href="#只保留最近一周的日志" class="headerlink" title="只保留最近一周的日志"></a>只保留最近一周的日志</h3><ul>
<li><p>只保留最近一周的日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl --vacuum-time=1w</span><br></pre></td></tr></table></figure>
</li>
<li><p>只保留最多500M日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl --vacuum-size=500M</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 时钟显示秒</title>
    <url>/2023/08/18/ubuntu-%E6%97%B6%E9%92%9F%E6%98%BE%E7%A4%BA%E7%A7%92/</url>
    <content><![CDATA[<h3 id="时钟显示秒"><a href="#时钟显示秒" class="headerlink" title="时钟显示秒"></a>时钟显示秒</h3><p>Ubuntu 日期时间显示格式“月-日 星期, 时-分-秒”命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.desktop.interface clock-show-seconds true</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu20.04/ubuntu22.04 安装，环境配置遇到的问题以及解决方案</title>
    <url>/2023/08/29/ubuntu20-04-ubuntu22-04-%E5%AE%89%E8%A3%85%EF%BC%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="build-a-python-env-on-ubuntu20-04"><a href="#build-a-python-env-on-ubuntu20-04" class="headerlink" title="build a python env on ubuntu20.04"></a>build a python env on ubuntu20.04</h3><h4 id="fix-virtualenvwarpper"><a href="#fix-virtualenvwarpper" class="headerlink" title="fix virtualenvwarpper"></a>fix virtualenvwarpper</h4><p>(Ubuntu20.04安装virtualenv方法以及安装过程中遇到的问题处理)[<a href="https://blog.csdn.net/qq_42296146/article/details/108291436]">https://blog.csdn.net/qq_42296146/article/details/108291436]</a></p>
<p>问题：bash: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;virtualenvwrapper.sh: No such file or directory</p>
<p>ubuntu18及以上版本，virtualenvwrapper.sh被安装到了家目录下的.local&#x2F;bin&#x2F;中，非原来的&#x2F;usr&#x2F;local&#x2F;bin&#x2F;中</p>
<p>&#x2F;usr&#x2F;share&#x2F;virtualenvwrapper&#x2F;virtualenvwrapper.sh 实际安装的位置，只要把这个地址配置到.brashrc之后就可以正常运行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export WORKON_HOME=$HOME/.virtualenvs</span><br><span class="line">export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3.10</span><br><span class="line">export VIRTUALENVWRAPPER_VIRTUALENV=/usr/bin/virtualenv</span><br><span class="line">source /usr/share/virtualenvwrapper/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>
<h4 id="install-a-local-git-repo-updata"><a href="#install-a-local-git-repo-updata" class="headerlink" title="install a local git repo updata"></a>install a local git repo updata</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@bitbucket.org:ginolegaltech/updata.git</span><br><span class="line">$ cd updata</span><br><span class="line">&amp; python3.10 setup.py install</span><br><span class="line">$ rm -rf build/</span><br><span class="line">$ rm -rf updata.egg-info/</span><br></pre></td></tr></table></figure>

<h5 id="fix-ImportError-cannot-import-name-‘html5lib’-from-‘pip-vendor’-home-ice-virtualenvs-310-lib-python3-10-site-packages-pip-vendor-init-py"><a href="#fix-ImportError-cannot-import-name-‘html5lib’-from-‘pip-vendor’-home-ice-virtualenvs-310-lib-python3-10-site-packages-pip-vendor-init-py" class="headerlink" title="fix ImportError: cannot import name ‘html5lib’ from ‘pip._vendor’ (&#x2F;home&#x2F;ice&#x2F;.virtualenvs&#x2F;310&#x2F;lib&#x2F;python3.10&#x2F;site-packages&#x2F;pip&#x2F;_vendor&#x2F;init.py)"></a>fix ImportError: cannot import name ‘html5lib’ from ‘pip._vendor’ (&#x2F;home&#x2F;ice&#x2F;.virtualenvs&#x2F;310&#x2F;lib&#x2F;python3.10&#x2F;site-packages&#x2F;pip&#x2F;_vendor&#x2F;<strong>init</strong>.py)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sS https://bootstrap.pypa.io/get-pip.py | python3.10</span><br></pre></td></tr></table></figure>



<h4 id="bash-显示当前所在分支"><a href="#bash-显示当前所在分支" class="headerlink" title="bash 显示当前所在分支"></a>bash 显示当前所在分支</h4><p>在.bashrc文件追加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function git_branch &#123;</span><br><span class="line">   branch=&quot;`git branch 2&gt;/dev/null | grep &quot;^\*&quot; | sed -e &quot;s/^\*\ //&quot;`&quot;</span><br><span class="line">   if [ &quot;$&#123;branch&#125;&quot; != &quot;&quot; ];then</span><br><span class="line">       if [ &quot;$&#123;branch&#125;&quot; = &quot;(no branch)&quot; ];then</span><br><span class="line">           branch=&quot;(`git rev-parse --short HEAD`...)&quot;</span><br><span class="line">       fi</span><br><span class="line">       echo &quot; ($branch)&quot;</span><br><span class="line">   fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export PS1=&#x27;\u@\h \[\033[01;36m\]\w\[\033[01;32m\]$(git_branch)\[\033[00m\] \$ &#x27;</span><br></pre></td></tr></table></figure>

<h4 id="install-virtualbox"><a href="#install-virtualbox" class="headerlink" title="install virtualbox"></a>install virtualbox</h4><p><a href="https://computingforgeeks.com/install-virtualbox-6-on-ubuntu-linux/">https://computingforgeeks.com/install-virtualbox-6-on-ubuntu-linux/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># step 1</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt -y upgrade</span><br><span class="line">sudo reboot</span><br><span class="line"></span><br><span class="line"># step 2</span><br><span class="line">#Download</span><br><span class="line">curl https://www.virtualbox.org/download/oracle_vbox_2016.asc | gpg --dearmor &gt; oracle_vbox_2016.gpg</span><br><span class="line">curl https://www.virtualbox.org/download/oracle_vbox.asc | gpg --dearmor &gt; oracle_vbox.gpg</span><br><span class="line">#Install on system</span><br><span class="line">sudo install -o root -g root -m 644 oracle_vbox_2016.gpg /etc/apt/trusted.gpg.d/</span><br><span class="line">sudo install -o root -g root -m 644 oracle_vbox.gpg /etc/apt/trusted.gpg.d/</span><br><span class="line"></span><br><span class="line"># step 3</span><br><span class="line"># ubuntu 22.04 </span><br><span class="line">echo &quot;deb [arch=amd64] http://download.virtualbox.org/virtualbox/debian focal contrib&quot; | sudo tee /etc/apt/sources.list.d/virtualbox.list</span><br><span class="line"></span><br><span class="line"># Ubuntu 20.04/18.04:</span><br><span class="line">echo &quot;deb [arch=amd64] http://download.virtualbox.org/virtualbox/debian $(lsb_release -sc) contrib&quot; | sudo tee /etc/apt/sources.list.d/virtualbox.list</span><br><span class="line"></span><br><span class="line"># step 4</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install linux-headers-$(uname -r) dkms</span><br><span class="line">sudo apt install virtualbox-6.1</span><br></pre></td></tr></table></figure>

<p>virtualbox start error:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo /sbin/vboxconfig </span><br><span class="line">[sudo] password for rcrozier:           </span><br><span class="line">vboxdrv.sh: Stopping VirtualBox services.</span><br><span class="line">vboxdrv.sh: Starting VirtualBox services.</span><br><span class="line">vboxdrv.sh: You must sign these kernel modules before using VirtualBox:</span><br><span class="line">  vboxdrv vboxnetflt vboxnetadp</span><br><span class="line">See the documenatation for your Linux distribution..</span><br><span class="line">vboxdrv.sh: Building VirtualBox kernel modules.</span><br><span class="line">debconf: DbDriver &quot;config&quot;: /var/cache/debconf/config.dat is locked by another process: Resource temporarily unavailable</span><br><span class="line">vboxdrv.sh: Failed to enroll secure boot key..</span><br><span class="line">vboxdrv.sh: failed: modprobe vboxdrv failed. Please use &#x27;dmesg&#x27; to find out why.</span><br><span class="line"></span><br><span class="line">There were problems setting up VirtualBox.  To re-start the set-up process, run</span><br><span class="line">  /sbin/vboxconfig</span><br><span class="line">as root.  If your system is using EFI Secure Boot you may need to sign the</span><br><span class="line">kernel modules (vboxdrv, vboxnetflt, vboxnetadp, vboxpci) before you can load</span><br><span class="line">them. Please see your Linux system&#x27;s documentation for more information.</span><br></pre></td></tr></table></figure>

<p>搜索了很多解决方案都无法处理，最后还是仔细看了报错信息，这里其实有一个很重要的提示信息<code>Secure Boot you may need to sign the kernel modules</code></p>
<p>最后搜到<a href="https://askubuntu.com/questions/900118/vboxdrv-sh-failed-modprobe-vboxdrv-failed-please-use-dmesg-to-find-out-why">https://askubuntu.com/questions/900118/vboxdrv-sh-failed-modprobe-vboxdrv-failed-please-use-dmesg-to-find-out-why</a> 这个答案最后的以解决答案：</p>
<p>The above answer probably works fine, but if you want an easier time for it:</p>
<p>I was able to solve it by</p>
<p>booting into the BIOS and going &gt; advanced (f7) &gt; boot &gt; scroll down to “secure boot” &gt; change “Windows EUFI mode” to “other OS”</p>
<p>My virtualbox works perfectly now.</p>
<p>最后对于为为的解决方案就是进入BIOS系统之后，和这个答案每个硬件平台的BIOS版本会有所不同(我的硬件三HUAWEI MateBook X Pro 2022)找到”secure boot”关键词对应的默认直是enable，为改为disable，第一次修改没有其作用，是应推出的时候没有保存，第二次再修改选择save and exit，再进入ubuntu启动virtualbox就可以正常运作了。</p>
<p>最近在ubuntu22.04 安装virtualbox的时候遇到另外还有一个报错：</p>
<h3 id="vboxdrv-sh-failed-Cannot-change-group-vboxusers-for-device-dev-vboxdrv"><a href="#vboxdrv-sh-failed-Cannot-change-group-vboxusers-for-device-dev-vboxdrv" class="headerlink" title="vboxdrv.sh: failed: Cannot change group vboxusers for device &#x2F;dev&#x2F;vboxdrv."></a>vboxdrv.sh: failed: Cannot change group vboxusers for device &#x2F;dev&#x2F;vboxdrv.</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行：/sbin/vboxconfig</span><br><span class="line">输出如下报错</span><br><span class="line">root@ice:~# /sbin/vboxconfig</span><br><span class="line">vboxdrv.sh: Stopping VirtualBox services.</span><br><span class="line">vboxdrv.sh: Starting VirtualBox services.</span><br><span class="line">vboxdrv.sh: Building VirtualBox kernel modules.</span><br><span class="line">vboxdrv.sh: failed: Cannot change group vboxusers for device /dev/vboxdrv.</span><br><span class="line"></span><br><span class="line">There were problems setting up VirtualBox.  To re-start the set-up process, run</span><br><span class="line">  /sbin/vboxconfig</span><br><span class="line">as root.  If your system is using EFI Secure Boot you may need to sign the</span><br><span class="line">kernel modules (vboxdrv, vboxnetflt, vboxnetadp, vboxpci) before you can load</span><br><span class="line">them. Please see your Linux system&#x27;s documentation for more information.</span><br></pre></td></tr></table></figure>
<ul>
<li>创建vboxusers group<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd vboxusers</span><br></pre></td></tr></table></figure></li>
<li>把当前user 加入到这个group， 你替换这里的ice<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -a -G vboxusers ice</span><br></pre></td></tr></table></figure></li>
<li>检查是否添加成功<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep vboxusers /etc/group</span><br><span class="line"># 输出为:</span><br><span class="line"># vboxusers:x:1003:ice</span><br></pre></td></tr></table></figure></li>
<li>然后运行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo /sbin/vboxconfig</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>人在什么情况下成长最快？</title>
    <url>/2023/08/21/%E4%BA%BA%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%88%90%E9%95%BF%E6%9C%80%E5%BF%AB%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="人在什么情况下成长最快？"><a href="#人在什么情况下成长最快？" class="headerlink" title="人在什么情况下成长最快？"></a>人在什么情况下成长最快？</h3><p>今天读到一篇知乎回答，感觉挺好的，记录一下自己的理解。<br>人成长最快的时候是: 一个场景， 三个条件。</p>
<h4 id="一个场景"><a href="#一个场景" class="headerlink" title="一个场景:"></a>一个场景:</h4><p>要牵头做事， 承担责任， 空想是不可能有什么成长的。做事也分很多种，有时候是与其他部门或者人配合做事，有时候是居中协调各个部门、有时候是牵头负责一件事。这里牵头负责一件事是最锻炼人了，成长也是最快的，牵头对成长的好处, 首先就是事情的强度和和面对事情的态度，牵头负责一件事的成败都系于你一人，你需要对这件事情负全责，无论结果怎样躲是躲不掉， 所以唯一的选择就是竭尽全力达成。<br>牵头做事另一方面的锻炼就是解决问题的能力，牵头负责一件事情, 你会发现处处是问题， 人是问题，钱是问题， 你的上面领导是问题，你的下面人是问题， 推进事情节奏是问题， 协调是问题; 出了问题那就得解决问题， 你发现你每一天都在解决问题。有的时候你得哄着团队成员，哄着领导，有时候给吓着他们，有时候还得瞒着，有时候得抓紧， 有时候得放松，有时候亢奋， 有时候失落, 还想散摊子回高老庄。总之到了最后结果也许好也许坏，但这个过程中的你就像八卦炉里的孙猴子，固然伤病一身，但本事也是结结实实地在成长了。</p>
<h4 id="三个条件：有动力也有压力，-有支持也有劝，-有认真也有放开"><a href="#三个条件：有动力也有压力，-有支持也有劝，-有认真也有放开" class="headerlink" title="三个条件：有动力也有压力， 有支持也有劝， 有认真也有放开"></a>三个条件：有动力也有压力， 有支持也有劝， 有认真也有放开</h4><ol>
<li><p>是有动力也有压力: 首先得有动力, 要么是自己喜欢, 自己很想, 要么是激励机制到位，你的积极性被激发了，总之首先你的得渴望做成这件事, 只有渴望成事，事情才能成， 其次必须有一定的压力， 这种压力往往来自明确的目标核对结果要求(deadline&#x2F;数据&#x2F;指标&#x2F;盈利养活团队…)，结果会呼唤效率，倒逼自己或者团队改进，只有动力没有压力人很容易进入一种什么都想做， 什么都放弃不了， 无法衡量结果好坏的泥潭，长时间使用自己喜欢过去习惯, 主观认同而非客观最高效率的方式， 直到自己的激情被耗尽。 这种情况下人是很难有快速的成长， 说白了成长是有痛感的， 没有什么事情从头到尾都是快乐的，最后还成事了，那都只有在小说里存在。 这是因为外部结果在对自己的认知、习惯、心态等进行修正和淬炼。没有压力就谈不上任何修正。 </p>
</li>
<li><p>有支持也有劝诫: 支持是必须的，物质上给资源、金钱； 精神上给鼓励肯定。环境上给决策权力。说到底做事一要有权， 二要有资源， 三要有肯定。领导只是口头上支持不给权、不给钱、那事情就很难做不如不做。还得有劝诫，自己做事很容易一根筋， 容易有盲区， 很多时候做的事问题很多， 但自己感觉不到， 这时候上面的领导能给自己提点，下面的团队成员敢提出问题这就很关键，这里面的分寸不好掌握, 需要自己慢慢体会。 另外，能成事的人一定有固执的一面， 有原则有坚持的一面， 什么地方该坚持什么地方该灵活改进需要自己去认真把握。</p>
</li>
<li><p>有认真也有放开: 就是说自己的心态要认真，想做成事， 必须很认真。 要有担当， 竭尽全力。把事情扛在肩上，放在心理，也就是得上心，得时刻绷着点。很多时候事情不是自己想做成就能做成， 很多时候甚至不是事情的问题， 只是时间还没， 到条件还没到。如果人过度焦虑， 心理负担太重就容易过度反应， 自习把自己压垮。事情还没怎样人已经扛不住了， 这种心理素质是不行的， 这时候人要懂得该放开时需放开，你控制不了的事情就别在意。无论压力多大， 人得有定力， 能冷静分析当前的局势问题到底在哪里? 做事的人最忌讳情绪大起大落。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>人生南北多歧路,君向潇湘我向秦</title>
    <url>/2023/08/25/%E4%BA%BA%E7%94%9F%E5%8D%97%E5%8C%97%E5%A4%9A%E6%AD%A7%E8%B7%AF-%E5%90%9B%E5%90%91%E6%BD%87%E6%B9%98%E6%88%91%E5%90%91%E7%A7%A6/</url>
    <content><![CDATA[<h3 id="人生南北多歧路-君向潇湘我向秦"><a href="#人生南北多歧路-君向潇湘我向秦" class="headerlink" title="人生南北多歧路,君向潇湘我向秦"></a>人生南北多歧路,君向潇湘我向秦</h3><p>这两句诗道尽初遇时的情投意合，最终却南辕北辙，遗憾分开的悲伤结局，有很多人可能并不知道这是被裁缝到一起的。<br>人生南北多歧路清代吴敬梓的《儒林外史》的一首词《秦时月》</p>
<p>《秦时月》：<br>人生南北多歧路。<br>将相神仙，也要凡人做。<br>百代兴亡朝复暮，<br>江风吹倒前朝树。<br>功名富贵无凭据。<br>费尽心情，总把流光误。<br>浊酒三杯沉醉去，<br>水流花谢知何处。</p>
<p>而后一句“君向潇湘我向秦”出自唐代诗人郑谷的《淮上与友人别》<br>《淮上与友人别》<br>郑谷<br>扬子江头杨柳春，杨花愁杀渡江人。<br>数声风笛离亭晚，君向潇湘我向秦。</p>
<p>扬子江边杨柳青青春意正浓，漫天飞扬的杨花使渡江之人非常的愁烦。<br>微风轻拂，笛声幽咽，离亭渐渐染上暮色，你就要南下潇湘我却奔向西秦。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>谈日本向海洋排放核污染水</title>
    <url>/2023/08/29/%E8%B0%88%E6%97%A5%E6%9C%AC%E5%90%91%E6%B5%B7%E6%B4%8B%E6%8E%92%E6%A0%B8%E6%B1%A1%E6%9F%93%E6%B0%B4/</url>
    <content><![CDATA[<h3 id="谈日本向海洋排放核污染水"><a href="#谈日本向海洋排放核污染水" class="headerlink" title="谈日本向海洋排放核污染水"></a>谈日本向海洋排放核污染水</h3><p>8月24日13时，日本福岛第一核电站启动核污染水排海。而且是计划至少30年持续核污染水排海。</p>
<h4 id="一个极其清晰明了的逻辑"><a href="#一个极其清晰明了的逻辑" class="headerlink" title="一个极其清晰明了的逻辑"></a>一个极其清晰明了的逻辑</h4><p>如果日本的核污水像日本人说的那样是干净的，那么日本就不应该顶着全世界各国的反对非要核污染水排海。<br>如果日本人说了谎，核污染水不干净，那么日本就更加不应该冒天下之大不韪将核污染水排海。<br>因此，日本绝对是不应该将核污染水排海的。</p>
<h4 id="日本核污染水排海造成的恐慌"><a href="#日本核污染水排海造成的恐慌" class="headerlink" title="日本核污染水排海造成的恐慌"></a>日本核污染水排海造成的恐慌</h4><p>日本核污染水排海实施消息一出，国内有很多人表示很慌，以后不能去海边了，不能去吃海鲜了。也有一些人表示不慌，可能通过网上一些知识博主的宣传了解了一些太平洋洋流的知识，核污水传遍太平洋到东海，南海还需要一段时间。<br>我的观点是，没必要慌，因为慌也没有用，你慌并不能阻止日本人和世界人民有”辐“同享的无耻行径。反而像24号当天有很多抢盐的行为并不可取，让人哭笑不得。以后日本的东西就尽量避免使用、食用。<br>说道海鲜，最近海鲜因为这个事件，导致大面积降价，我觉得倒是可以抓紧去吃一吃，过段时间倒是真的谨慎吃不能吃了哟。</p>
<h4 id="日本将遭到短视的严重反噬"><a href="#日本将遭到短视的严重反噬" class="headerlink" title="日本将遭到短视的严重反噬"></a>日本将遭到短视的严重反噬</h4><p>日本核污水排海，美国带头默许，西方世界全体失声, 或者表示理解。且看他们做了什么，不要看他们说了什么。<br>日本核污水排海公布之后，欧美各个国家都纷纷发布对日本水产品限制进口政策，已经说明了问题。<br>日本即将迎来的是日本产品被贴上核污染的标签，或者至少不是第一选择产品。日本整个国家的各种产品可能和水有关系的都会面临如此的下场。日本的产品可能含有微量剧毒，可能会导致癌症风险增加。只要大家对日本产品都有这样的印象就够了，这是一个非常可怕的精神暗示。因为水太重要了，它参与着农产品，工业产品的生产。都是对日本是极具毁灭性的打击。</p>
<p>如开头的逻辑所说，无论如何日本都不应该核污水排海的错误行为。这是对自己国家人民的不负责，也是对世界人民的不负责。那么，我们能做什么呢？尽量不用日本的产品，一方面是对自身健康的考量，另一方面也是对日本这种不负责任的行为的沉默抵抗。另外，宣传更要让日本产品与核污染牢牢绑定。就像他们权衡利益用最廉价却又不最不负责任的处理核污染水一样，让他们无法拒绝地停止核污染水排海。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Creational Design Patterns</title>
    <url>/2023/11/26/design-pattern/Creational-Design-Patterns/</url>
    <content><![CDATA[<h1 id="Creational-Design-Patterns-创建设计模式"><a href="#Creational-Design-Patterns-创建设计模式" class="headerlink" title="Creational Design Patterns 创建设计模式"></a>Creational Design Patterns 创建设计模式</h1><p>Creational design patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.<br>创建设计模式提供了各种对象创建机制，这些机制提高了灵活性和现有代码的重用性。</p>
<h2 id="Factory-Method-工厂方法"><a href="#Factory-Method-工厂方法" class="headerlink" title="Factory Method 工厂方法"></a>Factory Method 工厂方法</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/87KZ5eDmwjmWiKFEoA02lw">
    <img src="/images/factory-method-logo.png"/>
    Factory Method 工厂方法
    <a/>
</div>

<hr>
<h2 id="Abstract-Factory-抽象工厂模式"><a href="#Abstract-Factory-抽象工厂模式" class="headerlink" title="Abstract Factory 抽象工厂模式"></a>Abstract Factory 抽象工厂模式</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/ArraO8MpfdiSG7JiqJwZsQ">
    <img src="/images/abstract-factory-logo.png"/>
    Abstract Factory 抽象工厂模式
    <a/>
</div>

<hr>
<h2 id="Builder-建造者模式"><a href="#Builder-建造者模式" class="headerlink" title="Builder 建造者模式"></a>Builder 建造者模式</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/av15yLamVtV8D1bjLBxk4Q">
    <img src="/images/builder-logo.png"/>
    Builder 建造者模式
    <a/>
</div>

<hr>
<h2 id="Protopype-原型模式"><a href="#Protopype-原型模式" class="headerlink" title="Protopype 原型模式"></a>Protopype 原型模式</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/IG55Nn98d_PU382-VOGNhQ">
    <img src="/images/prototype-logo.png"/>
    Protopype 原型模式
    <a/>
</div>

<hr>
<h2 id="Singleton-单例模式"><a href="#Singleton-单例模式" class="headerlink" title="Singleton 单例模式"></a>Singleton 单例模式</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/Mpp-i9mm2KZsi4DPxZWLmg">
    <img src="/images/singleton-logo.png"/>
    Singleton 单例模式
    <a/>
</div>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Abstract Factory</title>
    <url>/2023/11/20/design-pattern/abstract-factory/</url>
    <content><![CDATA[<h1 id="Abstract-Factory-抽象工厂"><a href="#Abstract-Factory-抽象工厂" class="headerlink" title="Abstract Factory 抽象工厂"></a>Abstract Factory 抽象工厂</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p>Abstract Factory is a creational design pattern that lets you produce families of related objects without specifying their concrete classes.<br>抽象工厂是一种创建性设计模式，它允许您生成相关对象的族，而无需指定其具体类。</p>
<div align="center"> <img src="/images/abstract-factory-en.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Imagine that you’re creating a furniture shop simulator. Your code consists of classes that represent:<br>想象一下，您正在创建一个家具店模拟器。代码由表示以下内容的类组成：</p>
<p>A family of related products, say: <code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code>.<br>一系列相关产品，如：<code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code>。</p>
<p>Several variants of this family. For example, products <code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code> are available in these variants: <code>Modern</code>, <code>Victorian</code>, <code>ArtDeco</code>.<br>该系列的几个变体。例如，产品 <code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code> 提供以下变体： <code>Modern</code> + <code>Victorian</code> + <code>ArtDeco</code> 。</p>
<div align="center"> <img src="/images/abs-fac-problem2-en.png"/>Product families and their variants.</br> 产品系列及其变体。</div>

<p>You need a way to create individual furniture objects so that they match other objects of the same family. Customers get quite mad when they receive non-matching furniture.<br>您需要一种方法来创建单个家具对象，以便它们与同一系列的其他对象相匹配。当客户收到不匹配的家具时，他们会非常生气。</p>
<div align="center"> <img src="/images/abstract-factory-comic-1-en.png"/>A Modern-style sofa doesn’t match Victorian-style chairs.</div>

<p>A Modern-style sofa doesn’t match Victorian-style chairs.<br>现代风格的沙发与维多利亚风格的椅子不匹配。</p>
<p>Also, you don’t want to change existing code when adding new products or families of products to the program. Furniture vendors update their catalogs very often, and you wouldn’t want to change the core code each time it happens.<br>此外，在向程序添加新产品或产品系列时，您不希望更改现有代码。家具供应商经常更新他们的目录，您不希望每次都更改核心代码。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The first thing the Abstract Factory pattern suggests is to explicitly declare interfaces for each distinct product of the product family (e.g., chair, sofa or coffee table). Then you can make all variants of products follow those interfaces. For example, all chair variants can implement the <code>Chair</code> interface; all coffee table variants can implement the <code>CoffeeTable</code> interface, and so on.<br>抽象工厂模式建议的第一件事是显式声明产品系列中每个不同产品（例如，椅子、沙发或咖啡桌）的接口。然后，您可以使产品的所有变体都遵循这些接口。例如，所有椅子变体都可以实现该 <code>Chair</code> 接口;所有咖啡桌变体都可以实现接口 <code>CoffeeTable</code> ，依此类推。</p>
<div align="center"> <img src="/images/abs-fac-solution1.png"/>All variants of the same object must be moved to a single class hierarchy.</br>必须将同一对象的所有变体移动到单个类层次结构中。</div>

<p>The next move is to declare the Abstract Factory—an interface with a list of creation methods for all products that are part of the product family (for example, <code>createChair</code>, <code>createSofa</code> and <code>createCoffeeTable</code>). These methods must return abstract product types represented by the interfaces we extracted previously: <code>Chair</code>, <code>Sofa</code>, <code>CoffeeTable</code> and so on.<br>下一步是声明抽象工厂 - 一个接口，其中包含属于产品系列的所有产品的创建方法列表（例如， <code>createChair</code> 、 <code>createSofa </code>和 <code>createCoffeeTable</code> ）。这些方法必须返回由我们之前提取的接口表示的抽象产品类型： <code>Chair</code> 、 <code>Sofa</code> 等 <code>CoffeeTable</code> 。</p>
<div align="center"> <img src="/images/abs-fac-solution2.png"/>Each concrete factory corresponds to a specific product variant.</br>每个混凝土工厂对应一个特定的产品变型。</div>
The _Factories_ class hierarchy
Each concrete factory corresponds to a specific product variant.
每个混凝土工厂对应一个特定的产品变型。

<p>Now, how about the product variants? For each variant of a product family, we create a separate factory class based on the <code>AbstractFactory</code> interface. A factory is a class that returns products of a particular kind. For example, the <code>ModernFurnitureFactory</code> can only create <code>ModernChair</code>, <code>ModernSofa</code> and <code>ModernCoffeeTable</code> objects.<br>现在，产品变体怎么样？对于产品系列的每个变体，我们基于 <code>AbstractFactory</code> 接口创建一个单独的工厂类。工厂是返回特定种类产品的类。例如，只能 <code>ModernFurnitureFactory</code> 创建 <code>ModernChair</code> 和 <code>ModernSofa</code> <code>ModernCoffeeTable</code> 对象。</p>
<p>The client code has to work with both factories and products via their respective abstract interfaces. This lets you change the type of a factory that you pass to the client code, as well as the product variant that the client code receives, without breaking the actual client code.<br>客户端代码必须通过工厂和产品各自的抽象接口进行处理。这样，您就可以更改传递给客户端代码的工厂类型，以及客户端代码接收的产品变型，而不会破坏实际的客户端代码。</p>
<div align="center"> <img src="/images/abs-fac-solution2.png"/>The client shouldn’t care about the concrete class of the factory it works with.</br>客户不应该关心与它合作的工厂的具体类别。</div>

<p>The client shouldn’t care about the concrete class of the factory it works with.<br>客户不应该关心与它合作的工厂的具体类别。</p>
<p>Say the client wants a factory to produce a chair. The client doesn’t have to be aware of the factory’s class, nor does it matter what kind of chair it gets. Whether it’s a Modern model or a Victorian-style chair, the client must treat all chairs in the same manner, using the abstract <code>Chair</code> interface. With this approach, the only thing that the client knows about the chair is that it implements the sitOn method in some way. Also, whichever variant of the chair is returned, it’ll always match the type of sofa or coffee table produced by the same factory object.<br>假设客户想要一家工厂生产一把椅子。客户不必知道工厂的等级，也不必知道它得到什么样的椅子。无论是现代模型还是维多利亚风格的椅子，客户都必须使用抽象 <code>Chair</code> 界面以相同的方式对待所有椅子。使用这种方法，客户对椅子的唯一了解是它以某种方式实现了 <code>sitOn</code> 该方法。此外，无论返回哪种椅子变体，它都将始终与同一工厂对象生产的沙发或咖啡桌类型相匹配。</p>
<p>There’s one more thing left to clarify: if the client is only exposed to the abstract interfaces, what creates the actual factory objects? Usually, the application creates a concrete factory object at the initialization stage. Just before that, the app must select the factory type depending on the configuration or the environment settings.<br>还有一件事需要澄清：如果客户端只暴露给抽象接口，那么是什么创建了实际的工厂对象？通常，应用程序在初始化阶段创建一个具体的工厂对象。在此之前，应用程序必须根据配置或环境设置选择出厂类型。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/abs-fac-structure.png"/></br></div>

<ol>
<li><p><strong>Abstract Products</strong> declare interfaces for a set of distinct but related products which make up a product family.<br>抽象产品声明了一组不同但相关的产品的接口，这些产品构成了一个产品系列。</p>
</li>
<li><p><strong>concrete Products</strong> are various implementations of abstract products, grouped by variants. Each abstract product (chair&#x2F;sofa) must be implemented in all given variants (Victorian&#x2F;Modern).<br>具体产品是抽象产品的各种实现，按变体分组。每个抽象产品（椅子&#x2F;沙发）都必须在所有给定的变体（维多利亚式&#x2F;现代式）中实现。</p>
</li>
<li><p>The <strong>Abstract Factory</strong> interface declares a set of methods for creating each of the abstract products.<br>抽象工厂接口声明了一组用于创建每个抽象产品的方法。</p>
</li>
<li><p><strong>Concrete Factories</strong> implement creation methods of the abstract factory. Each concrete factory corresponds to a specific variant of products and creates only those product variants.<br>具体工厂实现了抽象工厂的创建方法。每个混凝土工厂对应于产品的特定变体，并且仅创建这些产品变体。</p>
</li>
<li><p><strong>Although concrete</strong> factories instantiate concrete products, signatures of their creation methods must return corresponding abstract products. This way the client code that uses a factory doesn’t get coupled to the specific variant of the product it gets from a factory. The Client can work with any concrete factory&#x2F;product variant, as long as it communicates with their objects via abstract interfaces.<br>虽然具体工厂实例化了具体产品，但其创建方法的签名必须返回相应的抽象产品。这样，使用工厂的客户端代码就不会与它从工厂获得的产品的特定变体耦合。客户端可以使用任何具体的工厂&#x2F;产品变体，只要它通过抽象接口与它们的对象进行通信即可。</p>
</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example illustrates how the <strong>Abstract Factory</strong> pattern can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes, while keeping all created elements consistent with a selected operating system.<br>此示例演示如何使用抽象工厂模式创建跨平台 UI 元素，而无需将客户端代码耦合到具体的 UI 类，同时使所有创建的元素与所选操作系统保持一致。</p>
<div align="center"> <img src="/images/abs-fac-example.png"/>The cross-platform UI classes example.</br>跨平台 UI 类示例。</div>
The same UI elements in a cross-platform application are expected to behave similarly, but look a little bit different under different operating systems. Moreover, it’s your job to make sure that the UI elements match the style of the current operating system. You wouldn’t want your program to render macOS controls when it’s executed in Windows.
跨平台应用程序中的相同 UI 元素的行为应相似，但在不同的操作系统下看起来略有不同。此外，您的工作是确保 UI 元素与当前操作系统的样式相匹配。你不希望程序在 Windows 中执行时呈现 macOS 控件。

<p>The Abstract Factory interface declares a set of creation methods that the client code can use to produce different types of UI elements. Concrete factories correspond to specific operating systems and create the UI elements that match that particular OS.<br>抽象工厂接口声明了一组创建方法，客户端代码可以使用这些方法生成不同类型的 UI 元素。具体工厂对应于特定的操作系统，并创建与该特定操作系统匹配的 UI 元素。</p>
<p>It works like this: when an application launches, it checks the type of the current operating system. The app uses this information to create a factory object from a class that matches the operating system. The rest of the code uses this factory to create UI elements. This prevents the wrong elements from being created.<br>它的工作原理是这样的：当应用程序启动时，它会检查当前操作系统的类型。应用使用此信息从与操作系统匹配的类创建工厂对象。代码的其余部分使用此工厂创建 UI 元素。这样可以防止创建错误的元素。</p>
<p>With this approach, the client code doesn’t depend on concrete classes of factories and UI elements as long as it works with these objects via their abstract interfaces. This also lets the client code support other factories or UI elements that you might add in the future.<br>使用这种方法，客户端代码不依赖于工厂和 UI 元素的具体类，只要它通过其抽象接口处理这些对象即可。这也允许客户端代码支持将来可能添加的其他工厂或 UI 元素。</p>
<p>As a result, you don’t need to modify the client code each time you add a new variation of UI elements to your app. You just have to create a new factory class that produces these elements and slightly modify the app’s initialization code so it selects that class when appropriate.<br>因此，每次向应用添加新的 UI 元素变体时，都无需修改客户端代码。只需创建一个新的工厂类来生成这些元素，并稍微修改应用的初始化代码，以便它在适当的时候选择该类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The abstract factory interface declares a set of methods that</span></span><br><span class="line"><span class="comment">// return different abstract products. These products are called</span></span><br><span class="line"><span class="comment">// a family and are related by a high-level theme or concept.</span></span><br><span class="line"><span class="comment">// Products of one family are usually able to collaborate among</span></span><br><span class="line"><span class="comment">// themselves. A family of products may have several variants,</span></span><br><span class="line"><span class="comment">// but the products of one variant are incompatible with the</span></span><br><span class="line"><span class="comment">// products of another variant.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line">    method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete factories produce a family of products that belong</span></span><br><span class="line"><span class="comment">// to a single variant. The factory guarantees that the</span></span><br><span class="line"><span class="comment">// resulting products are compatible. Signatures of the concrete</span></span><br><span class="line"><span class="comment">// factory&#x27;s methods return an abstract product, while inside</span></span><br><span class="line"><span class="comment">// the method a concrete product is instantiated.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinButton</span>()</span><br><span class="line">    method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinCheckbox</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each concrete factory has a corresponding product variant.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>()</span><br><span class="line">    method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacCheckbox</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Each distinct product of a product family should have a base</span></span><br><span class="line"><span class="comment">// interface. All variants of the product must implement this</span></span><br><span class="line"><span class="comment">// interface.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete products are created by corresponding concrete</span></span><br><span class="line"><span class="comment">// factories.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Render a button in Windows style.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Render a button in macOS style.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Here&#x27;s the base interface of another product. All products</span></span><br><span class="line"><span class="comment">// can interact with each other, but proper interaction is</span></span><br><span class="line"><span class="comment">// possible only between products of the same concrete variant.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Render a checkbox in Windows style.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Render a checkbox in macOS style.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The client code works with factories and products only</span></span><br><span class="line"><span class="comment">// through abstract types: GUIFactory, Button and Checkbox. This</span></span><br><span class="line"><span class="comment">// lets you pass any factory or product subclass to the client</span></span><br><span class="line"><span class="comment">// code without breaking it.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    <span class="keyword">private</span> field factory: GUIFactory</span><br><span class="line">    <span class="keyword">private</span> field button: Button</span><br><span class="line">    constructor <span class="title function_">Application</span><span class="params">(factory: GUIFactory)</span> is</span><br><span class="line">        <span class="built_in">this</span>.factory = factory</span><br><span class="line">    method <span class="title function_">createUI</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.button = factory.createButton()</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        button.paint()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The application picks the factory type depending on the</span></span><br><span class="line"><span class="comment">// current configuration or environment settings and creates it</span></span><br><span class="line"><span class="comment">// at runtime (usually at the initialization stage).</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationConfigurator</span> is</span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">config</span> <span class="operator">=</span> readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config.OS == <span class="string">&quot;Windows&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WinFactory</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (config.OS == <span class="string">&quot;Mac&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacFactory</span>()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Error! Unknown operating system.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Application</span>(factory)</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Abstract Factory when your code needs to work with various families of related products, but you don’t want it to depend on the concrete classes of those products—they might be unknown beforehand or you simply want to allow for future extensibility.<br>当您的代码需要处理各种相关产品系列，但您不希望它依赖于这些产品的具体类时，请使用抽象工厂 - 它们可能事先是未知的，或者您只是想允许将来的可扩展性。</strong></p>
</li>
<li><p>The Abstract Factory provides you with an interface for creating objects from each class of the product family. As long as your code creates objects via this interface, you don’t have to worry about creating the wrong variant of a product which doesn’t match the products already created by your app.<br>抽象工厂为您提供了一个接口，用于从产品系列的每个类创建对象。只要您的代码通过此接口创建对象，您就不必担心创建错误的产品变体，而该变体与您的应用已创建的产品不匹配。</p>
</li>
<li><p><strong>Consider implementing the Abstract Factory when you have a class with a set of Factory Methods that blur its primary responsibility.<br>当您有一个具有一组模糊其主要职责的工厂方法的类时，请考虑实现抽象工厂。</strong></p>
</li>
<li><p>In a well-designed program each class is responsible only for one thing. When a class deals with multiple product types, it may be worth extracting its factory methods into a stand-alone factory class or a full-blown Abstract Factory implementation.<br>在一个精心设计的程序中，每个类只负责一件事。当一个类处理多种产品类型时，可能值得将其工厂方法提取到独立的工厂类或成熟的抽象工厂实现中。</p>
</li>
</ul>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Map out a matrix of distinct product types versus variants of these products.<br>绘制出不同产品类型与这些产品变体的矩阵。</p>
</li>
<li><p>Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.<br>声明所有产品类型的抽象产品接口。然后让所有具体的产品类实现这些接口。</p>
</li>
<li><p>Declare the abstract factory interface with a set of creation methods for all abstract products.<br>声明抽象工厂接口，其中包含所有抽象产品的一组创建方法。</p>
</li>
<li><p>Implement a set of concrete factory classes, one for each product variant.<br>实现一组具体的工厂类，每个产品变型对应一个。</p>
</li>
<li><p>Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.<br>在应用的某个位置创建工厂初始化代码。它应该实例化一个具体的工厂类，具体取决于应用程序配置或当前环境。将此工厂对象传递给构造产品的所有类。</p>
</li>
<li><p>Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.<br>扫描代码并找到对产品构造函数的所有直接调用。将它们替换为对工厂对象上相应创建方法的调用。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><h3 id="Pros-优点"><a href="#Pros-优点" class="headerlink" title="Pros 优点"></a>Pros 优点</h3><ul>
<li>You can be sure that the products you’re getting from a factory are compatible with each other.<br>您可以确定您从工厂获得的产品彼此兼容。</li>
<li>You avoid tight coupling between concrete products and client code.<br>可以避免具体产品和客户端代码之间的紧密耦合。</li>
<li>Single Responsibility Principle. You can extract the product creation code into one place, making the code easier to support.<br>单一责任原则。您可以将产品创建代码提取到一个位置，使代码更易于支持。</li>
<li>Open&#x2F;Closed Principle. You can introduce new variants of products without breaking existing client code.<br>开&#x2F;闭原理。您可以在不破坏现有客户端代码的情况下引入新的产品变体。</li>
</ul>
<h3 id="Cons-缺点"><a href="#Cons-缺点" class="headerlink" title="Cons 缺点"></a>Cons 缺点</h3><ul>
<li>The code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern.<br>代码可能会变得比应有的更复杂，因为许多新的接口和类与模式一起引入。</li>
</ul>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Many designs start by using <strong>Factory Method</strong> (less complicated and more customizable via subclasses) and evolve toward <strong>Abstract Factory</strong>, <strong>Prototype</strong>, or <strong>Builder</strong> (more flexible, but more complicated).<br>许多设计从使用工厂方法（不那么复杂，通过子类更可定制）开始，然后发展到抽象工厂、原型或构建器（更灵活，但更复杂）。</p>
</li>
<li><p><strong>Builder</strong> focuses on constructing complex objects step by step.** Abstract Factory** specializes in creating families of related objects. <strong>Abstract Factory</strong> returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.<br>Builder 专注于逐步构建复杂的对象。Abstract Factory专门用于创建相关对象的族。Abstract Factory 会立即返回产品，而 Builder 允许您在获取产品之前运行一些额外的构造步骤。</p>
</li>
<li><p><strong>Abstract Factory</strong> classes are often based on a set of <strong>Factory Methods</strong>, but you can also use <strong>Prototype</strong> to compose the methods on these classes.<br>抽象工厂类通常基于一组工厂方法，但您也可以使用 Prototype 来组合这些类的方法。</p>
</li>
<li><p><strong>Abstract Factory</strong> can serve as an alternative to <strong>Facade</strong> when you only want to hide the way the subsystem objects are created from the client code.<br>抽象工厂可以作为 Facade 的替代方法，当您只想从客户端代码中隐藏子系统对象的创建方式时。</p>
</li>
<li><p>You can use <strong>Abstract Factory</strong> along with <strong>Bridge</strong>. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.<br>您可以将 Abstract Factory 与 Bridge 一起使用。当 Bridge 定义的某些抽象只能与特定实现一起使用时，这种配对非常有用。在这种情况下，抽象工厂可以封装这些关系，并从客户端代码中隐藏复杂性。</p>
</li>
<li><p><strong>Abstract Factories</strong>, <strong>Builders</strong> and <strong>Prototypes</strong> can all be implemented as <strong>Singletons</strong>.<br>抽象工厂、构建器和原型都可以作为单例实现。</p>
</li>
</ul>
<h2 id="Code-Examples-示例代码"><a href="#Code-Examples-示例代码" class="headerlink" title="Code Examples 示例代码"></a>Code Examples 示例代码</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Abstract Factory interface declares a set of methods that return</span></span><br><span class="line"><span class="string">    different abstract products. These products are called a family and are</span></span><br><span class="line"><span class="string">    related by a high-level theme or concept. Products of one family are usually</span></span><br><span class="line"><span class="string">    able to collaborate among themselves. A family of products may have several</span></span><br><span class="line"><span class="string">    variants, but the products of one variant are incompatible with products of</span></span><br><span class="line"><span class="string">    another.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_a</span>(<span class="params">self</span>) -&gt; AbstractProductA:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_b</span>(<span class="params">self</span>) -&gt; AbstractProductB:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span>(<span class="title class_ inherited__">AbstractFactory</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Concrete Factories produce a family of products that belong to a single</span></span><br><span class="line"><span class="string">    variant. The factory guarantees that resulting products are compatible. Note</span></span><br><span class="line"><span class="string">    that signatures of the Concrete Factory&#x27;s methods return an abstract</span></span><br><span class="line"><span class="string">    product, while inside the method a concrete product is instantiated.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_a</span>(<span class="params">self</span>) -&gt; AbstractProductA:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProductA1()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_b</span>(<span class="params">self</span>) -&gt; AbstractProductB:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProductB1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span>(<span class="title class_ inherited__">AbstractFactory</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Each Concrete Factory has a corresponding product variant.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_a</span>(<span class="params">self</span>) -&gt; AbstractProductA:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProductA2()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_b</span>(<span class="params">self</span>) -&gt; AbstractProductB:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProductB2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductA</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Each distinct product of a product family should have a base interface. All</span></span><br><span class="line"><span class="string">    variants of the product must implement this interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_a</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Products are created by corresponding Concrete Factories.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA1</span>(<span class="title class_ inherited__">AbstractProductA</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_a</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The result of the product A1.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA2</span>(<span class="title class_ inherited__">AbstractProductA</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_a</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The result of the product A2.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductB</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Here&#x27;s the the base interface of another product. All products can interact</span></span><br><span class="line"><span class="string">    with each other, but proper interaction is possible only between products of</span></span><br><span class="line"><span class="string">    the same concrete variant.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_b</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Product B is able to do its own thing...</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">another_useful_function_b</span>(<span class="params">self, collaborator: AbstractProductA</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        ...but it also can collaborate with the ProductA.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The Abstract Factory makes sure that all products it creates are of the</span></span><br><span class="line"><span class="string">        same variant and thus, compatible.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Products are created by corresponding Concrete Factories.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB1</span>(<span class="title class_ inherited__">AbstractProductB</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_b</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The result of the product B1.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The variant, Product B1, is only able to work correctly with the variant,</span></span><br><span class="line"><span class="string">    Product A1. Nevertheless, it accepts any instance of AbstractProductA as an</span></span><br><span class="line"><span class="string">    argument.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">another_useful_function_b</span>(<span class="params">self, collaborator: AbstractProductA</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        result = collaborator.useful_function_a()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;The result of the B1 collaborating with the (<span class="subst">&#123;result&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB2</span>(<span class="title class_ inherited__">AbstractProductB</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_b</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The result of the product B2.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">another_useful_function_b</span>(<span class="params">self, collaborator: AbstractProductA</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The variant, Product B2, is only able to work correctly with the</span></span><br><span class="line"><span class="string">        variant, Product A2. Nevertheless, it accepts any instance of</span></span><br><span class="line"><span class="string">        AbstractProductA as an argument.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = collaborator.useful_function_a()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;The result of the B2 collaborating with the (<span class="subst">&#123;result&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">factory: AbstractFactory</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code works with factories and products only through abstract</span></span><br><span class="line"><span class="string">    types: AbstractFactory and AbstractProduct. This lets you pass any factory</span></span><br><span class="line"><span class="string">    or product subclass to the client code without breaking it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    product_a = factory.create_product_a()</span><br><span class="line">    product_b = factory.create_product_b()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;product_b.useful_function_b()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;product_b.another_useful_function_b(product_a)&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code can work with any concrete factory class.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Testing client code with the first factory type:&quot;</span>)</span><br><span class="line">    client_code(ConcreteFactory1())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Testing the same client code with the second factory type:&quot;</span>)</span><br><span class="line">    client_code(ConcreteFactory2())</span><br></pre></td></tr></table></figure>

<h3 id="Output-txt-Exception-result"><a href="#Output-txt-Exception-result" class="headerlink" title="Output.txt: Exception result"></a>Output.txt: Exception result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: Testing client code with the first factory type:</span><br><span class="line">The result of the product B1.</span><br><span class="line">The result of the B1 collaborating with the (The result of the product A1.)</span><br><span class="line"></span><br><span class="line">Client: Testing the same client code with the second factory type:</span><br><span class="line">The result of the product B2.</span><br><span class="line">The result of the B2 collaborating with the (The result of the product A2.)</span><br></pre></td></tr></table></figure>
<h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><h4 id="GUI-Elements-Factory-GUI-元素工厂"><a href="#GUI-Elements-Factory-GUI-元素工厂" class="headerlink" title="GUI Elements Factory GUI 元素工厂"></a>GUI Elements Factory GUI 元素工厂</h4><p>This example illustrates how a GUI framework can organize its classes into independent libraries:<br>此示例说明了 GUI 框架如何将其类组织到独立的库中：</p>
<ol>
<li>The gui library defines interfaces for all the components.<br>该 gui 库定义了所有组件的接口。<br>It has no external dependencies.<br>它没有外部依赖关系。</li>
<li>The windows-gui library provides Windows implementation of the base GUI.<br>该 windows-gui 库提供基本 GUI 的 Windows 实现。<br>Depends on gui.<br>取决于 gui 。</li>
<li>The macos-gui library provides Mac OS implementation of the base GUI.<br>该 macos-gui 库提供基本 GUI 的 Mac OS 实现。<br>Depends on gui.<br>取决于 gui 。<br>The app is a client application that can use several implementations of the GUI framework, depending on the current environment or configuration. However, most of the app code doesn’t depend on specific types of GUI elements. All the client code works with GUI elements through abstract interfaces (traits) defined by the gui lib.<br>是一个 app 客户端应用程序，可以使用 GUI 框架的多个实现，具体取决于当前环境或配置。但是，大多数 app 代码并不依赖于特定类型的 GUI 元素。所有客户端代码都通过 gui 库定义的抽象接口（特征）与 GUI 元素一起使用。</li>
</ol>
<p>There are two approaches to implementing abstract factories in Rust:<br>在 Rust 中实现抽象工厂有两种方法：<br>1.using generics (static dispatch)<br>使用泛型（静态调度）<br>2.using dynamic allocation (dynamic dispatch)<br>使用动态分配（动态调度）</p>
<p>When you’re given a choice between static and dynamic dispatch, there is rarely a clear-cut correct answer. You’ll want to use static dispatch in your libraries and dynamic dispatch in your binaries. In a library, you want to allow your users to decide what kind of dispatch is best for them since you don’t know what their needs are. If you use dynamic dispatch, they’re forced to do the same, whereas if you use static dispatch, they can choose whether to use dynamic dispatch or not.<br>当您在静态调度和动态调度之间做出选择时，很少有明确的正确答案。您需要在库中使用静态调度，在二进制文件中使用动态调度。在图书馆中，您希望允许用户决定哪种调度最适合他们，因为您不知道他们的需求是什么。如果您使用动态调度，他们将被迫执行相同的操作，而如果您使用静态调度，则可以选择是否使用动态调度。</p>
<h4 id="gui-Abstract-Factory-and-Abstract-Products-gui：抽象工厂和抽象产品"><a href="#gui-Abstract-Factory-and-Abstract-Products-gui：抽象工厂和抽象产品" class="headerlink" title="gui: Abstract Factory and Abstract Products gui：抽象工厂和抽象产品"></a>gui: Abstract Factory and Abstract Products gui：抽象工厂和抽象产品</h4><ul>
<li>gui&#x2F;lib.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">press</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Checkbox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">switch</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Abstract Factory defined using generics.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">GuiFactory</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">B</span>: Button;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">C</span>: Checkbox;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::B;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_checkbox</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Abstract Factory defined using Box pointer.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">GuiFactoryDynamic</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Button&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_checkbox</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Checkbox&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>macos-gui: One family of products<br>file: macos-gui&#x2F;lib.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> button;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> checkbox;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> factory;</span><br></pre></td></tr></table></figure></li>
<li>windows-gui: Another family of products<br>file: windows-gui&#x2F;lib.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> button;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> checkbox;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> factory;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Static-dispatch-静态调度"><a href="#Static-dispatch-静态调度" class="headerlink" title="Static dispatch 静态调度"></a>Static dispatch 静态调度</h4><p>Here, the abstract factory is implemented via generics which lets the compiler create a code that does NOT require dynamic dispatch in runtime.<br>在这里，抽象工厂是通过泛型实现的，它允许编译器创建不需要在运行时动态调度的代码。</p>
<ul>
<li>app: Client code with static dispatch<br>file: app&#x2F;main.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> render;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> render::render;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> macos_gui::factory::MacFactory;</span><br><span class="line"><span class="keyword">use</span> windows_gui::factory::WindowsFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">windows</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> windows &#123;</span><br><span class="line">        <span class="title function_ invoke__">render</span>(WindowsFactory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">render</span>(MacFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
file: app&#x2F;render.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! The code demonstrates that it doesn&#x27;t depend on a concrete</span></span><br><span class="line"><span class="comment">//! factory implementation.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gui::GuiFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Renders GUI. Factory object must be passed as a parameter to such the</span></span><br><span class="line"><span class="comment">// generic function with factory invocation to utilize static dispatch.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">render</span>(factory: <span class="keyword">impl</span> <span class="title class_">GuiFactory</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button1</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button2</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">checkbox1</span> = factory.<span class="title function_ invoke__">create_checkbox</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">checkbox2</span> = factory.<span class="title function_ invoke__">create_checkbox</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> gui::&#123;Button, Checkbox&#125;;</span><br><span class="line"></span><br><span class="line">    button1.<span class="title function_ invoke__">press</span>();</span><br><span class="line">    button2.<span class="title function_ invoke__">press</span>();</span><br><span class="line">    checkbox1.<span class="title function_ invoke__">switch</span>();</span><br><span class="line">    checkbox2.<span class="title function_ invoke__">switch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Dynamic-dispatch-动态调度"><a href="#Dynamic-dispatch-动态调度" class="headerlink" title="Dynamic dispatch 动态调度"></a>Dynamic dispatch 动态调度</h4><p>If a concrete type of abstract factory is not known at the compilation time, then is should be implemented using Box pointers.<br>如果在编译时不知道抽象工厂的具体类型，则应使用 Box 指针实现。</p>
<ul>
<li>app-dyn: Client code with dynamic dispatch<br>file: app-dyn&#x2F;main.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> render;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> render::render;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gui::GuiFactoryDynamic;</span><br><span class="line"><span class="keyword">use</span> macos_gui::factory::MacFactory;</span><br><span class="line"><span class="keyword">use</span> windows_gui::factory::WindowsFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">windows</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a factory object in runtime depending on unpredictable input.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">factory</span>: &amp;<span class="keyword">dyn</span> GuiFactoryDynamic = <span class="keyword">if</span> windows &#123;</span><br><span class="line">        &amp;WindowsFactory</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &amp;MacFactory</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Factory invocation can be inlined right here.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    button.<span class="title function_ invoke__">press</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Factory object can be passed to a function as a parameter.</span></span><br><span class="line">    <span class="title function_ invoke__">render</span>(factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
file: app-dyn&#x2F;render.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! The code demonstrates that it doesn&#x27;t depend on a concrete</span></span><br><span class="line"><span class="comment">//! factory implementation.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gui::GuiFactoryDynamic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Renders GUI.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">render</span>(factory: &amp;<span class="keyword">dyn</span> GuiFactoryDynamic) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button1</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button2</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">checkbox1</span> = factory.<span class="title function_ invoke__">create_checkbox</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">checkbox2</span> = factory.<span class="title function_ invoke__">create_checkbox</span>();</span><br><span class="line"></span><br><span class="line">    button1.<span class="title function_ invoke__">press</span>();</span><br><span class="line">    button2.<span class="title function_ invoke__">press</span>();</span><br><span class="line">    checkbox1.<span class="title function_ invoke__">switch</span>();</span><br><span class="line">    checkbox2.<span class="title function_ invoke__">switch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows button has pressed</span><br><span class="line">Windows button has pressed</span><br><span class="line">Windows checkbox has switched</span><br><span class="line">Windows checkbox has switched</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Adapter</title>
    <url>/2023/12/03/design-pattern/adapter/</url>
    <content><![CDATA[<h1 id="Adapter-适配器"><a href="#Adapter-适配器" class="headerlink" title="Adapter 适配器"></a>Adapter 适配器</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Adapter</strong> is a structural design pattern that allows objects with incompatible interfaces to collaborate.<br>适配器是一种结构设计模式，它允许具有不兼容接口的对象进行协作。</p>
<div align="center"> <img src="/images/adapter-header.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Imagine that you’re creating a stock market monitoring app. The app downloads the stock data from multiple sources in XML format and then displays nice-looking charts and diagrams for the user.<br>想象一下，您正在创建一个股票市场监控应用程序。该应用程序以XML格式从多个来源下载股票数据，然后为用户显示漂亮的图表和图表。</p>
<p>At some point, you decide to improve the app by integrating a smart 3rd-party analytics library. But there’s a catch: the analytics library only works with data in JSON format.<br>在某些时候，您决定通过集成智能第三方分析库来改进应用程序。但有一个问题：分析库仅适用于 JSON 格式的数据。</p>
<div align="center"> <img src="/images/adapter-problem-en.png"/>You can’t use the analytics library “as is” because it expects the data in a format that’s incompatible with your app.</br>您不能“按原样”使用分析库，因为它需要的数据格式与您的应用不兼容。</div>
You could change the library to work with XML. However, this might break some existing code that relies on the library. And worse, you might not have access to the library’s source code in the first place, making this approach impossible.
您可以更改库以使用 XML。但是，这可能会破坏一些依赖于该库的现有代码。更糟糕的是，您可能一开始就无法访问库的源代码，从而无法使用此方法。

<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>You can create an adapter. This is a special object that converts the interface of one object so that another object can understand it.<br>您可以创建适配器。这是一个特殊的对象，它转换一个对象的接口，以便另一个对象可以理解它。</p>
<p>An adapter wraps one of the objects to hide the complexity of conversion happening behind the scenes. The wrapped object isn’t even aware of the adapter. For example, you can wrap an object that operates in meters and kilometers with an adapter that converts all of the data to imperial units such as feet and miles.<br>适配器包装其中一个对象，以隐藏在后台发生的转换的复杂性。包装的对象甚至不知道适配器。例如，您可以使用适配器包装以米和公里为单位运行的对象，该适配器将所有数据转换为英制单位（如英尺和英里）。</p>
<p>Adapters can not only convert data into various formats but can also help objects with different interfaces collaborate. Here’s how it works:<br>适配器不仅可以将数据转换为各种格式，还可以帮助具有不同接口的对象进行协作。其工作原理如下：</p>
<ol>
<li>The adapter gets an interface, compatible with one of the existing objects.<br>适配器获取一个接口，该接口与现有对象之一兼容。</li>
<li>Using this interface, the existing object can safely call the adapter’s methods.<br>使用此接口，现有对象可以安全地调用适配器的方法。</li>
<li>Upon receiving a call, the adapter passes the request to the second object, but in a format and order that the second object expects.<br>收到调用后，适配器将请求传递给第二个对象，但采用第二个对象期望的格式和顺序。</li>
</ol>
<p>Sometimes it’s even possible to create a two-way adapter that can convert the calls in both directions.<br>有时甚至可以创建一个双向适配器，可以在两个方向上转换呼叫。</p>
<div align="center"> <img src="/images/adapter-solution.png"/></div>
Let’s get back to our stock market app. To solve the dilemma of incompatible formats, you can create XML-to-JSON adapters for every class of the analytics library that your code works with directly. Then you adjust your code to communicate with the library only via these adapters. When an adapter receives a call, it translates the incoming XML data into a JSON structure and passes the call to the appropriate methods of a wrapped analytics object.

<p>让我们回到我们的股票市场应用程序。为了解决格式不兼容的难题，您可以为代码直接使用的分析库的每个类创建 XML 到 JSON 适配器。然后，将代码调整为仅通过这些适配器与库通信。当适配器收到调用时，它会将传入的 XML 数据转换为 JSON 结构，并将调用传递给包装的分析对象的相应方法。</p>
<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><div align="center"> <img src="/images/adapter-comic-1.png"/>A suitcase before and after a trip abroad.</br>出国旅行前后的行李箱。</div>
When you travel from the US to Europe for the first time, you may get a surprise when trying to charge your laptop. The power plug and sockets standards are different in different countries. That’s why your US plug won’t fit a German socket. The problem can be solved by using a power plug adapter that has the American-style socket and the European-style plug.
当您第一次从美国到欧洲旅行时，当您尝试为笔记本电脑充电时，您可能会感到惊讶。不同国家的电源插头和插座标准不同。这就是为什么您的美国插头不适合德国插座的原因。这个问题可以通过使用具有美式插座和欧式插头的电源插头适配器来解决。

<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><h3 id="Object-adapter-对象适配器"><a href="#Object-adapter-对象适配器" class="headerlink" title="Object adapter 对象适配器"></a>Object adapter 对象适配器</h3><p>This implementation uses the object composition principle: the adapter implements the interface of one object and wraps the other one. It can be implemented in all popular programming languages.<br>此实现使用对象组合原则：适配器实现一个对象的接口并包装另一个对象。它可以用所有流行的编程语言实现。</p>
<div align="center"> <img src="/images/adapter-structure-object-adapter.png"/></div>

<ol>
<li><p>The Client is a class that contains the existing business logic of the program.<br>Client 是一个包含程序现有业务逻辑的类。</p>
</li>
<li><p>The Client Interface describes a protocol that other classes must follow to be able to collaborate with the client code.<br>客户端接口描述了其他类必须遵循的协议，以便能够与客户端代码进行协作。</p>
</li>
<li><p>The Service is some useful class (usually 3rd-party or legacy). The client can’t use this class directly because it has an incompatible interface.<br>服务是一些有用的类（通常是第三方或旧版）。客户端不能直接使用此类，因为它具有不兼容的接口。</p>
</li>
<li><p>The <strong>Adapter</strong> is a class that’s able to work with both the client and the service: it implements the client interface, while wrapping the service object. The adapter receives calls from the client via the client interface and translates them into calls to the wrapped service object in a format it can understand.<br>Adapter 是一个能够同时使用客户端和服务的类：它实现客户端接口，同时包装服务对象。适配器通过客户端接口接收来自客户端的调用，并以它可以理解的格式将其转换为对包装的服务对象的调用。</p>
</li>
<li><p>The client code doesn’t get coupled to the concrete adapter class as long as it works with the adapter via the client interface. Thanks to this, you can introduce new types of adapters into the program without breaking the existing client code. This can be useful when the interface of the service class gets changed or replaced: you can just create a new adapter class without changing the client code.<br>只要客户端代码通过客户端接口与适配器一起使用，它就不会耦合到具体的适配器类。因此，您可以在不破坏现有客户端代码的情况下将新类型的适配器引入程序。当服务类的接口被更改或替换时，这可能很有用：您可以只创建一个新的适配器类，而无需更改客户端代码。</p>
</li>
</ol>
<h3 id="Class-adapter-类适配器"><a href="#Class-adapter-类适配器" class="headerlink" title="Class adapter 类适配器"></a>Class adapter 类适配器</h3><p>This implementation uses inheritance: the adapter inherits interfaces from both objects at the same time. Note that this approach can only be implemented in programming languages that support multiple inheritance, such as C++.<br>此实现使用继承：适配器同时从两个对象继承接口。请注意，此方法只能在支持多重继承的编程语言（如 C++）中实现。</p>
<div align="center"> <img src="/images/adapter-structure-class-adapter.png"/></div>

<ol>
<li>The Class Adapter doesn’t need to wrap any objects because it inherits behaviors from both the client and the service. The adaptation happens within the overridden methods. The resulting adapter can be used in place of an existing client class.<br>类适配器不需要包装任何对象，因为它从客户端和服务继承行为。适应发生在被覆盖的方法中。生成的适配器可用于代替现有的客户端类。</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example of the <strong>Adapter</strong> pattern is based on the classic conflict between square pegs and round holes.<br>此适配器模式示例基于方形钉子和圆孔之间的经典冲突。</p>
<div align="center"> <img src="/images/adapter-example.png"/>Adapting square pegs to round holes.</br>使方钉适应圆孔。</div>
The Adapter pretends to be a round peg, with a radius equal to a half of the square’s diameter (in other words, the radius of the smallest circle that can accommodate the square peg).
适配器假装是一个圆钉，其半径等于正方形直径的一半（换句话说，可以容纳方形钉的最小圆的半径）。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Say you have two classes with compatible interfaces:</span></span><br><span class="line"><span class="comment">// RoundHole and RoundPeg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundHole</span> is</span><br><span class="line">    constructor <span class="title function_">RoundHole</span><span class="params">(radius)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getRadius</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Return the radius of the hole.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">fits</span><span class="params">(peg: RoundPeg)</span> is</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getRadius() &gt;= peg.getRadius()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundPeg</span> is</span><br><span class="line">    constructor <span class="title function_">RoundPeg</span><span class="params">(radius)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getRadius</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Return the radius of the peg.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// But there&#x27;s an incompatible class: SquarePeg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquarePeg</span> is</span><br><span class="line">    constructor <span class="title function_">SquarePeg</span><span class="params">(width)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getWidth</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Return the square peg width.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// An adapter class lets you fit square pegs into round holes.</span></span><br><span class="line"><span class="comment">// It extends the RoundPeg class to let the adapter objects act</span></span><br><span class="line"><span class="comment">// as round pegs.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquarePegAdapter</span> <span class="keyword">extends</span> <span class="title class_">RoundPeg</span> is</span><br><span class="line">    <span class="comment">// In reality, the adapter contains an instance of the</span></span><br><span class="line">    <span class="comment">// SquarePeg class.</span></span><br><span class="line">    <span class="keyword">private</span> field peg: SquarePeg</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">SquarePegAdapter</span><span class="params">(peg: SquarePeg)</span> is</span><br><span class="line">        <span class="built_in">this</span>.peg = peg</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getRadius</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// The adapter pretends that it&#x27;s a round peg with a</span></span><br><span class="line">        <span class="comment">// radius that could fit the square peg that the adapter</span></span><br><span class="line">        <span class="comment">// actually wraps.</span></span><br><span class="line">        <span class="keyword">return</span> peg.getWidth() * Math.sqrt(<span class="number">2</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Somewhere in client code.</span></span><br><span class="line">hole = <span class="keyword">new</span> <span class="title class_">RoundHole</span>(<span class="number">5</span>)</span><br><span class="line">rpeg = <span class="keyword">new</span> <span class="title class_">RoundPeg</span>(<span class="number">5</span>)</span><br><span class="line">hole.fits(rpeg) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">small_sqpeg = <span class="keyword">new</span> <span class="title class_">SquarePeg</span>(<span class="number">5</span>)</span><br><span class="line">large_sqpeg = <span class="keyword">new</span> <span class="title class_">SquarePeg</span>(<span class="number">10</span>)</span><br><span class="line">hole.fits(small_sqpeg) <span class="comment">// this won&#x27;t compile (incompatible types)</span></span><br><span class="line"></span><br><span class="line">small_sqpeg_adapter = <span class="keyword">new</span> <span class="title class_">SquarePegAdapter</span>(small_sqpeg)</span><br><span class="line">large_sqpeg_adapter = <span class="keyword">new</span> <span class="title class_">SquarePegAdapter</span>(large_sqpeg)</span><br><span class="line">hole.fits(small_sqpeg_adapter) <span class="comment">// true</span></span><br><span class="line">hole.fits(large_sqpeg_adapter) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Adapter class when you want to use some existing class, but its interface isn’t compatible with the rest of your code.<br>如果要使用某些现有类，但其接口与代码的其余部分不兼容，请使用 Adapter 类。</strong></p>
</li>
<li><p>The Adapter pattern lets you create a middle-layer class that serves as a translator between your code and a legacy class, a 3rd-party class or any other class with a weird interface.<br>适配器模式允许您创建一个中间层类，该类充当代码与旧类、第三方类或任何其他具有奇怪接口的类之间的转换器。</p>
</li>
<li><p><strong>Use the pattern when you want to reuse several existing subclasses that lack some common functionality that can’t be added to the superclass.<br>如果要重用多个现有的子类，这些子类缺少一些无法添加到超类的通用功能，请使用该模式。</strong></p>
</li>
<li><p>You could extend each subclass and put the missing functionality into new child classes. However, you’ll need to duplicate the code across all of these new classes, which smells really bad.<br>您可以扩展每个子类，并将缺少的功能放入新的子类中。但是，您需要在所有这些新类中复制代码，这闻起来非常难闻。</p>
</li>
</ul>
<p>The much more elegant solution would be to put the missing functionality into an adapter class. Then you would wrap objects with missing features inside the adapter, gaining needed features dynamically. For this to work, the target classes must have a common interface, and the adapter’s field should follow that interface. This approach looks very similar to the Decorator pattern.<br>更优雅的解决方案是将缺少的功能放入适配器类中。然后，将缺少特征的对象包装在适配器内，动态获得所需的特征。为此，目标类必须具有通用接口，并且适配器的字段应遵循该接口。此方法看起来与 Decorator 模式非常相似。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Make sure that you have at least two classes with incompatible interfaces:确保至少有两个接口不兼容的类：</p>
<ul>
<li>A useful service class, which you can’t change (often 3rd-party, legacy or with lots of existing dependencies).<br>一个有用的服务类，您无法更改（通常是第三方、旧版或具有大量现有依赖项）。</li>
<li>One or several client classes that would benefit from using the service class.<br>一个或多个客户端类，这些类将从使用服务类中受益。</li>
</ul>
</li>
<li><p>Declare the client interface and describe how clients communicate with the service.<br>声明客户端接口并描述客户端如何与服务通信。</p>
</li>
<li><p>Create the adapter class and make it follow the client interface. Leave all the methods empty for now.<br>创建适配器类，并使其遵循客户端接口。暂时将所有方法留空。</p>
</li>
<li><p>Add a field to the adapter class to store a reference to the service object. The common practice is to initialize this field via the constructor, but sometimes it’s more convenient to pass it to the adapter when calling its methods.<br>向适配器类添加一个字段，以存储对服务对象的引用。通常的做法是通过构造函数初始化此字段，但有时在调用适配器的方法时将其传递给适配器会更方便。</p>
</li>
<li><p>One by one, implement all methods of the client interface in the adapter class. The adapter should delegate most of the real work to the service object, handling only the interface or data format conversion.<br>在适配器类中逐个实现客户端接口的所有方法。适配器应将大部分实际工作委托给服务对象，仅处理接口或数据格式转换。</p>
</li>
<li><p>Clients should use the adapter via the client interface. This will let you change or extend the adapters without affecting the client code.<br>客户端应通过客户端接口使用适配器。这将允许您更改或扩展适配器，而不会影响客户端代码。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>Pros 优点</th>
<th>Cons 缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Single Responsibility Principle. You can separate the interface or data conversion code from the primary business logic of the program. 单一责任原则。您可以将接口或数据转换代码与程序的主要业务逻辑分开。</td>
<td>The overall complexity of the code increases because you need to introduce a set of new interfaces and classes. Sometimes it’s simpler just to change the service class so that it matches the rest of your code. 代码的整体复杂性增加，因为您需要引入一组新的接口和类。有时，只需更改服务类以使其与代码的其余部分匹配即可更简单。</td>
</tr>
<tr>
<td>Open&#x2F;Closed Principle. You can introduce new types of adapters into the program without breaking the existing client code, as long as they work with the adapters through the client interface. 开&#x2F;闭原理。您可以在不破坏现有客户端代码的情况下将新类型的适配器引入程序，只要它们通过客户端接口与适配器一起使用即可。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.<br>Bridge 通常是预先设计的，允许您彼此独立地开发应用程序的各个部分。另一方面，Adapter 通常与现有应用程序一起使用，以使一些不兼容的类很好地协同工作。</p>
</li>
<li><p>Adapter provides a completely different interface for accessing an existing object. On the other hand, with the Decorator pattern the interface either stays the same or gets extended. In addition, Decorator supports recursive composition, which isn’t possible when you use Adapter.<br>适配器提供了一个完全不同的接口来访问现有对象。另一方面，使用 Decorator 模式，界面要么保持不变，要么得到扩展。此外，Decorator 支持递归组合，这在使用 Adapter 时是不可能的。</p>
</li>
<li><p>With Adapter you access an existing object via different interface. With Proxy, the interface stays the same. With Decorator you access the object via an enhanced interface.<br>使用 Adapter，您可以通过不同的接口访问现有对象。使用 Proxy，界面保持不变。使用 Decorator，您可以通过增强的界面访问对象。</p>
</li>
<li><p>Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.<br>Facade 为现有对象定义了一个新的接口，而 Adapter 则试图使现有接口可用。Adapter 通常只包装一个对象，而 Facade 则处理对象的整个子系统。</p>
</li>
<li><p>Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.<br>桥接、状态、策略（在某种程度上还有适配器）具有非常相似的结构。事实上，所有这些模式都是基于构图的，而构图是将工作委托给其他对象。但是，它们都解决了不同的问题。模式不仅仅是以特定方式构建代码的秘诀。它还可以向其他开发人员传达该模式解决的问题。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="Python-Conceptual-Example-via-inheritance-概念示例（通过继承）"><a href="#Python-Conceptual-Example-via-inheritance-概念示例（通过继承）" class="headerlink" title="Python: Conceptual Example (via inheritance) 概念示例（通过继承）"></a>Python: Conceptual Example (via inheritance) 概念示例（通过继承）</h3><p>This example illustrates the structure of the Adapter design pattern. It focuses on answering these questions:<br>此示例阐释了适配器设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些课程扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式的元素以何种方式相关？</li>
</ul>
<h3 id="main-py：概念示例"><a href="#main-py：概念示例" class="headerlink" title="main.py：概念示例"></a>main.py：概念示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Target defines the domain-specific interface used by the client code.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Target: The default target&#x27;s behavior.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Adaptee contains some useful behavior, but its interface is incompatible</span></span><br><span class="line"><span class="string">    with the existing client code. The Adaptee needs some adaptation before the</span></span><br><span class="line"><span class="string">    client code can use it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">specific_request</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;.eetpadA eht fo roivaheb laicepS&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span>(Target, Adaptee):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Adapter makes the Adaptee&#x27;s interface compatible with the Target&#x27;s</span></span><br><span class="line"><span class="string">    interface via multiple inheritance.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Adapter: (TRANSLATED) <span class="subst">&#123;self.specific_request()[::-<span class="number">1</span>]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">target: <span class="string">&quot;Target&quot;</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code supports all classes that follow the Target interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(target.request(), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: I can work just fine with the Target objects:&quot;</span>)</span><br><span class="line">    target = Target()</span><br><span class="line">    client_code(target)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    adaptee = Adaptee()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: The Adaptee class has a weird interface. &quot;</span></span><br><span class="line">          <span class="string">&quot;See, I don&#x27;t understand it:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Adaptee: <span class="subst">&#123;adaptee.specific_request()&#125;</span>&quot;</span>, end=<span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: But I can work with it via the Adapter:&quot;</span>)</span><br><span class="line">    adapter = Adapter()</span><br><span class="line">    client_code(adapter)</span><br></pre></td></tr></table></figure>
<h3 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: I can work just fine with the Target objects:</span><br><span class="line">Target: The default target&#x27;s behavior.</span><br><span class="line"></span><br><span class="line">Client: The Adaptee class has a weird interface. See, I don&#x27;t understand it:</span><br><span class="line">Adaptee: .eetpadA eht fo roivaheb laicepS</span><br><span class="line"></span><br><span class="line">Client: But I can work with it via the Adapter:</span><br><span class="line">Adapter: (TRANSLATED) Special behavior of the Adaptee.</span><br></pre></td></tr></table></figure>

<h3 id="Python-Conceptual-Example-via-object-composition-概念示例（通过对象组合）"><a href="#Python-Conceptual-Example-via-object-composition-概念示例（通过对象组合）" class="headerlink" title="Python: Conceptual Example (via object composition) 概念示例（通过对象组合）"></a>Python: Conceptual Example (via object composition) 概念示例（通过对象组合）</h3><p>This example illustrates the structure of the Adapter design pattern. It focuses on answering these questions:<br>此示例阐释了适配器设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些课程扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式的元素以何种方式相关？</li>
</ul>
<h3 id="main-py：概念示例-1"><a href="#main-py：概念示例-1" class="headerlink" title="main.py：概念示例"></a>main.py：概念示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Target defines the domain-specific interface used by the client code.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Target: The default target&#x27;s behavior.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Adaptee contains some useful behavior, but its interface is incompatible</span></span><br><span class="line"><span class="string">    with the existing client code. The Adaptee needs some adaptation before the</span></span><br><span class="line"><span class="string">    client code can use it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">specific_request</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;.eetpadA eht fo roivaheb laicepS&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span>(<span class="title class_ inherited__">Target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Adapter makes the Adaptee&#x27;s interface compatible with the Target&#x27;s</span></span><br><span class="line"><span class="string">    interface via composition.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, adaptee: Adaptee</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.adaptee = adaptee</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Adapter: (TRANSLATED) <span class="subst">&#123;self.adaptee.specific_request()[::-<span class="number">1</span>]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">target: Target</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code supports all classes that follow the Target interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(target.request(), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: I can work just fine with the Target objects:&quot;</span>)</span><br><span class="line">    target = Target()</span><br><span class="line">    client_code(target)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    adaptee = Adaptee()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: The Adaptee class has a weird interface. &quot;</span></span><br><span class="line">          <span class="string">&quot;See, I don&#x27;t understand it:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Adaptee: <span class="subst">&#123;adaptee.specific_request()&#125;</span>&quot;</span>, end=<span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: But I can work with it via the Adapter:&quot;</span>)</span><br><span class="line">    adapter = Adapter(adaptee)</span><br><span class="line">    client_code(adapter)</span><br></pre></td></tr></table></figure>
<h3 id="Output-txt-Execution-result-1"><a href="#Output-txt-Execution-result-1" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: I can work just fine with the Target objects:</span><br><span class="line">Target: The default target&#x27;s behavior.</span><br><span class="line"></span><br><span class="line">Client: The Adaptee class has a weird interface. See, I don&#x27;t understand it:</span><br><span class="line">Adaptee: .eetpadA eht fo roivaheb laicepS</span><br><span class="line"></span><br><span class="line">Client: But I can work with it via the Adapter:</span><br><span class="line">Adapter: (TRANSLATED) Special behavior of the Adaptee.</span><br></pre></td></tr></table></figure>

<h3 id="Adapter-in-Rust-Rust-中的适配器"><a href="#Adapter-in-Rust-Rust-中的适配器" class="headerlink" title="Adapter in Rust Rust 中的适配器"></a>Adapter in Rust Rust 中的适配器</h3><p>In this example, the <code>trait SpecificTarget</code> is incompatible with a <code>call</code> function which accepts <code>trait Target</code> only.<br>在此示例中，与 <code>trait SpecificTarget</code> 仅接受 <code>call</code> <code>trait Target</code> 的函数不兼容。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">call</span>(target: <span class="keyword">impl</span> <span class="title class_">Target</span>);</span><br></pre></td></tr></table></figure>
<p>The adapter helps to pass the incompatible interface to the <code>call</code> function.<br>适配器有助于将不兼容的接口传递给 <code>call</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">target</span> = TargetAdapter::<span class="title function_ invoke__">new</span>(specific_target);</span><br><span class="line"><span class="title function_ invoke__">call</span>(target);</span><br></pre></td></tr></table></figure>

<h4 id="adapter-rs"><a href="#adapter-rs" class="headerlink" title="adapter.rs"></a>adapter.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;adaptee::SpecificTarget, Target&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Converts adaptee&#x27;s specific interface to a compatible `Target` output.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TargetAdapter</span> &#123;</span><br><span class="line">    adaptee: SpecificTarget,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TargetAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(adaptee: SpecificTarget) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; adaptee &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Target</span> <span class="keyword">for</span> <span class="title class_">TargetAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// Here&#x27;s the &quot;adaptation&quot; of a specific output to a compatible output.</span></span><br><span class="line">        <span class="keyword">self</span>.adaptee.<span class="title function_ invoke__">specific_request</span>().<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">rev</span>().<span class="title function_ invoke__">collect</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="adaptee-rs"><a href="#adaptee-rs" class="headerlink" title="adaptee.rs"></a>adaptee.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpecificTarget</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SpecificTarget</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">specific_request</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;.tseuqer cificepS&quot;</span>.<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="target-rs"><a href="#target-rs" class="headerlink" title="target.rs"></a>target.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">OrdinaryTarget</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Target</span> <span class="keyword">for</span> <span class="title class_">OrdinaryTarget</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;Ordinary request.&quot;</span>.<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a>main.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> adaptee;</span><br><span class="line"><span class="keyword">mod</span> adapter;</span><br><span class="line"><span class="keyword">mod</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> adaptee::SpecificTarget;</span><br><span class="line"><span class="keyword">use</span> adapter::TargetAdapter;</span><br><span class="line"><span class="keyword">use</span> target::&#123;OrdinaryTarget, Target&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Calls any object of a `Target` trait.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// To understand the Adapter pattern better, imagine that this is</span></span><br><span class="line"><span class="comment">/// a client code, which can operate over a specific interface only</span></span><br><span class="line"><span class="comment">/// (`Target` trait only). It means that an incompatible interface cannot be</span></span><br><span class="line"><span class="comment">/// passed here without an adapter.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call</span>(target: <span class="keyword">impl</span> <span class="title class_">Target</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#x27;&#123;&#125;&#x27;&quot;</span>, target.<span class="title function_ invoke__">request</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">target</span> = OrdinaryTarget;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;A compatible target can be directly called: &quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">call</span>(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">adaptee</span> = SpecificTarget;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;Adaptee is incompatible with client: &#x27;&#123;&#125;&#x27;&quot;</span>,</span><br><span class="line">        adaptee.<span class="title function_ invoke__">specific_request</span>()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">adapter</span> = TargetAdapter::<span class="title function_ invoke__">new</span>(adaptee);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;But with adapter client can call its method: &quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">call</span>(adapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A compatible target can be directly called: &#x27;Ordinary request.&#x27;</span><br><span class="line">Adaptee is incompatible with client: &#x27;.tseuqer cificepS&#x27;</span><br><span class="line">But with adapter client can call its method: &#x27;Specific request.&#x27;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Builder</title>
    <url>/2023/11/21/design-pattern/builder/</url>
    <content><![CDATA[<h1 id="Builder-建造者"><a href="#Builder-建造者" class="headerlink" title="Builder 建造者"></a>Builder 建造者</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Builder</strong> is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code.<br><strong>Builder</strong> 是一种创建性设计模式，可让您逐步构建复杂的对象。该模式允许您使用相同的构造代码生成对象的不同类型和表示形式。</p>
<div align="center"> <img src="/images/builder-en.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Imagine a complex object that requires laborious, step-by-step initialization of many fields and nested objects. Such initialization code is usually buried inside a monstrous constructor with lots of parameters. Or even worse: scattered all over the client code.<br>想象一个复杂的对象，需要费力地逐步初始化许多字段和嵌套对象。这种初始化代码通常隐藏在具有大量参数的可怕构造函数中。或者更糟糕的是：分散在客户端代码中。</p>
<div align="center"> <img src="/images/builder-problem1.png"/>You might make the program too complex by creating a subclass for every possible configuration of an object.</通过为对象的每个可能配置创建一个子类，可能会使程序过于复杂。></div>

<p>For example, let’s think about how to create a <code>House</code> object. To build a simple house, you need to construct four walls and a floor, install a door, fit a pair of windows, and build a roof. But what if you want a bigger, brighter house, with a backyard and other goodies (like a heating system, plumbing, and electrical wiring)?<br>例如，让我们考虑如何创建一个 <code>House</code> 对象。要建造一个简单的房子，你需要建造四面墙和一个地板，安装一扇门，安装一对窗户，并建造一个屋顶。但是，如果您想要一个更大、更明亮的房子，有后院和其他好东西（如供暖系统、管道和电线）怎么办？</p>
<p>The simplest solution is to extend the base <code>House</code> class and create a set of subclasses to cover all combinations of the parameters. But eventually you’ll end up with a considerable number of subclasses. Any new parameter, such as the porch style, will require growing this hierarchy even more.<br>最简单的解决方案是扩展基 <code>House</code> 类并创建一组子类以涵盖参数的所有组合。但最终你会得到相当多的子类。任何新参数（例如门廊样式）都需要进一步扩展此层次结构。</p>
<p>There’s another approach that doesn’t involve breeding subclasses. You can create a giant constructor right in the base <code>House</code> class with all possible parameters that control the house object. While this approach indeed eliminates the need for subclasses, it creates another problem.<br>还有另一种方法不涉及育种子类。您可以直接在基 <code>House</code> 类中创建一个巨大的构造函数，其中包含控制 house 对象的所有可能参数。虽然这种方法确实消除了对子类的需求，但它产生了另一个问题。</p>
<div align="center"> <img src="/images/builder-problem2.png"/>The constructor with lots of parameters has its downside: not all the parameters are needed at all times.</br>具有大量参数的构造函数有其缺点：并非所有参数都是必需的。</div>

<p>In most cases most of the parameters will be unused, making <strong>the constructor calls pretty ugly</strong>. For instance, only a fraction of houses have swimming pools, so the parameters related to swimming pools will be useless nine times out of ten.<br>在大多数情况下，大多数参数将处于未使用状态，这使得构造函数调用非常丑陋。例如，只有一小部分房屋有游泳池，因此与游泳池相关的参数十有八九将毫无用处。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The Builder pattern suggests that you extract the object construction code out of its own class and move it to separate objects called builders.<br>Builder 模式建议您将对象构造代码从其自己的类中提取出来，并将其移动到称为生成器的单独对象中。</p>
<div align="center"> <img src="/images/builder-solution1.png"/>The Builder pattern lets you construct complex objects step by step. The Builder doesn’t allow other objects to access the product while it’s being built.</br>Builder 模式允许您逐步构建复杂的对象。Builder 不允许其他对象在构建产品时访问产品。</div>

<p>The pattern organizes object construction into a set of steps (<code>buildWalls</code>, <code>buildDoor</code>, etc.). To create an object, you execute a series of these steps on a builder object. The important part is that you don’t need to call all of the steps. You can call only those steps that are necessary for producing a particular configuration of an object.<br>该模式将对象构造组织为一组步骤（<code>buildWalls</code>, <code>buildDoor</code> 等）。要创建对象，请在生成器对象上执行一系列这些步骤。重要的是，您不需要调用所有步骤。您只能调用生成对象的特定配置所需的那些步骤。</p>
<p>Some of the construction steps might require different implementation when you need to build various representations of the product. For example, walls of a cabin may be built of wood, but the castle walls must be built with stone.<br>当您需要构建产品的各种表示形式时，某些构造步骤可能需要不同的实现。例如，小屋的墙壁可以用木头建造，但城堡的墙壁必须用石头建造。</p>
<p>In this case, you can create several different builder classes that implement the same set of building steps, but in a different manner. Then you can use these builders in the construction process (i.e., an ordered set of calls to the building steps) to produce different kinds of objects.<br>在这种情况下，您可以创建多个不同的生成器类，这些类以不同的方式实现同一组生成步骤。然后，您可以在构造过程中使用这些构建器（即，对构建步骤的一组有序调用）来生成不同类型的对象。</p>
<div align="center"> <img src="/images/builder-comic-1-en.png"/>Different builders execute the same task in various ways.</br>不同的构建器以不同的方式执行相同的任务。</div>

<p>For example, imagine a builder that builds everything from wood and glass, a second one that builds everything with stone and iron and a third one that uses gold and diamonds. By calling the same set of steps, you get a regular house from the first builder, a small castle from the second and a palace from the third. However, this would only work if the client code that calls the building steps is able to interact with builders using a common interface.<br>例如，想象一个建筑商用木头和玻璃建造所有东西，第二个建筑商用石头和铁建造所有东西，第三个建筑商使用黄金和钻石建造所有东西。通过调用相同的步骤，您可以从第一个建筑商那里获得普通房屋，从第二个建造者那里获得一座小城堡，从第三个建造者那里获得一座宫殿。但是，仅当调用生成步骤的客户端代码能够使用通用接口与构建器交互时，这才有效。</p>
<h2 id="Director"><a href="#Director" class="headerlink" title="Director"></a>Director</h2><p>You can go further and extract a series of calls to the builder steps you use to construct a product into a separate class called director. The director class defines the order in which to execute the building steps, while the builder provides the implementation for those steps.<br>您可以更进一步，将对用于将产品构造到称为 director 的单独类的构建器步骤的一系列调用中提取出来。director 类定义执行生成步骤的顺序，而生成器则提供这些步骤的实现。</p>
<div align="center"> <img src="/images/builder-comic-2-en.png"/>The director knows which building steps to execute to get a working product.</br>主管知道要执行哪些构建步骤才能获得工作产品。</div>

<p>Having a director class in your program isn’t strictly necessary. You can always call the building steps in a specific order directly from the client code. However, the director class might be a good place to put various construction routines so you can reuse them across your program.<br>在您的课程中开设director类并不是绝对必要的。您始终可以直接从客户端代码按特定顺序调用生成步骤。但是，director 类可能是放置各种构造例程的好地方，以便您可以在程序中重用它们。</p>
<p>In addition, the director class completely hides the details of product construction from the client code. The client only needs to associate a builder with a director, launch the construction with the director, and get the result from the builder.<br>此外，director 类在客户端代码中完全隐藏了产品构造的细节。客户端只需将构建器与控制器关联，与控制器一起启动构造，并从构建器获取结果。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/builder-structure.png"/></div>

<ol>
<li><p>The <strong>Builder</strong> interface declares product construction steps that are common to all types of builders.<br>Builder 界面声明了所有类型的构建器通用的产品构建步</p>
</li>
<li><p><strong>Concrete</strong> Builders provide different implementations of the construction steps. Concrete builders may produce products that don’t follow the common interface.<br>混凝土建造者提供施工步骤的不同实施。混凝土建筑商可能会生产不遵循通用接口的产品。</p>
</li>
<li><p><strong>Products</strong> are resulting objects. Products constructed by different builders don’t have to belong to the same class hierarchy or interface.<br>产品是结果对象。由不同构建器构建的产品不必属于相同的类层次结构或接口。</p>
</li>
<li><p>The <strong>Director</strong> class defines the order in which to call construction steps, so you can create and reuse specific configurations of products.<br>Director 类定义调用构造步骤的顺序，以便您可以创建和重用产品的特定配置。</p>
</li>
<li><p>The <strong>Client</strong> must associate one of the builder objects with the director. Usually, it’s done just once, via parameters of the director’s constructor. Then the director uses that builder object for all further construction. However, there’s an alternative approach for when the client passes the builder object to the production method of the director. In this case, you can use a different builder each time you produce something with the director.<br>客户端必须将其中一个构建器对象与控制器相关联。通常，它只通过控制器构造函数的参数完成一次。然后，director 使用该构建器对象进行所有进一步的构造。但是，当客户端将生成器对象传递给控制器的生产方法时，还有另一种方法。在这种情况下，每次与director一起制作内容时，都可以使用不同的构建器。</p>
</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example of the <strong>Builder</strong> pattern illustrates how you can reuse the same object construction code when building different types of products, such as cars, and create the corresponding manuals for them.<br>此 Builder 模式示例说明了如何在构建不同类型的产品（如汽车）时重用相同的对象构造代码，并为它们创建相应的手册。</p>
<div align="center"> <img src="/images/builder-example-en.png"/>The example of step-by-step construction of cars and the user guides that fit those car models.</br>汽车的分步构造示例以及适合这些汽车型号的用户指南。</div>

<p>A car is a complex object that can be constructed in a hundred different ways. Instead of bloating the <code>Car</code> class with a huge constructor, we extracted the car assembly code into a separate car builder class. This class has a set of methods for configuring various parts of a car.<br>汽车是一个复杂的物体，可以用一百种不同的方式建造。我们没有使用庞大的构造函数来膨胀类 <code>Car</code> ，而是将汽车装配代码提取到一个单独的 car builder 类中。此类具有一组用于配置汽车各个部分的方法。</p>
<p>If the client code needs to assemble a special, fine-tuned model of a car, it can work with the builder directly. On the other hand, the client can delegate the assembly to the director class, which knows how to use a builder to construct several of the most popular models of cars.<br>如果客户端代码需要组装一个特殊的、微调的汽车模型，它可以直接与构建器一起使用。另一方面，客户端可以将程序集委托给 director 类，该类知道如何使用构建器来构造几种最流行的汽车模型。</p>
<p>You might be shocked, but every car needs a manual (seriously, who reads them?). The manual describes every feature of the car, so the details in the manuals vary across the different models. That’s why it makes sense to reuse an existing construction process for both real cars and their respective manuals. Of course, building a manual isn’t the same as building a car, and that’s why we must provide another builder class that specializes in composing manuals. This class implements the same building methods as its car-building sibling, but instead of crafting car parts, it describes them. By passing these builders to the same director object, we can construct either a car or a manual.<br>您可能会感到震惊，但每辆车都需要一本手册（说真的，谁会读它们？手册描述了汽车的每个功能，因此手册中的细节因不同车型而异。这就是为什么在真实汽车及其各自的手册中重复使用现有的制造过程是有意义的。当然，构建手册与构建汽车不同，这就是为什么我们必须提供另一个专门编写手册的构建者类。该类实现了与其汽车制造同级相同的构建方法，但不是制作汽车零件，而是描述它们。通过将这些构建器传递给同一个 director 对象，我们可以构造汽车或手册。</p>
<p>The final part is fetching the resulting object. A metal car and a paper manual, although related, are still very different things. We can’t place a method for fetching results in the director without coupling the director to concrete product classes. Hence, we obtain the result of the construction from the builder which performed the job.<br>最后一部分是获取生成的对象。金属汽车和纸质手册虽然相关，但仍然是非常不同的东西。如果不将控制器与具体的产品类耦合，我们就无法在控制器中放置获取结果的方法。因此，我们从执行工作的建筑商那里获得施工结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using the Builder pattern makes sense only when your products</span></span><br><span class="line"><span class="comment">// are quite complex and require extensive configuration. The</span></span><br><span class="line"><span class="comment">// following two products are related, although they don&#x27;t have</span></span><br><span class="line"><span class="comment">// a common interface.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> is</span><br><span class="line">    <span class="comment">// A car can have a GPS, trip computer and some number of</span></span><br><span class="line">    <span class="comment">// seats. Different models of cars (sports car, SUV,</span></span><br><span class="line">    <span class="comment">// cabriolet) might have different features installed or</span></span><br><span class="line">    <span class="comment">// enabled.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manual</span> is</span><br><span class="line">    <span class="comment">// Each car should have a user manual that corresponds to</span></span><br><span class="line">    <span class="comment">// the car&#x27;s configuration and describes all its features.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The builder interface specifies methods for creating the</span></span><br><span class="line"><span class="comment">// different parts of the product objects.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Builder</span> is</span><br><span class="line">    method <span class="title function_">reset</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">setSeats</span><span class="params">(...)</span></span><br><span class="line">    method <span class="title function_">setEngine</span><span class="params">(...)</span></span><br><span class="line">    method <span class="title function_">setTripComputer</span><span class="params">(...)</span></span><br><span class="line">    method <span class="title function_">setGPS</span><span class="params">(...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The concrete builder classes follow the builder interface and</span></span><br><span class="line"><span class="comment">// provide specific implementations of the building steps. Your</span></span><br><span class="line"><span class="comment">// program may have several variations of builders, each</span></span><br><span class="line"><span class="comment">// implemented differently.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> is</span><br><span class="line">    <span class="keyword">private</span> field car:Car</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A fresh builder instance should contain a blank product</span></span><br><span class="line">    <span class="comment">// object which it uses in further assembly.</span></span><br><span class="line">    constructor <span class="title function_">CarBuilder</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The reset method clears the object being built.</span></span><br><span class="line">    method <span class="title function_">reset</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.car = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All production steps work with the same product instance.</span></span><br><span class="line">    method <span class="title function_">setSeats</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Set the number of seats in the car.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setEngine</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Install a given engine.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setTripComputer</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Install a trip computer.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setGPS</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Install a global positioning system.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Concrete builders are supposed to provide their own</span></span><br><span class="line">    <span class="comment">// methods for retrieving results. That&#x27;s because various</span></span><br><span class="line">    <span class="comment">// types of builders may create entirely different products</span></span><br><span class="line">    <span class="comment">// that don&#x27;t all follow the same interface. Therefore such</span></span><br><span class="line">    <span class="comment">// methods can&#x27;t be declared in the builder interface (at</span></span><br><span class="line">    <span class="comment">// least not in a statically-typed programming language).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Usually, after returning the end result to the client, a</span></span><br><span class="line">    <span class="comment">// builder instance is expected to be ready to start</span></span><br><span class="line">    <span class="comment">// producing another product. That&#x27;s why it&#x27;s a usual</span></span><br><span class="line">    <span class="comment">// practice to call the reset method at the end of the</span></span><br><span class="line">    <span class="comment">// `getProduct` method body. However, this behavior isn&#x27;t</span></span><br><span class="line">    <span class="comment">// mandatory, and you can make your builder wait for an</span></span><br><span class="line">    <span class="comment">// explicit reset call from the client code before disposing</span></span><br><span class="line">    <span class="comment">// of the previous result.</span></span><br><span class="line">    method <span class="title function_">getProduct</span><span class="params">()</span>:Car <span class="type">is</span></span><br><span class="line">        <span class="variable">product</span> <span class="operator">=</span> <span class="built_in">this</span>.car</span><br><span class="line">        <span class="built_in">this</span>.reset()</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlike other creational patterns, builder lets you construct</span></span><br><span class="line"><span class="comment">// products that don&#x27;t follow the common interface.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarManualBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> is</span><br><span class="line">    <span class="keyword">private</span> field manual:Manual</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">CarManualBuilder</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.reset()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">reset</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.manual = <span class="keyword">new</span> <span class="title class_">Manual</span>()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setSeats</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Document car seat features.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setEngine</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Add engine instructions.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setTripComputer</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Add trip computer instructions.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setGPS</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Add GPS instructions.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getProduct</span><span class="params">()</span>:Manual is</span><br><span class="line">        <span class="comment">// Return the manual and reset the builder.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The director is only responsible for executing the building</span></span><br><span class="line"><span class="comment">// steps in a particular sequence. It&#x27;s helpful when producing</span></span><br><span class="line"><span class="comment">// products according to a specific order or configuration.</span></span><br><span class="line"><span class="comment">// Strictly speaking, the director class is optional, since the</span></span><br><span class="line"><span class="comment">// client can control builders directly.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> is</span><br><span class="line">    <span class="comment">// The director works with any builder instance that the</span></span><br><span class="line">    <span class="comment">// client code passes to it. This way, the client code may</span></span><br><span class="line">    <span class="comment">// alter the final type of the newly assembled product.</span></span><br><span class="line">    <span class="comment">// The director can construct several product variations</span></span><br><span class="line">    <span class="comment">// using the same building steps.</span></span><br><span class="line">    method <span class="title function_">constructSportsCar</span><span class="params">(builder: Builder)</span> is</span><br><span class="line">        builder.reset()</span><br><span class="line">        builder.setSeats(<span class="number">2</span>)</span><br><span class="line">        builder.setEngine(<span class="keyword">new</span> <span class="title class_">SportEngine</span>())</span><br><span class="line">        builder.setTripComputer(<span class="literal">true</span>)</span><br><span class="line">        builder.setGPS(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">constructSUV</span><span class="params">(builder: Builder)</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The client code creates a builder object, passes it to the</span></span><br><span class="line"><span class="comment">// director and then initiates the construction process. The end</span></span><br><span class="line"><span class="comment">// result is retrieved from the builder object.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">makeCar</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>()</span><br><span class="line"></span><br><span class="line">        <span class="type">CarBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarBuilder</span>()</span><br><span class="line">        director.constructSportsCar(builder)</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> builder.getProduct()</span><br><span class="line"></span><br><span class="line">        <span class="type">CarManualBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarManualBuilder</span>()</span><br><span class="line">        director.constructSportsCar(builder)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The final product is often retrieved from a builder</span></span><br><span class="line">        <span class="comment">// object since the director isn&#x27;t aware of and not</span></span><br><span class="line">        <span class="comment">// dependent on concrete builders and products.</span></span><br><span class="line">        <span class="type">Manual</span> <span class="variable">manual</span> <span class="operator">=</span> builder.getProduct()</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Builder pattern to get rid of a “telescoping constructor”. 使用 Builder 模式来摆脱“伸缩构造函数”。</strong></p>
</li>
<li><p>Say you have a constructor with ten optional parameters. Calling such a beast is very inconvenient; therefore, you overload the constructor and create several shorter versions with fewer parameters. These constructors still refer to the main one, passing some default values into any omitted parameters.<br>假设您有一个包含十个可选参数的构造函数。召唤这样的野兽是很不方便的;因此，重载构造函数，并使用较少的参数创建多个较短的版本。这些构造函数仍然引用主构造函数，将一些默认值传递到任何省略的参数中。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    Pizza(<span class="type">int</span> size) &#123; ... &#125;</span><br><span class="line">    Pizza(<span class="type">int</span> size, <span class="type">boolean</span> cheese) &#123; ... &#125;</span><br><span class="line">    Pizza(<span class="type">int</span> size, <span class="type">boolean</span> cheese, <span class="type">boolean</span> pepperoni) &#123; ... &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>Creating such a monster is only possible in languages that support method overloading, such as C# or Java.只有在支持方法重载的语言（如 C# 或 Java）中才能创建这样的怪物。</p>
<p>The Builder pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you don’t have to cram dozens of parameters into your constructors anymore.<br>Builder 模式允许您逐步构建对象，仅使用您真正需要的那些步骤。实现该模式后，您不必再将数十个参数塞入构造函数中。</p>
<ul>
<li><p><strong>Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses).当您希望代码能够创建某些产品（例如，石头和木屋）的不同表示形式时，请使用 Builder 模式。</strong></p>
</li>
<li><p>The Builder pattern can be applied when construction of various representations of the product involves similar steps that differ only in the details.<br>当构建产品的各种表示形式涉及仅在细节上有所不同的类似步骤时，可以应用构建器模式。</p>
</li>
</ul>
<p>The base builder interface defines all possible construction steps, and concrete builders implement these steps to construct particular representations of the product. Meanwhile, the director class guides the order of construction.<br>基础构建器界面定义了所有可能的构建步骤，具体构建器实现这些步骤来构建产品的特定表示。同时，director类指导施工顺序。</p>
<ul>
<li><p><strong>Use the Builder to construct Composite trees or other complex objects.使用构建器构建复合树或其他复杂对象。</strong></p>
</li>
<li><p>The Builder pattern lets you construct products step-by-step. You could defer execution of some steps without breaking the final product. You can even call steps recursively, which comes in handy when you need to build an object tree.<br>Builder 模式允许您逐步构建产品。您可以在不破坏最终产品的情况下延迟某些步骤的执行。您甚至可以递归调用步骤，这在需要构建对象树时会派上用场。</p>
</li>
</ul>
<p>A builder doesn’t expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result.<br>构建器在运行构造步骤时不会暴露未完成的产品。这样可以防止客户端代码提取不完整的结果。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Make sure that you can clearly define the common construction steps for building all available product representations. Otherwise, you won’t be able to proceed with implementing the pattern.<br>确保您可以清楚地定义用于构建所有可用产品表示的常见构造步骤。否则，您将无法继续实现该模式。</p>
</li>
<li><p>Declare these steps in the base builder interface.<br>在基础构建器界面中声明这些步骤。</p>
</li>
<li><p>Create a concrete builder class for each of the product representations and implement their construction steps.<br>为每个产品表示形式创建一个具体的构建器类，并实现其构造步骤。</p>
</li>
</ol>
<p>Don’t forget about implementing a method for fetching the result of the construction. The reason why this method can’t be declared inside the builder interface is that various builders may construct products that don’t have a common interface. Therefore, you don’t know what would be the return type for such a method. However, if you’re dealing with products from a single hierarchy, the fetching method can be safely added to the base interface.<br>不要忘记实现一个获取构造结果的方法。无法在生成器接口中声明此方法的原因是，各种生成器可能会构造没有通用接口的产品。因此，您不知道这种方法的返回类型是什么。但是，如果您要处理来自单个层次结构的产品，则可以安全地将提取方法添加到基本界面。</p>
<ol start="4">
<li><p>Think about creating a director class. It may encapsulate various ways to construct a product using the same builder object.<br>考虑创建一个director类。它可以封装使用相同的构建器对象构建产品的各种方法。</p>
</li>
<li><p>The client code creates both the builder and the director objects. Before construction starts, the client must pass a builder object to the director. Usually, the client does this only once, via parameters of the director’s class constructor. The director uses the builder object in all further construction. There’s an alternative approach, where the builder is passed to a specific product construction method of the director.<br>客户端代码创建生成器和控制器对象。在构造开始之前，客户端必须将生成器对象传递给控制器。通常，客户端仅通过 director 类构造函数的参数执行此操作一次。director 在所有进一步的构造中使用 builder 对象。还有另一种方法，将构建器传递给主管的特定产品构建方法。</p>
</li>
<li><p>The construction result can be obtained directly from the director only if all products follow the same interface. Otherwise, the client should fetch the result from the builder.<br>只有当所有产品都遵循相同的接口时，才能直接从director那里获得施工结果。否则，客户端应从构建器获取结果。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><h3 id="Pros-优点"><a href="#Pros-优点" class="headerlink" title="Pros 优点"></a>Pros 优点</h3><ul>
<li><p>You can construct objects step-by-step, defer construction steps or run steps recursively.<br>您可以逐步构造对象、延迟构造步骤或递归运行步骤。</p>
</li>
<li><p>You can reuse the same construction code when building various representations of products.<br>在构建产品的各种表示形式时，您可以重复使用相同的构造代码。</p>
</li>
<li><p>Single Responsibility Principle. You can isolate complex construction code from the business logic of the product.<br>单一责任原则。您可以将复杂的构造代码与产品的业务逻辑隔离开来。</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>The overall complexity of the code increases since the pattern requires creating multiple new classes.<br>代码的整体复杂性增加，因为该模式需要创建多个新类。</li>
</ul>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Many designs start by using **Factory Method **(less complicated and more customizable via subclasses) and evolve toward <strong>Abstract Factory</strong>, <strong>Prototype</strong>, or <strong>Builder</strong> (more flexible, but more complicated).<br>许多设计从使用工厂方法（不那么复杂，通过子类更可定制）开始，然后发展到抽象工厂、原型或构建器（更灵活，但更复杂）。</p>
</li>
<li><p><strong>Builder</strong> focuses on constructing complex objects step by step. <strong>Abstract Factory</strong> specializes in creating families of related objects. <strong>Abstract Factory</strong> returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.<br>Builder 专注于逐步构建复杂的对象。Abstract Factory专门用于创建相关对象的族。Abstract Factory 会立即返回产品，而 Builder 允许您在获取产品之前运行一些额外的构造步骤。</p>
</li>
<li><p>You can use <strong>Builder</strong> when creating complex <strong>Composite</strong> trees because you can program its construction steps to work recursively.<br>在创建复杂的复合树时，可以使用 Builder，因为您可以对其构造步骤进行编程以递归方式工作。</p>
</li>
<li><p>You can combine <strong>Builder</strong> with <strong>Bridge</strong>: the director class plays the role of the abstraction, while different builders act as implementations.<br>您可以将 Builder 与 Bridge 结合使用：director 类扮演抽象的角色，而不同的构建器充当实现。</p>
</li>
<li><p><strong>Abstract Factories</strong>, <strong>Builders</strong> and <strong>Prototypes</strong> can all be implemented as <strong>Singletons</strong>.<br>抽象工厂、构建器和原型都可以作为单例实现。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="python-Conceptual-Example-概念示例"><a href="#python-Conceptual-Example-概念示例" class="headerlink" title="python Conceptual Example 概念示例"></a>python Conceptual Example 概念示例</h3><p>This example illustrates the structure of the Builder design pattern. It focuses on answering these questions:<br>此示例说明了 Builder 设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些课程扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式的元素以何种方式相关？</li>
</ul>
<p>main.py: 概念示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Builder interface specifies methods for creating the different parts of</span></span><br><span class="line"><span class="string">    the Product objects.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">product</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_a</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_b</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_c</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder1</span>(<span class="title class_ inherited__">Builder</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Concrete Builder classes follow the Builder interface and provide</span></span><br><span class="line"><span class="string">    specific implementations of the building steps. Your program may have</span></span><br><span class="line"><span class="string">    several variations of Builders, implemented differently.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        A fresh builder instance should contain a blank product object, which is</span></span><br><span class="line"><span class="string">        used in further assembly.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._product = Product1()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">product</span>(<span class="params">self</span>) -&gt; Product1:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Concrete Builders are supposed to provide their own methods for</span></span><br><span class="line"><span class="string">        retrieving results. That&#x27;s because various types of builders may create</span></span><br><span class="line"><span class="string">        entirely different products that don&#x27;t follow the same interface.</span></span><br><span class="line"><span class="string">        Therefore, such methods cannot be declared in the base Builder interface</span></span><br><span class="line"><span class="string">        (at least in a statically typed programming language).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Usually, after returning the end result to the client, a builder</span></span><br><span class="line"><span class="string">        instance is expected to be ready to start producing another product.</span></span><br><span class="line"><span class="string">        That&#x27;s why it&#x27;s a usual practice to call the reset method at the end of</span></span><br><span class="line"><span class="string">        the `getProduct` method body. However, this behavior is not mandatory,</span></span><br><span class="line"><span class="string">        and you can make your builders wait for an explicit reset call from the</span></span><br><span class="line"><span class="string">        client code before disposing of the previous result.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        product = self._product</span><br><span class="line">        self.reset()</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_a</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._product.add(<span class="string">&quot;PartA1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_b</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._product.add(<span class="string">&quot;PartB1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_c</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._product.add(<span class="string">&quot;PartC1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product1</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    It makes sense to use the Builder pattern only when your products are quite</span></span><br><span class="line"><span class="string">    complex and require extensive configuration.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Unlike in other creational patterns, different concrete builders can produce</span></span><br><span class="line"><span class="string">    unrelated products. In other words, results of various builders may not</span></span><br><span class="line"><span class="string">    always follow the same interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.parts = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, part: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.parts.append(part)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list_parts</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Product parts: <span class="subst">&#123;<span class="string">&#x27;, &#x27;</span>.join(self.parts)&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Director is only responsible for executing the building steps in a</span></span><br><span class="line"><span class="string">    particular sequence. It is helpful when producing products according to a</span></span><br><span class="line"><span class="string">    specific order or configuration. Strictly speaking, the Director class is</span></span><br><span class="line"><span class="string">    optional, since the client can control builders directly.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._builder = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">builder</span>(<span class="params">self</span>) -&gt; Builder:</span><br><span class="line">        <span class="keyword">return</span> self._builder</span><br><span class="line"></span><br><span class="line"><span class="meta">    @builder.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">builder</span>(<span class="params">self, builder: Builder</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Director works with any builder instance that the client code passes</span></span><br><span class="line"><span class="string">        to it. This way, the client code may alter the final type of the newly</span></span><br><span class="line"><span class="string">        assembled product.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._builder = builder</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Director can construct several product variations using the same</span></span><br><span class="line"><span class="string">    building steps.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_minimal_viable_product</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.builder.produce_part_a()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_full_featured_product</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.builder.produce_part_a()</span><br><span class="line">        self.builder.produce_part_b()</span><br><span class="line">        self.builder.produce_part_c()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code creates a builder object, passes it to the director and then</span></span><br><span class="line"><span class="string">    initiates the construction process. The end result is retrieved from the</span></span><br><span class="line"><span class="string">    builder object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    director = Director()</span><br><span class="line">    builder = ConcreteBuilder1()</span><br><span class="line">    director.builder = builder</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Standard basic product: &quot;</span>)</span><br><span class="line">    director.build_minimal_viable_product()</span><br><span class="line">    builder.product.list_parts()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Standard full featured product: &quot;</span>)</span><br><span class="line">    director.build_full_featured_product()</span><br><span class="line">    builder.product.list_parts()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Remember, the Builder pattern can be used without a Director class.</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Custom product: &quot;</span>)</span><br><span class="line">    builder.produce_part_a()</span><br><span class="line">    builder.produce_part_b()</span><br><span class="line">    builder.product.list_parts()</span><br></pre></td></tr></table></figure>

<h3 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Standard basic product:</span><br><span class="line">Product parts: PartA1</span><br><span class="line"></span><br><span class="line">Standard full featured product:</span><br><span class="line">Product parts: PartA1, PartB1, PartC1</span><br><span class="line"></span><br><span class="line">Custom product:</span><br><span class="line">Product parts: PartA1, PartB1</span><br></pre></td></tr></table></figure>

<h3 id="Rust-示例：Car-car-manual-builders"><a href="#Rust-示例：Car-car-manual-builders" class="headerlink" title="Rust 示例：Car &amp; car manual builders"></a>Rust 示例：Car &amp; car manual builders</h3><p>This slightly synthetic example illustrates how you can use the <code>Builder</code> pattern to construct totally different products using the same building process. For example, the trait Builder declares steps for assembling a car. However, depending on the builder implementation, a constructed object can be something different, for example, a car manual. The resulting manual will contain instructions from each building step, making it accurate and up-to-date.<br>这个略微合成的示例说明了如何使用 Builder 模式，通过相同的构建过程来构建完全不同的产品。例如，该特征 <code>Builder</code> 声明了组装汽车的步骤。但是，根据构建器实现的不同，构造的对象可以是不同的对象，例如汽车手册。由此产生的手册将包含每个构建步骤的说明，使其准确和最新。</p>
<p>The <strong>Builder</strong> design pattern is not the same as the <strong>Fluent Interface</strong> idiom (that relies on method chaining), although Rust developers sometimes use those terms interchangeably.<br>Builder 设计模式与 Fluent Interface 习惯用语（依赖于方法链）不同，尽管 Rust 开发人员有时会互换使用这些术语。</p>
<ol>
<li><p>Fluent Interface is a way to chain methods for constructing or modifying an object using the following approach:<br>Fluent Interface 是一种使用以下方法链接用于构造或修改对象的方法的方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">car</span> = Car::<span class="title function_ invoke__">default</span>().<span class="title function_ invoke__">places</span>(<span class="number">5</span>).<span class="title function_ invoke__">gas</span>(<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>It’s pretty elegant way to construct an object. Still, such a code may not be an instance of the Builder pattern.<br>这是构造对象的非常优雅的方式。不过，这样的代码可能不是 Builder 模式的实例。</p>
</li>
<li><p>While the <strong>Builder</strong> pattern also suggests constructing object step by step, it also lets you build different types of products using the same construction process.<br>虽然 <strong>Builder</strong> 模式还建议逐步构建对象，但它也允许您使用相同的构建过程构建不同类型的产品。</p>
</li>
</ol>
<h3 id="builders-Builders-builders"><a href="#builders-Builders-builders" class="headerlink" title="builders: Builders builders"></a>builders: Builders builders</h3><h4 id="builders-mod-rs"><a href="#builders-mod-rs" class="headerlink" title="builders&#x2F;mod.rs"></a>builders&#x2F;mod.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> car;</span><br><span class="line"><span class="keyword">mod</span> car_manual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Builder defines how to assemble a car.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">OutputType</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_car_type</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, car_type: CarType);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_seats</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, seats: <span class="type">u16</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_engine</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, engine: Engine);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_transmission</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, transmission: Transmission);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_gsp_navigator</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, gps_navigator: GpsNavigator);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::OutputType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> car::CarBuilder;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> car_manual::CarManualBuilder;</span><br></pre></td></tr></table></figure>
<h4 id="builders-car-rs"><a href="#builders-car-rs" class="headerlink" title="builders&#x2F;car.rs"></a>builders&#x2F;car.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    cars::Car,</span><br><span class="line">    components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::Builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DEFAULT_FUEL: <span class="type">f64</span> = <span class="number">5f64</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line">    car_type: <span class="type">Option</span>&lt;CarType&gt;,</span><br><span class="line">    engine: <span class="type">Option</span>&lt;Engine&gt;,</span><br><span class="line">    gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">    seats: <span class="type">Option</span>&lt;<span class="type">u16</span>&gt;,</span><br><span class="line">    transmission: <span class="type">Option</span>&lt;Transmission&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Builder</span> <span class="keyword">for</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">OutputType</span> = Car;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_car_type</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, car_type: CarType) &#123;</span><br><span class="line">        <span class="keyword">self</span>.car_type = <span class="title function_ invoke__">Some</span>(car_type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_engine</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, engine: Engine) &#123;</span><br><span class="line">        <span class="keyword">self</span>.engine = <span class="title function_ invoke__">Some</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_gsp_navigator</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, gps_navigator: GpsNavigator) &#123;</span><br><span class="line">        <span class="keyword">self</span>.gps_navigator = <span class="title function_ invoke__">Some</span>(gps_navigator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_seats</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, seats: <span class="type">u16</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.seats = <span class="title function_ invoke__">Some</span>(seats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_transmission</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, transmission: Transmission) &#123;</span><br><span class="line">        <span class="keyword">self</span>.transmission = <span class="title function_ invoke__">Some</span>(transmission);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Car &#123;</span><br><span class="line">        Car::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            <span class="keyword">self</span>.car_type.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set a car type&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.seats.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set a number of seats&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.engine.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set an engine configuration&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.transmission.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set up transmission&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.gps_navigator,</span><br><span class="line">            DEFAULT_FUEL,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="builders-car-manual-rs"><a href="#builders-car-manual-rs" class="headerlink" title="builders&#x2F;car_manual.rs"></a>builders&#x2F;car_manual.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    cars::Manual,</span><br><span class="line">    components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::Builder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CarManualBuilder</span> &#123;</span><br><span class="line">    car_type: <span class="type">Option</span>&lt;CarType&gt;,</span><br><span class="line">    engine: <span class="type">Option</span>&lt;Engine&gt;,</span><br><span class="line">    gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">    seats: <span class="type">Option</span>&lt;<span class="type">u16</span>&gt;,</span><br><span class="line">    transmission: <span class="type">Option</span>&lt;Transmission&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Builds a car manual instead of an actual car.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Builder</span> <span class="keyword">for</span> <span class="title class_">CarManualBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">OutputType</span> = Manual;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_car_type</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, car_type: CarType) &#123;</span><br><span class="line">        <span class="keyword">self</span>.car_type = <span class="title function_ invoke__">Some</span>(car_type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_engine</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, engine: Engine) &#123;</span><br><span class="line">        <span class="keyword">self</span>.engine = <span class="title function_ invoke__">Some</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_gsp_navigator</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, gps_navigator: GpsNavigator) &#123;</span><br><span class="line">        <span class="keyword">self</span>.gps_navigator = <span class="title function_ invoke__">Some</span>(gps_navigator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_seats</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, seats: <span class="type">u16</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.seats = <span class="title function_ invoke__">Some</span>(seats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_transmission</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, transmission: Transmission) &#123;</span><br><span class="line">        <span class="keyword">self</span>.transmission = <span class="title function_ invoke__">Some</span>(transmission);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Manual &#123;</span><br><span class="line">        Manual::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            <span class="keyword">self</span>.car_type.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set a car type&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.seats.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set a number of seats&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.engine.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set an engine configuration&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.transmission.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set up transmission&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.gps_navigator,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cars-Products"><a href="#cars-Products" class="headerlink" title="cars: Products"></a>cars: Products</h4><h5 id="cars-mod-rs"><a href="#cars-mod-rs" class="headerlink" title="cars&#x2F;mod.rs"></a>cars&#x2F;mod.rs</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> car;</span><br><span class="line"><span class="keyword">mod</span> manual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> car::Car;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> manual::Manual;</span><br></pre></td></tr></table></figure>

<h5 id="cars-car-rs"><a href="#cars-car-rs" class="headerlink" title="cars&#x2F;car.rs"></a>cars&#x2F;car.rs</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    car_type: CarType,</span><br><span class="line">    seats: <span class="type">u16</span>,</span><br><span class="line">    engine: Engine,</span><br><span class="line">    transmission: Transmission,</span><br><span class="line">    gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">    fuel: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">        car_type: CarType,</span><br><span class="line">        seats: <span class="type">u16</span>,</span><br><span class="line">        engine: Engine,</span><br><span class="line">        transmission: Transmission,</span><br><span class="line">        gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">        fuel: <span class="type">f64</span>,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            car_type,</span><br><span class="line">            seats,</span><br><span class="line">            engine,</span><br><span class="line">            transmission,</span><br><span class="line">            gps_navigator,</span><br><span class="line">            fuel,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">car_type</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> CarType &#123;</span><br><span class="line">        <span class="keyword">self</span>.car_type</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fuel</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.fuel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_fuel</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, fuel: <span class="type">f64</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fuel = fuel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">seats</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u16</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.seats</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">engine</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;Engine &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.engine</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">transmission</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;Transmission &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.transmission</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">gps_navigator</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">Option</span>&lt;GpsNavigator&gt; &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.gps_navigator</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="cars-manual-rs"><a href="#cars-manual-rs" class="headerlink" title="cars&#x2F;manual.rs"></a>cars&#x2F;manual.rs</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Manual</span> &#123;</span><br><span class="line">    car_type: CarType,</span><br><span class="line">    seats: <span class="type">u16</span>,</span><br><span class="line">    engine: Engine,</span><br><span class="line">    transmission: Transmission,</span><br><span class="line">    gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Manual</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">        car_type: CarType,</span><br><span class="line">        seats: <span class="type">u16</span>,</span><br><span class="line">        engine: Engine,</span><br><span class="line">        transmission: Transmission,</span><br><span class="line">        gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            car_type,</span><br><span class="line">            seats,</span><br><span class="line">            engine,</span><br><span class="line">            transmission,</span><br><span class="line">            gps_navigator,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> <span class="title class_">Manual</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">&quot;Type of car: &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.car_type)?;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">&quot;Count of seats: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.seats)?;</span><br><span class="line">        <span class="built_in">writeln!</span>(</span><br><span class="line">            f,</span><br><span class="line">            <span class="string">&quot;Engine: volume - &#123;&#125;; mileage - &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.engine.<span class="title function_ invoke__">volume</span>(),</span><br><span class="line">            <span class="keyword">self</span>.engine.<span class="title function_ invoke__">mileage</span>()</span><br><span class="line">        )?;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">&quot;Transmission: &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.transmission)?;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.gps_navigator &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(_) =&gt; <span class="built_in">writeln!</span>(f, <span class="string">&quot;GPS Navigator: Functional&quot;</span>)?,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="built_in">writeln!</span>(f, <span class="string">&quot;GPS Navigator: N/A&quot;</span>)?,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="components-rs-Product-components"><a href="#components-rs-Product-components" class="headerlink" title="components.rs: Product components"></a>components.rs: Product components</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">CarType</span> &#123;</span><br><span class="line">    CityCar,</span><br><span class="line">    SportsCar,</span><br><span class="line">    Suv,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Transmission</span> &#123;</span><br><span class="line">    SingleSpeed,</span><br><span class="line">    Manual,</span><br><span class="line">    Automatic,</span><br><span class="line">    SemiAutomatic,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    volume: <span class="type">f64</span>,</span><br><span class="line">    mileage: <span class="type">f64</span>,</span><br><span class="line">    started: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(volume: <span class="type">f64</span>, mileage: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            volume,</span><br><span class="line">            mileage,</span><br><span class="line">            started: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">on</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.started = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">off</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.started = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">started</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.started</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">volume</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.volume</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mileage</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.mileage</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">go</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, mileage: <span class="type">f64</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">started</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.mileage += mileage;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Cannot go(), you must start engine first!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GpsNavigator</span> &#123;</span><br><span class="line">    route: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GpsNavigator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">from_route</span>(</span><br><span class="line">            <span class="string">&quot;221b, Baker Street, London  to Scotland Yard, 8-10 Broadway, London&quot;</span>.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_route</span>(route: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; route &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">route</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.route</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="director-rs-Directors"><a href="#director-rs-Directors" class="headerlink" title="director.rs: Directors"></a>director.rs: Directors</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    builders::Builder,</span><br><span class="line">    components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Director knows how to build a car.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// However, a builder can build a car manual instead of an actual car,</span></span><br><span class="line"><span class="comment">/// everything depends on the concrete builder.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Director</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">construct_sports_car</span>(builder: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> <span class="title class_">Builder</span>) &#123;</span><br><span class="line">        builder.<span class="title function_ invoke__">set_car_type</span>(CarType::SportsCar);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_seats</span>(<span class="number">2</span>);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_engine</span>(Engine::<span class="title function_ invoke__">new</span>(<span class="number">3.0</span>, <span class="number">0.0</span>));</span><br><span class="line">        builder.<span class="title function_ invoke__">set_transmission</span>(Transmission::SemiAutomatic);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_gsp_navigator</span>(GpsNavigator::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">construct_city_car</span>(builder: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> <span class="title class_">Builder</span>) &#123;</span><br><span class="line">        builder.<span class="title function_ invoke__">set_car_type</span>(CarType::CityCar);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_seats</span>(<span class="number">2</span>);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_engine</span>(Engine::<span class="title function_ invoke__">new</span>(<span class="number">1.2</span>, <span class="number">0.0</span>));</span><br><span class="line">        builder.<span class="title function_ invoke__">set_transmission</span>(Transmission::Automatic);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_gsp_navigator</span>(GpsNavigator::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">construct_suv</span>(builder: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> <span class="title class_">Builder</span>) &#123;</span><br><span class="line">        builder.<span class="title function_ invoke__">set_car_type</span>(CarType::Suv);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_seats</span>(<span class="number">4</span>);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_engine</span>(Engine::<span class="title function_ invoke__">new</span>(<span class="number">2.5</span>, <span class="number">0.0</span>));</span><br><span class="line">        builder.<span class="title function_ invoke__">set_transmission</span>(Transmission::Manual);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_gsp_navigator</span>(GpsNavigator::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main-rs-Client-code"><a href="#main-rs-Client-code" class="headerlink" title="main.rs: Client code"></a>main.rs: Client code</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> builders;</span><br><span class="line"><span class="keyword">mod</span> cars;</span><br><span class="line"><span class="keyword">mod</span> components;</span><br><span class="line"><span class="keyword">mod</span> director;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> builders::&#123;Builder, CarBuilder, CarManualBuilder&#125;;</span><br><span class="line"><span class="keyword">use</span> cars::&#123;Car, Manual&#125;;</span><br><span class="line"><span class="keyword">use</span> director::Director;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">car_builder</span> = CarBuilder::<span class="title function_ invoke__">default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Director gets the concrete builder object from the client</span></span><br><span class="line">    <span class="comment">// (application code). That&#x27;s because application knows better which</span></span><br><span class="line">    <span class="comment">// builder to use to get a specific product.</span></span><br><span class="line">    Director::<span class="title function_ invoke__">construct_sports_car</span>(&amp;<span class="keyword">mut</span> car_builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The final product is often retrieved from a builder object, since</span></span><br><span class="line">    <span class="comment">// Director is not aware and not dependent on concrete builders and</span></span><br><span class="line">    <span class="comment">// products.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">car</span>: Car = car_builder.<span class="title function_ invoke__">build</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Car built: &#123;:?&#125;\n&quot;</span>, car.<span class="title function_ invoke__">car_type</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">manual_builder</span> = CarManualBuilder::<span class="title function_ invoke__">default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Director may know several building recipes.</span></span><br><span class="line">    Director::<span class="title function_ invoke__">construct_city_car</span>(&amp;<span class="keyword">mut</span> manual_builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The final car manual.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">manual</span>: Manual = manual_builder.<span class="title function_ invoke__">build</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Car manual built:\n&#123;&#125;&quot;</span>, manual);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Car built: SportsCar</span><br><span class="line"></span><br><span class="line">Car manual built:</span><br><span class="line">Type of car: CityCar</span><br><span class="line">Count of seats: 2</span><br><span class="line">Engine: volume - 1.2; mileage - 0</span><br><span class="line">Transmission: Automatic</span><br><span class="line">GPS Navigator: Functional</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Bridge</title>
    <url>/2023/12/06/design-pattern/bridge/</url>
    <content><![CDATA[<h1 id="Bridge-桥接模式"><a href="#Bridge-桥接模式" class="headerlink" title="Bridge 桥接模式"></a>Bridge 桥接模式</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Bridge</strong> is a structural design pattern that lets you split a large class or a set of closely related classes into two separate hierarchies—abstraction and implementation—which can be developed independently of each other.<br><strong>Bridge</strong>是一种结构设计模式，它允许您将一个大型类或一组密切相关的类拆分为两个单独的层次结构（抽象和实现），这两个层次结构可以相互独立开发。</p>
<div align="center"> <img src="/images/bridge-header.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Abstraction? Implementation? Sound scary? Stay calm and let’s consider a simple example.<br>抽象化？实现？听起来很吓人？保持冷静，让我们考虑一个简单的例子。</p>
<p>Say you have a geometric <code>Shape</code> class with a pair of subclasses: <code>Circle</code> and <code>Square</code>. You want to extend this class hierarchy to incorporate colors, so you plan to create <code>Red</code> and <code>Blue</code> shape subclasses. However, since you already have two subclasses, you’ll need to create four class combinations such as <code>BlueCircle</code> and <code>RedSquare</code>.<br>假设您有一个几何类，其中包含一对子 <code>Shape</code> 类： <code>Circle</code> 和 <code>Square</code> 。您希望扩展此类层次结构以合并颜色，因此您计划创建 <code>Red</code> 和 <code>Blue</code> 调整子类。但是，由于您已经有两个子类，因此需要创建四个类组合，例如 <code>BlueCircle</code> 和 <code>RedSquare</code> 。</p>
<div align="center"> <img src="/images/bridge-problem-en.png"/>Number of class combinations grows in geometric progression.</br>类组合的数量以几何级数增长。</div>
Adding new shape types and colors to the hierarchy will grow it exponentially. For example, to add a triangle shape you’d need to introduce two subclasses, one for each color. And after that, adding a new color would require creating three subclasses, one for each shape type. The further we go, the worse it becomes.
向层次结构添加新的形状类型和颜色将使其呈指数级增长。例如，要添加三角形形状，您需要引入两个子类，每个子类对应一种颜色。之后，添加新颜色将需要创建三个子类，每个子类对应一个形状类型。我们走得越远，情况就越糟。

<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>This problem occurs because we’re trying to extend the shape classes in two independent dimensions: by form and by color. That’s a very common issue with class inheritance.<br>出现此问题的原因是，我们尝试在两个独立的维度中扩展形状类：按形状和按颜色。这是类继承的一个非常常见的问题。</p>
<p>The Bridge pattern attempts to solve this problem by switching from inheritance to the object composition. What this means is that you extract one of the dimensions into a separate class hierarchy, so that the original classes will reference an object of the new hierarchy, instead of having all of its state and behaviors within one class.<br>Bridge 模式试图通过从继承切换到对象组合来解决此问题。这意味着将其中一个维度提取到单独的类层次结构中，以便原始类将引用新层次结构的对象，而不是将其所有状态和行为都放在一个类中。</p>
<div align="center"> <img src="/images/bridge-solution-en.png"/>You can prevent the explosion of a class hierarchy by transforming it into several related hierarchies.</br>可以通过将类层次结构转换为多个相关的层次结构来防止类层次结构的爆炸式增长。</div>
Following this approach, we can extract the color-related code into its own class with two subclasses: `Red` and `Blue`. The `Shape` class then gets a reference field pointing to one of the color objects. Now the shape can delegate any color-related work to the linked color object. That reference will act as a bridge between the `Shape` and `Color` classes. From now on, adding new colors won’t require changing the shape hierarchy, and vice versa.
按照这种方法，我们可以将与颜色相关的代码提取到它自己的类中，其中包含两个子类： `Red` 和 `Blue` .然后，该 `Shape` 类获取指向其中一个颜色对象的引用字段。现在，形状可以将任何与颜色相关的工作委托给链接的颜色对象。该引用将充当 `Shape` 和 `Color` 类之间的桥梁。从现在开始，添加新颜色将不需要更改形状层次结构，反之亦然。

<h3 id="Abstraction-and-Implementation-抽象和实现"><a href="#Abstraction-and-Implementation-抽象和实现" class="headerlink" title="Abstraction and Implementation 抽象和实现"></a>Abstraction and Implementation 抽象和实现</h3><p>The <a href="https://refactoring.guru/gof-book" title="“Gang of Four” is a nickname given to the four authors of the original book about design patterns: Design Patterns: Elements of Reusable Object-Oriented Software 设计模式：可重用面向对象软件的元素">GoF book</a>  introduces the terms Abstraction and Implementation as part of the Bridge definition. In my opinion, the terms sound too academic and make the pattern seem more complicated than it really is. Having read the simple example with shapes and colors, let’s decipher the meaning behind the GoF book’s scary words.<br>GoF一书引入了术语“抽象”和“实现”，作为桥接定义的一部分。在我看来，这些术语听起来太学术化了，使模式看起来比实际情况更复杂。在阅读了带有形状和颜色的简单示例之后，让我们破译 GoF 书的可怕单词背后的含义。</p>
<p>Abstraction (also called interface) is a high-level control layer for some entity. This layer isn’t supposed to do any real work on its own. It should delegate the work to the implementation layer (also called platform).<br>抽象（也称为接口）是某些实体的高级控制层。这个层不应该自己做任何真正的工作。它应该将工作委托给实现层（也称为平台）。</p>
<p>Note that we’re not talking about interfaces or abstract classes from your programming language. These aren’t the same things.<br>请注意，我们不是在谈论编程语言中的接口或抽象类。这些不是一回事。</p>
<p>When talking about real applications, the abstraction can be represented by a graphical user interface (GUI), and the implementation could be the underlying operating system code (API) which the GUI layer calls in response to user interactions.<br>在谈论实际应用程序时，抽象可以由图形用户界面 （GUI） 表示，实现可以是 GUI 层为响应用户交互而调用的底层操作系统代码 （API）。</p>
<p>Generally speaking, you can extend such an app in two independent directions:<br>一般来说，您可以在两个独立的方向上扩展此类应用程序：</p>
<ul>
<li>Have several different GUIs (for instance, tailored for regular customers or admins).<br>有几个不同的 GUI（例如，为普通客户或管理员量身定制）。</li>
<li>Support several different APIs (for example, to be able to launch the app under Harmony, Windows, Linux, and macOS).<br>支持多个不同的 API（例如，能够在 Harmony, Windows、Linux 和 macOS 下启动应用程序）。</li>
</ul>
<p>In a worst-case scenario, this app might look like a giant spaghetti bowl, where hundreds of conditionals connect different types of GUI with various APIs all over the code.<br>在最坏的情况下，这个应用程序可能看起来像一个巨大的意大利面碗，其中数百个条件将不同类型的 GUI 与代码中的各种 API 连接起来。</p>
<div align="center"> <img src="/images/bridge-bridge-3-en.png"/>Making even a simple change to a monolithic codebase is pretty hard because you must understand the entire thing very well. Making changes to smaller, well-defined modules is much easier.</br>即使是对单体代码库进行简单的更改也非常困难，因为您必须很好地理解整个事情。对更小、定义明确的模块进行更改要容易得多。</div>
You can bring order to this chaos by extracting the code related to specific interface-platform combinations into separate classes. However, soon you’ll discover that there are lots of these classes. The class hierarchy will grow exponentially because adding a new GUI or supporting a different API would require creating more and more classes.
您可以通过将与特定接口平台组合相关的代码提取到单独的类中来恢复这种混乱。但是，很快您就会发现有很多这样的课程。类层次结构将呈指数级增长，因为添加新的 GUI 或支持不同的 API 需要创建越来越多的类。

<p>Let’s try to solve this issue with the Bridge pattern. It suggests that we divide the classes into two hierarchies:<br>让我们尝试使用 Bridge 模式来解决这个问题。它建议我们将类分为两个层次结构：</p>
<ul>
<li>Abstraction: the GUI layer of the app.<br>抽象：应用的 GUI 层。</li>
<li>Implementation: the operating systems’ APIs.<br>实现：操作系统的 API。<div align="center"> <img src="/images/bridge-bridge-2-en.png"/>One of the ways to structure a cross-platform application.</br>构建跨平台应用程序的方法之一。</div>
The abstraction object controls the appearance of the app, delegating the actual work to the linked implementation object. Different implementations are interchangeable as long as they follow a common interface, enabling the same GUI to work under Harmony, Windows and Linux.
抽象对象控制应用的外观，将实际工作委托给链接的实现对象。不同的实现是可以互换的，只要它们遵循一个通用的接口，使相同的 GUI 能够在Harmony, Windows 和 Linux 下工作。</li>
</ul>
<p>As a result, you can change the GUI classes without touching the API-related classes. Moreover, adding support for another operating system only requires creating a subclass in the implementation hierarchy.<br>因此，您可以在不接触 API 相关类的情况下更改 GUI 类。此外，添加对另一个操作系统的支持只需要在实现层次结构中创建一个子类。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/bridge-structure-en.png"/></div>

<ol>
<li><p>The <strong>Abstraction</strong> provides high-level control logic. It relies on the implementation object to do the actual low-level work.<br>抽象提供高级控制逻辑。它依赖于实现对象来执行实际的低级工作。</p>
</li>
<li><p>The <strong>Implementation</strong> declares the interface that’s common for all concrete implementations. An abstraction can only communicate with an implementation object via methods that are declared here.<br>实现声明了所有具体实现通用的接口。抽象只能通过此处声明的方法与实现对象进行通信。</p>
</li>
<li><p><strong>Concrete Implementations</strong> contain platform-specific code.<br>具体实现包含特定于平台的代码。</p>
</li>
<li><p><strong>Refined Abstractions</strong> provide variants of control logic. Like their parent, they work with different implementations via the general implementation interface.<br>精炼的抽象提供了控制逻辑的变体。与它们的父级一样，它们通过通用实现接口使用不同的实现。</p>
</li>
<li><p>Usually, the <strong>Client</strong> is only interested in working with the abstraction. However, it’s the client’s job to link the abstraction object with one of the implementation objects.<br>通常，客户端只对处理抽象感兴趣。但是，客户端的工作是将抽象对象与其中一个实现对象链接起来。</p>
</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example illustrates how the <strong>Bridge</strong> pattern can help divide the monolithic code of an app that manages devices and their remote controls. The <code>Device</code> classes act as the implementation, whereas the <code>Remote</code>s act as the abstraction.<br>此示例演示了 Bridge 模式如何帮助划分管理设备及其遥控器的应用的整体代码。 <code>Device</code> 类充当实现，而 <code>Remote</code>s 充当抽象。</p>
<div align="center"> <img src="/images/bridge-example-en.png"/>The original class hierarchy is divided into two parts: devices and remote controls.</br>原始的类层次结构分为两部分：设备和遥控器。</div>
The base remote control class declares a reference field that links it with a device object. All remotes work with the devices via the general device interface, which lets the same remote support multiple device types.
基远程控制类声明一个引用字段，该字段将其与设备对象链接。所有遥控器都通过通用设备接口与设备配合使用，这使得同一个遥控器支持多种设备类型。

<p>You can develop the remote control classes independently from the device classes. All that’s needed is to create a new remote subclass. For example, a basic remote control might only have two buttons, but you could extend it with additional features, such as an extra battery or a touchscreen.<br>您可以独立于设备类开发远程控制类。所需要的只是创建一个新的远程子类。例如，一个基本的遥控器可能只有两个按钮，但您可以使用其他功能（例如额外的电池或触摸屏）对其进行扩展。</p>
<p>The client code links the desired type of remote control with a specific device object via the remote’s constructor.<br>客户端代码通过遥控器的构造函数将所需类型的遥控器与特定设备对象链接起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The &quot;abstraction&quot; defines the interface for the &quot;control&quot;</span></span><br><span class="line"><span class="comment">// part of the two class hierarchies. It maintains a reference</span></span><br><span class="line"><span class="comment">// to an object of the &quot;implementation&quot; hierarchy and delegates</span></span><br><span class="line"><span class="comment">// all of the real work to this object.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span> is</span><br><span class="line">    <span class="keyword">protected</span> field device: Device</span><br><span class="line">    constructor <span class="title function_">RemoteControl</span><span class="params">(device: Device)</span> is</span><br><span class="line">        <span class="built_in">this</span>.device = device</span><br><span class="line">    method <span class="title function_">togglePower</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(device.isEnabled()</span>) then</span><br><span class="line">            device.disable()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            device.enable()</span><br><span class="line">    method <span class="title function_">volumeDown</span><span class="params">()</span> is</span><br><span class="line">        device.setVolume(device.getVolume() - <span class="number">10</span>)</span><br><span class="line">    method <span class="title function_">volumeUp</span><span class="params">()</span> is</span><br><span class="line">        device.setVolume(device.getVolume() + <span class="number">10</span>)</span><br><span class="line">    method <span class="title function_">channelDown</span><span class="params">()</span> is</span><br><span class="line">        device.setChannel(device.getChannel() - <span class="number">1</span>)</span><br><span class="line">    method <span class="title function_">channelUp</span><span class="params">()</span> is</span><br><span class="line">        device.setChannel(device.getChannel() + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can extend classes from the abstraction hierarchy</span></span><br><span class="line"><span class="comment">// independently from device classes.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedRemoteControl</span> <span class="keyword">extends</span> <span class="title class_">RemoteControl</span> is</span><br><span class="line">    method <span class="title function_">mute</span><span class="params">()</span> is</span><br><span class="line">        device.setVolume(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The &quot;implementation&quot; interface declares methods common to all</span></span><br><span class="line"><span class="comment">// concrete implementation classes. It doesn&#x27;t have to match the</span></span><br><span class="line"><span class="comment">// abstraction&#x27;s interface. In fact, the two interfaces can be</span></span><br><span class="line"><span class="comment">// entirely different. Typically the implementation interface</span></span><br><span class="line"><span class="comment">// provides only primitive operations, while the abstraction</span></span><br><span class="line"><span class="comment">// defines higher-level operations based on those primitives.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Device</span> is</span><br><span class="line">    method <span class="title function_">isEnabled</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">enable</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">disable</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">getVolume</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">setVolume</span><span class="params">(percent)</span></span><br><span class="line">    method <span class="title function_">getChannel</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">setChannel</span><span class="params">(channel)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// All devices follow the same interface.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span> <span class="keyword">implements</span> <span class="title class_">Device</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Radio</span> <span class="keyword">implements</span> <span class="title class_">Device</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Somewhere in client code.</span></span><br><span class="line">tv = <span class="keyword">new</span> <span class="title class_">Tv</span>()</span><br><span class="line">remote = <span class="keyword">new</span> <span class="title class_">RemoteControl</span>(tv)</span><br><span class="line">remote.togglePower()</span><br><span class="line"></span><br><span class="line">radio = <span class="keyword">new</span> <span class="title class_">Radio</span>()</span><br><span class="line">remote = <span class="keyword">new</span> <span class="title class_">AdvancedRemoteControl</span>(radio)</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Bridge pattern when you want to divide and organize a monolithic class that has several variants of some functionality (for example, if the class can work with various database servers).如果要划分和组织具有某些功能的多个变体的整体类（例如，如果该类可以与各种数据库服务器一起使用），请使用 Bridge 模式。</strong></p>
</li>
<li><p>The bigger a class becomes, the harder it is to figure out how it works, and the longer it takes to make a change. The changes made to one of the variations of functionality may require making changes across the whole class, which often results in making errors or not addressing some critical side effects.<br>一个班级变得越大，就越难弄清楚它是如何工作的，做出改变所需的时间就越长。对功能变体之一所做的更改可能需要在整个类中进行更改，这通常会导致出错或无法解决一些关键的副作用。</p>
</li>
</ul>
<p>The Bridge pattern lets you split the monolithic class into several class hierarchies. After this, you can change the classes in each hierarchy independently of the classes in the others. This approach simplifies code maintenance and minimizes the risk of breaking existing code.<br>Bridge 模式允许您将整体类拆分为多个类层次结构。在此之后，您可以独立于其他层次结构中的类更改每个层次结构中的类。此方法简化了代码维护，并最大限度地降低了破坏现有代码的风险。</p>
<ul>
<li><p><strong>Use the pattern when you need to extend a class in several orthogonal (independent) dimensions. 当您需要在多个正交（独立）维度中扩展类时，请使用该模式。</strong></p>
</li>
<li><p>The Bridge suggests that you extract a separate class hierarchy for each of the dimensions. The original class delegates the related work to the objects belonging to those hierarchies instead of doing everything on its own.<br>Bridge 建议您为每个维度提取单独的类层次结构。原始类将相关工作委托给属于这些层次结构的对象，而不是自己执行所有操作。</p>
</li>
</ul>
<p> Use the Bridge if you need to be able to switch implementations at runtime.<br>如果您需要能够在运行时切换实现，请使用 Bridge。</p>
<p> Although it’s optional, the Bridge pattern lets you replace the implementation object inside the abstraction. It’s as easy as assigning a new value to a field.<br>尽管它是可选的，但 Bridge 模式允许您替换抽象中的实现对象。这就像为字段分配新值一样简单。</p>
<p>By the way, this last item is the main reason why so many people confuse the Bridge with the Strategy pattern. Remember that a pattern is more than just a certain way to structure your classes. It may also communicate intent and a problem being addressed.<br>顺便说一句，最后一项是这么多人将桥接模式与策略模式混淆的主要原因。请记住，模式不仅仅是构建类的某种方式。它还可以传达意图和正在解决的问题。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Identify the orthogonal dimensions in your classes. These independent concepts could be: abstraction&#x2F;platform, domain&#x2F;infrastructure, front-end&#x2F;back-end, or interface&#x2F;implementation.<br>确定类中的正交维度。这些独立的概念可以是：抽象&#x2F;平台、域&#x2F;基础结构、前端&#x2F;后端或接口&#x2F;实现。</p>
</li>
<li><p>See what operations the client needs and define them in the base abstraction class.<br>查看客户端需要哪些操作，并在基抽象类中定义它们。</p>
</li>
<li><p>Determine the operations available on all platforms. Declare the ones that the abstraction needs in the general implementation interface.<br>确定所有平台上可用的操作。在通用实现接口中声明抽象需要的那些。</p>
</li>
<li><p>For all platforms in your domain create concrete implementation classes, but make sure they all follow the implementation interface.<br>对于域中的所有平台，请创建具体的实现类，但请确保它们都遵循实现接口。</p>
</li>
<li><p>Inside the abstraction class, add a reference field for the implementation type. The abstraction delegates most of the work to the implementation object that’s referenced in that field.<br>在抽象类中，为实现类型添加一个引用字段。抽象将大部分工作委托给该字段中引用的实现对象。</p>
</li>
<li><p>If you have several variants of high-level logic, create refined abstractions for each variant by extending the base abstraction class.<br>如果有多个高级逻辑变体，请通过扩展基本抽象类为每个变体创建精细的抽象。</p>
</li>
<li><p>The client code should pass an implementation object to the abstraction’s constructor to associate one with the other. After that, the client can forget about the implementation and work only with the abstraction object.<br>客户端代码应将实现对象传递给抽象的构造函数，以将一个对象与另一个对象相关联。之后，客户端可以忘记实现，只使用抽象对象。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>Pros 优点</th>
<th>Cons 缺点</th>
</tr>
</thead>
<tbody><tr>
<td>You can create platform-independent classes and apps.您可以创建与平台无关的类和应用。</td>
<td>You might make the code more complicated by applying the pattern to a highly cohesive class. 通过将模式应用于高度内聚的类，可以使代码更加复杂。</td>
</tr>
<tr>
<td>The client code works with high-level abstractions. It isn’t exposed to the platform details. 客户端代码使用高级抽象。它不会公开给平台详细信息。</td>
<td></td>
</tr>
<tr>
<td>Open&#x2F;Closed Principle. You can introduce new abstractions and implementations independently from each other. 开&#x2F;闭原理。您可以引入新的抽象和实现，彼此独立。</td>
<td></td>
</tr>
<tr>
<td>Single Responsibility Principle. You can focus on high-level logic in the abstraction and on platform details in the implementation. 单一责任原则。您可以专注于抽象中的高级逻辑和实现中的平台细节。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p><strong>Bridge</strong> is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, <strong>Adapter</strong> is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.<br><strong>Bridge</strong> 通常是预先设计的，允许您彼此独立地开发应用程序的各个部分。另一方面，<strong>Adapter</strong> 通常与现有应用程序一起使用，以使一些不兼容的类很好地协同工作。</p>
</li>
<li><p><strong>Bridge, State, Strategy</strong> (and to some degree <strong>Adapter</strong>) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.<br>桥接、状态、策略（在某种程度上还有适配器）具有非常相似的结构。事实上，所有这些模式都是基于构图的，而构图是将工作委托给其他对象。但是，它们都解决了不同的问题。模式不仅仅是以特定方式构建代码的秘诀。它还可以向其他开发人员传达该模式解决的问题。</p>
</li>
<li><p>You can use <strong>Abstract Factory</strong> along with <strong>Bridge</strong>. This pairing is useful when some abstractions defined by <strong>Bridge</strong> can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.</p>
</li>
<li><p>You can combine <strong>Builder</strong> with <strong>Bridge</strong>: the director class plays the role of the abstraction, while different builders act as implementations.<br>您可以将 <strong>Builder</strong> 与 <strong>Bridge</strong> 结合使用：director 类扮演抽象的角色，而不同的构建器充当实现。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="Python-Conceptual-Example-概念示例"><a href="#Python-Conceptual-Example-概念示例" class="headerlink" title="Python Conceptual Example 概念示例"></a>Python Conceptual Example 概念示例</h3><p>This example illustrates the structure of the Bridge design pattern. It focuses on answering these questions:<br>此示例说明了 Bridge 设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些课程扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式的元素以何种方式相关？</li>
</ul>
<h4 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstraction</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Abstraction defines the interface for the &quot;control&quot; part of the two</span></span><br><span class="line"><span class="string">    class hierarchies. It maintains a reference to an object of the</span></span><br><span class="line"><span class="string">    Implementation hierarchy and delegates all of the real work to this object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, implementation: Implementation</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.implementation = implementation</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f&quot;Abstraction: Base operation with:\n&quot;</span></span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;self.implementation.operation_implementation()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendedAbstraction</span>(<span class="title class_ inherited__">Abstraction</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    You can extend the Abstraction without changing the Implementation classes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f&quot;ExtendedAbstraction: Extended operation with:\n&quot;</span></span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;self.implementation.operation_implementation()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implementation</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Implementation defines the interface for all implementation classes. It</span></span><br><span class="line"><span class="string">    doesn&#x27;t have to match the Abstraction&#x27;s interface. In fact, the two</span></span><br><span class="line"><span class="string">    interfaces can be entirely different. Typically the Implementation interface</span></span><br><span class="line"><span class="string">    provides only primitive operations, while the Abstraction defines higher-</span></span><br><span class="line"><span class="string">    level operations based on those primitives.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation_implementation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Each Concrete Implementation corresponds to a specific platform and implements</span></span><br><span class="line"><span class="string">the Implementation interface using that platform&#x27;s API.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementationA</span>(<span class="title class_ inherited__">Implementation</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation_implementation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConcreteImplementationA: Here&#x27;s the result on the platform A.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementationB</span>(<span class="title class_ inherited__">Implementation</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation_implementation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConcreteImplementationB: Here&#x27;s the result on the platform B.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">abstraction: Abstraction</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Except for the initialization phase, where an Abstraction object gets linked</span></span><br><span class="line"><span class="string">    with a specific Implementation object, the client code should only depend on</span></span><br><span class="line"><span class="string">    the Abstraction class. This way the client code can support any abstraction-</span></span><br><span class="line"><span class="string">    implementation combination.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(abstraction.operation(), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code should be able to work with any pre-configured abstraction-</span></span><br><span class="line"><span class="string">    implementation combination.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    implementation = ConcreteImplementationA()</span><br><span class="line">    abstraction = Abstraction(implementation)</span><br><span class="line">    client_code(abstraction)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    implementation = ConcreteImplementationB()</span><br><span class="line">    abstraction = ExtendedAbstraction(implementation)</span><br><span class="line">    client_code(abstraction)</span><br></pre></td></tr></table></figure>

<h4 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Abstraction: Base operation with:</span><br><span class="line">ConcreteImplementationA: Here&#x27;s the result on the platform A.</span><br><span class="line"></span><br><span class="line">ExtendedAbstraction: Extended operation with:</span><br><span class="line">ConcreteImplementationB: Here&#x27;s the result on the platform B.</span><br></pre></td></tr></table></figure>

<h3 id="Rust-Conceptual-Example-概念示例"><a href="#Rust-Conceptual-Example-概念示例" class="headerlink" title="Rust Conceptual Example 概念示例"></a>Rust Conceptual Example 概念示例</h3><h4 id="Devices-and-Remotes-设备和遥控器"><a href="#Devices-and-Remotes-设备和遥控器" class="headerlink" title="Devices and Remotes 设备和遥控器"></a>Devices and Remotes 设备和遥控器</h4><p>This example illustrates how the Bridge pattern can help divide the monolithic code of an app that manages devices and their remote controls. The Device classes act as the implementation, whereas the Remotes act as the abstraction.<br>此示例演示了 Bridge 模式如何帮助划分管理设备及其遥控器的应用的整体代码。Device 类充当实现，而 Remote 充当抽象。</p>
<h4 id="remotes-mod-rs"><a href="#remotes-mod-rs" class="headerlink" title="remotes&#x2F;mod.rs"></a>remotes&#x2F;mod.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> advanced;</span><br><span class="line"><span class="keyword">mod</span> basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> advanced::AdvancedRemove;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> basic::BasicRemote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::device::Device;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">HasMutableDevice</span>&lt;D: Device&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">device</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Remote</span>&lt;D: Device&gt;: HasMutableDevice&lt;D&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">power</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Remote: power toggle&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">is_enabled</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">disable</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">enable</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">volume_down</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Remote: volume down&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">volume</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">volume</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">set_volume</span>(volume - <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">volume_up</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Remote: volume up&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">volume</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">volume</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">set_volume</span>(volume + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">channel_down</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Remote: channel down&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">channel</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">set_channel</span>(channel - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">channel_up</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Remote: channel up&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">channel</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">set_channel</span>(channel + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="remotes-basic-rs"><a href="#remotes-basic-rs" class="headerlink" title="remotes&#x2F;basic.rs"></a>remotes&#x2F;basic.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::device::Device;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::&#123;HasMutableDevice, Remote&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">BasicRemote</span>&lt;D: Device&gt; &#123;</span><br><span class="line">    device: D,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;D: Device&gt; BasicRemote&lt;D&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(device: D) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; device &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;D: Device&gt; HasMutableDevice&lt;D&gt; <span class="keyword">for</span> <span class="title class_">BasicRemote</span>&lt;D&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">device</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> D &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.device</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;D: Device&gt; Remote&lt;D&gt; <span class="keyword">for</span> <span class="title class_">BasicRemote</span>&lt;D&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remotes-advanced-rs"><a href="#remotes-advanced-rs" class="headerlink" title="remotes&#x2F;advanced.rs"></a>remotes&#x2F;advanced.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::device::Device;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::&#123;HasMutableDevice, Remote&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AdvancedRemote</span>&lt;D: Device&gt; &#123;</span><br><span class="line">    device: D,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;D: Device&gt; AdvancedRemote&lt;D&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(device: D) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; device &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mute</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Remote: mute&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.device.<span class="title function_ invoke__">set_volume</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;D: Device&gt; HasMutableDevice&lt;D&gt; <span class="keyword">for</span> <span class="title class_">AdvancedRemote</span>&lt;D&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">device</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> D &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.device</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;D: Device&gt; Remote&lt;D&gt; <span class="keyword">for</span> <span class="title class_">AdvancedRemote</span>&lt;D&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="device-mod-rs"><a href="#device-mod-rs" class="headerlink" title="device&#x2F;mod.rs"></a>device&#x2F;mod.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> radio;</span><br><span class="line"><span class="keyword">mod</span> tv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> radio::Radio;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> tv::Tv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Device</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_enabled</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">enable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">disable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">volume</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_volume</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, percent: <span class="type">u8</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">channel</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u16</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_channel</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, channel: <span class="type">u16</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_status</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="device-radio-rs"><a href="#device-radio-rs" class="headerlink" title="device&#x2F;radio.rs"></a>device&#x2F;radio.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Device;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Radio</span> &#123;</span><br><span class="line">    on: <span class="type">bool</span>,</span><br><span class="line">    volume: <span class="type">u8</span>,</span><br><span class="line">    channel: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Default</span> <span class="keyword">for</span> <span class="title class_">Radio</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            on: <span class="literal">false</span>,</span><br><span class="line">            volume: <span class="number">30</span>,</span><br><span class="line">            channel: <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Device</span> <span class="keyword">for</span> <span class="title class_">Radio</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_enabled</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">enable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.on = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">disable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.on = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">volume</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.volume</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_volume</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, percent: <span class="type">u8</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.volume = std::cmp::<span class="title function_ invoke__">min</span>(percent, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">channel</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u16</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.channel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_channel</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, channel: <span class="type">u16</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_status</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| I&#x27;m radio.&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| I&#x27;m &#123;&#125;&quot;</span>, <span class="keyword">if</span> <span class="keyword">self</span>.on &#123; <span class="string">&quot;enabled&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;disabled&quot;</span> &#125;);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| Current volume is &#123;&#125;%&quot;</span>, <span class="keyword">self</span>.volume);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| Current channel is &#123;&#125;&quot;</span>, <span class="keyword">self</span>.channel);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;------------------------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="device-tv-rs"><a href="#device-tv-rs" class="headerlink" title="device&#x2F;tv.rs"></a>device&#x2F;tv.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Device;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tv</span> &#123;</span><br><span class="line">    on: <span class="type">bool</span>,</span><br><span class="line">    volume: <span class="type">u8</span>,</span><br><span class="line">    channel: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Default</span> <span class="keyword">for</span> <span class="title class_">Tv</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            on: <span class="literal">false</span>,</span><br><span class="line">            volume: <span class="number">30</span>,</span><br><span class="line">            channel: <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Device</span> <span class="keyword">for</span> <span class="title class_">Tv</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_enabled</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">enable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.on = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">disable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.on = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">volume</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.volume</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_volume</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, percent: <span class="type">u8</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.volume = std::cmp::<span class="title function_ invoke__">min</span>(percent, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">channel</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u16</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.channel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_channel</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, channel: <span class="type">u16</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_status</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| I&#x27;m TV set.&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| I&#x27;m &#123;&#125;&quot;</span>, <span class="keyword">if</span> <span class="keyword">self</span>.on &#123; <span class="string">&quot;enabled&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;disabled&quot;</span> &#125;);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| Current volume is &#123;&#125;%&quot;</span>, <span class="keyword">self</span>.volume);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| Current channel is &#123;&#125;&quot;</span>, <span class="keyword">self</span>.channel);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;------------------------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a>main.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> device;</span><br><span class="line"><span class="keyword">mod</span> remotes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> device::&#123;Device, Radio, Tv&#125;;</span><br><span class="line"><span class="keyword">use</span> remotes::&#123;AdvancedRemove, BasicRemote, HasMutableDevice, Remote&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">test_device</span>(Tv::<span class="title function_ invoke__">default</span>());</span><br><span class="line">    <span class="title function_ invoke__">test_device</span>(Radio::<span class="title function_ invoke__">default</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_device</span>(device: <span class="keyword">impl</span> <span class="title class_">Device</span> + <span class="built_in">Clone</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Tests with basic remote.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">basic_remote</span> = BasicRemote::<span class="title function_ invoke__">new</span>(device.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    basic_remote.<span class="title function_ invoke__">power</span>();</span><br><span class="line">    basic_remote.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">print_status</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Tests with advanced remote.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">advanced_remote</span> = AdvancedRemove::<span class="title function_ invoke__">new</span>(device);</span><br><span class="line">    advanced_remote.<span class="title function_ invoke__">power</span>();</span><br><span class="line">    advanced_remote.<span class="title function_ invoke__">mute</span>();</span><br><span class="line">    advanced_remote.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">print_status</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tests with basic remote.</span><br><span class="line">Remote: power toggle</span><br><span class="line">------------------------------------</span><br><span class="line">| I&#x27;m TV set.</span><br><span class="line">| I&#x27;m enabled</span><br><span class="line">| Current volume is 30%</span><br><span class="line">| Current channel is 1</span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line">Tests with advanced remote.</span><br><span class="line">Remote: power toggle</span><br><span class="line">Remote: mute</span><br><span class="line">------------------------------------</span><br><span class="line">| I&#x27;m TV set.</span><br><span class="line">| I&#x27;m enabled</span><br><span class="line">| Current volume is 0%</span><br><span class="line">| Current channel is 1</span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line">Tests with basic remote.</span><br><span class="line">Remote: power toggle</span><br><span class="line">------------------------------------</span><br><span class="line">| I&#x27;m radio.</span><br><span class="line">| I&#x27;m enabled</span><br><span class="line">| Current volume is 30%</span><br><span class="line">| Current channel is 1</span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line">Tests with advanced remote.</span><br><span class="line">Remote: power toggle</span><br><span class="line">Remote: mute</span><br><span class="line">------------------------------------</span><br><span class="line">| I&#x27;m radio.</span><br><span class="line">| I&#x27;m enabled</span><br><span class="line">| Current volume is 0%</span><br><span class="line">| Current channel is 1</span><br><span class="line">------------------------------------</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Chain of Responsibility 责任链</title>
    <url>/2024/02/03/design-pattern/chain-of-responsibility/</url>
    <content><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>Chain of Responsibility是一种行为设计模式，它允许您沿着处理程序链沿着传递请求。在接收到请求时，每个处理程序决定是处理请求还是将其传递给链中的下一个处理程序。</p>
<div align="center"> <img src="/images/chain-of-responsibility-header.png"/></div>


<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假设你正在开发一个在线订购系统。您希望限制对系统的访问，以便只有经过身份验证的用户才能创建订单。此外，具有管理权限的用户必须对所有订单具有完全访问权限。</p>
<p>经过一段时间的规划后，您意识到这些检查必须按顺序执行。每当应用程序收到包含用户凭据的请求时，它都可以尝试向系统验证用户的身份。但是，如果这些凭据不正确并且身份验证失败，则没有理由继续进行任何其他检查。</p>
<div align="center"> <img src="/images/responsibilty-problem1.png"/>请求必须通过一系列检查，然后订购系统才能处理它。</div>


<p>在接下来的几个月里，您又实现了几个这样的顺序检查。</p>
<ul>
<li>您的一位同事建议将原始数据直接传递到订购系统是不安全的。因此，您添加了一个额外的验证步骤来清理请求中的数据。</li>
<li>后来，有人注意到，该系统是脆弱的暴力破解密码。为了消除这种情况，您立即添加了一个检查，该检查过滤来自同一IP地址的重复失败请求。</li>
<li>还有人建议，可以通过返回包含相同数据的重复请求的缓存结果来加快系统速度。因此，您添加了另一个检查，仅当没有合适的缓存响应时，才允许请求通过系统。</li>
</ul>
<div align="center"> <img src="/images/responsibility-problem2.png"/>代码越庞杂，就越混乱。</div>


<p>检查的代码本来看起来就很混乱，随着您添加每个新特性，它变得越来越臃肿。更改一张支票有时会影响其他支票。最糟糕的是，当您试图重用检查来保护系统的其他组件时，您不得不复制一些代码，因为这些组件需要一些检查，但不是所有检查。</p>
<p>这个系统变得很难理解，维护起来也很昂贵。你在代码上挣扎了一段时间，直到有一天你决定重构整个代码。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>与许多其他行为设计模式一样，责任链依赖于将特定行为转换为称为处理程序的独立对象。在我们的例子中，每个检查都应该被提取到它自己的类中，并使用一个执行检查的方法。请求沿着数据作为参数传递给此方法。</p>
<p>该模式建议您将这些处理程序链接成一个链。每个链接的处理程序都有一个字段，用于存储对链中下一个处理程序的引用。除了处理请求之外，处理程序还将请求进一步沿着链传递。请求沿着链传递，直到所有处理程序都有机会处理它。</p>
<p>这里是最好的部分：处理程序可以决定不将请求进一步向下传递，并有效地停止任何进一步的处理。</p>
<p>在我们的订单系统示例中，处理程序执行处理，然后决定是否将请求进一步向下传递。假设请求包含正确的数据，所有处理程序都可以执行其主要行为，无论是身份验证检查还是缓存。</p>
<div align="center"> <img src="/images/responsibility-solution1-en.png"/>把手一个接一个地排列，形成一条链条。</div>


<p>然而，还有一种稍微不同的方法（它更规范一点），在这种方法中，在接收到请求时，处理程序决定它是否可以处理它。如果可以，它就不再传递请求。因此，要么只有一个处理程序处理请求，要么根本没有处理程序。这种方法在处理图形用户界面中的元素堆栈中的事件时非常常见。</p>
<p>例如，当用户单击按钮时，事件将通过GUI元素链传播，该元素链从按钮开始，沿着其容器（如窗体或面板）传播，最后到达主应用程序窗口。事件由链中能够处理它的第一个元素处理。这个例子也值得注意，因为它表明链总是可以从对象树中提取。</p>
<div align="center"> <img src="/images/responsibility-solution2.png"/>链可以由对象树的分支形成。</div>


<p>所有的处理程序类实现相同的接口是至关重要的。每个具体的处理程序应该只关心下面的一个具有 所有的处理程序类实现相同的接口是至关重要的。每个具体的处理程序应该只关心下面的一个具有 <code>execute</code> 方法的处理程序。通过这种方式，您可以在运行时使用各种处理程序组合链，而无需将代码耦合到它们的具体类。 方法的处理程序。通过这种方式，您可以在运行时使用各种处理程序组合链，而无需将代码耦合到它们的具体类。</p>
<h2 id="现实世界的类比"><a href="#现实世界的类比" class="headerlink" title="现实世界的类比"></a>现实世界的类比</h2><div align="center"> <img src="/images/chain-of-responsibility-comic-1-en.png"/>打电话给技术支持可以通过多个运营商。</div>


<p>您刚刚购买并在计算机上安装了一个新硬件。因为你是个电脑迷，所以这台电脑安装了几个操作系统。您尝试靴子所有这些设备，以查看硬件是否受支持。Windows自动检测并启用硬件。然而，您心爱的Linux拒绝与新硬件一起工作。带着一丝希望，你决定拨打盒子上写的技术支持电话号码。</p>
<p>你听到的第一件事是自动应答器的机器人声音。它为各种问题提出了九种流行的解决方案，其中没有一种与您的情况相关。一段时间后，机器人将您连接到现场操作员。</p>
<p>唉，运营商也无法提供任何具体的建议。他不断地从手册中引用冗长的摘录，拒绝听你的评论。在听到“你试过把电脑关掉再打开吗？”我说了十遍了，你需要找个合适的工程师。</p>
<p>最后，接线员会把你的电话转给其中一位工程师，他坐在某栋办公楼黑暗的地下室里，孤独的服务器室里，可能已经渴望了好几个小时的真人聊天。工程师告诉你在哪里为你的新硬件下载合适的驱动程序，以及如何在Linux上安装它们。最后，解决方案！你结束了通话，满心欢喜。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><div align="center"> <img src="/images/responsibility-structure.png"/></div>


<ol>
<li><p>该函数声明了接口，对所有具体处理程序都是通用的。它通常只包含一个处理请求的方法，但有时它也可能有另一个方法来设置链上的下一个处理程序。</p>
</li>
<li><p>BaseHandler是一个可选类，您可以在其中放置所有处理程序类通用的样板代码。</p>
<p>通常，这个类定义一个字段来存储对下一个处理程序的引用。客户端可以通过将处理程序传递给前一个处理程序的构造函数或setter来构建链。类也可以实现默认的处理行为：它可以在检查其存在之后将执行传递给下一个处理程序。</p>
</li>
<li><p>具体处理程序包含处理请求的实际代码。在接收到一个请求后，每个处理程序必须决定是否处理它，另外，是否沿着链沿着它。</p>
<p>处理程序通常是自包含的和不可变的，通过构造函数只接受一次所有必要的数据。</p>
</li>
<li><p>客户端可以只组合一次链，也可以动态组合它们，这取决于应用程序的逻辑。请注意，请求可以发送到链中的任何处理程序-它不必是第一个。</p>
</li>
</ol>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>在本例中，责任链模式负责显示活动GUI元素的上下文帮助信息。</p>
<div align="center"> <img src="/images/responsibility-example1.png"/>GUI类是用Composite模式构建的。每个元素都链接到它的容器元素。在任何时候，您都可以构建一个元素链，该元素链从元素本身开始，遍历它的所有容器元素。</div>


<p>应用程序的GUI通常被构造为对象树。例如，呈现应用程序主窗口的 <code>Dialog</code> 类将是对象树的根。对话框包含 <code>Panels</code> ，它可能包含其他面板或简单的低级元素，如 <code>Buttons</code> 和 <code>TextFields</code> 。</p>
<p>一个简单的组件可以显示简短的上下文工具提示，只要该组件有一些帮助文本分配。但更复杂的组件定义了自己显示上下文帮助的方式，例如显示手册摘录或在浏览器中打开页面。responsibility-example2</p>
<div align="center"> <img src="/images/responsibility-solution2.png"/>这就是帮助请求遍历GUI对象的方式。</div>


<p>当用户将鼠标光标指向某个元素并按下 当用户将鼠标光标指向某个元素并按下 <code>F1</code> 键时，应用程序将检测指针下的组件并向其发送帮助请求。该请求将在元素的所有容器中冒泡，直到到达能够显示帮助信息的元素。 键时，应用程序将检测指针下的组件并向其发送帮助请求。该请求将在元素的所有容器中冒泡，直到到达能够显示帮助信息的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The handler interface declares a method for executing a</span></span><br><span class="line"><span class="comment">// request.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentWithContextualHelp</span> is</span><br><span class="line">    method <span class="title function_">showHelp</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The base class for simple components.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> <span class="keyword">implements</span> <span class="title class_">ComponentWithContextualHelp</span> is</span><br><span class="line">    field tooltipText: string</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The component&#x27;s container acts as the next link in the</span></span><br><span class="line">    <span class="comment">// chain of handlers.</span></span><br><span class="line">    <span class="keyword">protected</span> field container: Container</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The component shows a tooltip if there&#x27;s help text</span></span><br><span class="line">    <span class="comment">// assigned to it. Otherwise it forwards the call to the</span></span><br><span class="line">    <span class="comment">// container, if it exists.</span></span><br><span class="line">    method <span class="title function_">showHelp</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(tooltipText != <span class="literal">null</span>)</span></span><br><span class="line">            <span class="comment">// Show tooltip.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            container.showHelp()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Containers can contain both simple components and other</span></span><br><span class="line"><span class="comment">// containers as children. The chain relationships are</span></span><br><span class="line"><span class="comment">// established here. The class inherits showHelp behavior from</span></span><br><span class="line"><span class="comment">// its parent.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Container</span> <span class="keyword">extends</span> <span class="title class_">Component</span> is</span><br><span class="line">    <span class="keyword">protected</span> field children: array of Component</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">add</span><span class="params">(child)</span> is</span><br><span class="line">        children.add(child)</span><br><span class="line">        child.container = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Primitive components may be fine with default help</span></span><br><span class="line"><span class="comment">// implementation...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">extends</span> <span class="title class_">Component</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// But complex components may override the default</span></span><br><span class="line"><span class="comment">// implementation. If the help text can&#x27;t be provided in a new</span></span><br><span class="line"><span class="comment">// way, the component can always call the base implementation</span></span><br><span class="line"><span class="comment">// (see Component class).</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Panel</span> <span class="keyword">extends</span> <span class="title class_">Container</span> is</span><br><span class="line">    field modalHelpText: string</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">showHelp</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(modalHelpText != <span class="literal">null</span>)</span></span><br><span class="line">            <span class="comment">// Show a modal window with the help text.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">super</span>.showHelp()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...same as above...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> <span class="keyword">extends</span> <span class="title class_">Container</span> is</span><br><span class="line">    field wikiPageURL: string</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">showHelp</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(wikiPageURL != <span class="literal">null</span>)</span></span><br><span class="line">            <span class="comment">// Open the wiki help page.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">super</span>.showHelp()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Client code.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    <span class="comment">// Every application configures the chain differently.</span></span><br><span class="line">    method <span class="title function_">createUI</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dialog</span>(<span class="string">&quot;Budget Reports&quot;</span>)</span><br><span class="line">        dialog.wikiPageURL = <span class="string">&quot;http://...&quot;</span></span><br><span class="line">        panel = <span class="keyword">new</span> <span class="title class_">Panel</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">800</span>)</span><br><span class="line">        panel.modalHelpText = <span class="string">&quot;This panel does...&quot;</span></span><br><span class="line">        ok = <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="number">250</span>, <span class="number">760</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="string">&quot;OK&quot;</span>)</span><br><span class="line">        ok.tooltipText = <span class="string">&quot;This is an OK button that...&quot;</span></span><br><span class="line">        cancel = <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="number">320</span>, <span class="number">760</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="string">&quot;Cancel&quot;</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        panel.add(ok)</span><br><span class="line">        panel.add(cancel)</span><br><span class="line">        dialog.add(panel)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Imagine what happens here.</span></span><br><span class="line">    method <span class="title function_">onF1KeyPress</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">component</span> <span class="operator">=</span> <span class="built_in">this</span>.getComponentAtMouseCoords()</span><br><span class="line">        component.showHelp()</span><br></pre></td></tr></table></figure>

<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ul>
<li><strong>当你的程序需要以不同的方式处理不同类型的请求，但请求的确切类型和它们的顺序事先是未知的时，请使用责任链模式。</strong></li>
<li>该模式允许您将多个处理程序链接到一个链中，并在收到请求时“询问”每个处理程序是否可以处理该请求。</li>
<li><strong>当必须以特定顺序执行多个处理程序时，请使用该模式。</strong></li>
<li>由于您可以以任何顺序链接链中的处理程序，因此所有请求都将完全按照您的计划通过链。</li>
<li>当处理程序集及其顺序应该在运行时更改时，请使用CoR模式。</li>
<li>如果在处理程序类中为引用字段提供setter，则可以动态地插入、删除或重新排序处理程序。</li>
</ul>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><ol>
<li><p>描述处理程序接口并描述处理请求的方法的签名。</p>
<p>决定客户端如何将请求数据传递到方法中。最灵活的方法是将请求转换为对象，并将其作为参数传递给处理方法。</p>
</li>
<li><p>为了消除具体处理程序中重复的样板代码，可能需要创建一个从处理程序接口派生的抽象基处理程序类。</p>
<p>这个类应该有一个字段来存储对链中下一个处理程序的引用。考虑使类不可变。但是，如果您计划在运行时修改链，则需要定义一个setter来更改引用字段的值。</p>
<p>您还可以为处理方法实现方便的默认行为，即将请求转发到下一个对象，除非没有对象了。具体处理程序将能够通过调用父方法来使用此行为。</p>
</li>
<li><p>逐个创建具体的处理程序子类并实现它们的处理方法。每个处理程序在接收请求时应该做出两个决定：</p>
<ul>
<li>它是否会处理请求。</li>
<li>它是否会沿着链沿着传递请求。</li>
</ul>
</li>
<li><p>客户端可以自行组装链，也可以从其他对象接收预构建的链。在后一种情况下，您必须实现一些工厂类来根据配置或环境设置构建链</p>
</li>
<li><p>客户端可以触发链中的任何处理程序，而不仅仅是第一个。请求将沿着链传递，直到某个处理程序拒绝进一步传递它，或者直到它到达链的末端。</p>
</li>
<li><p>由于链的动态特性，客户端应该准备好处理以下场景：</p>
<ul>
<li>链条可以由单个链环组成。</li>
<li>有些请求可能无法到达链的末端。</li>
<li>其他人可能会到达链条的末端。</li>
</ul>
</li>
</ol>
<h2 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h2><table>
<thead>
<tr>
<th>√ 利</th>
<th>× 弊</th>
</tr>
</thead>
<tbody><tr>
<td>您可以控制请求处理的顺序。</td>
<td>有些请求可能最终无法处理。</td>
</tr>
<tr>
<td>单一责任原则。可以将调用操作的类与执行操作的类解耦。</td>
<td></td>
</tr>
<tr>
<td>开放&#x2F;封闭原则。您可以在应用程序中引入新的处理程序，而不会破坏现有的客户端代码。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li><p>责任链、命令、调解器和观察者解决了连接请求的接收者和接收者的各种方式：</p>
<ul>
<li>责任链（Chain of Responsibility）将请求顺序地沿着一个动态的潜在接收者链传递，直到其中一个接收者处理它。</li>
<li>命令在中继器和接收器之间建立单向连接。</li>
<li>Mediator消除了发送者和接收者之间的直接连接，迫使它们通过Mediator对象间接通信。</li>
<li>观察者允许接收者动态订阅和取消订阅接收请求。</li>
</ul>
</li>
<li><p>责任链通常与复合一起使用。在这种情况下，当一个叶组件收到一个请求时，它可以通过所有父组件的链将其传递到对象树的根。</p>
</li>
<li><p>责任链中的处理程序可以作为命令实现。在这种情况下，您可以对同一个上下文对象（由请求表示）执行许多不同的操作。</p>
<p>然而，还有另一种方法，其中请求本身是一个Command对象。在这种情况下，您可以在链接成链的一系列不同上下文中执行相同的操作。</p>
</li>
<li><p>Chain of Responsibility和Decorator具有非常相似的类结构。这两种模式都依赖于递归组合来通过一系列对象传递执行。然而，有几个关键的区别。</p>
<p>CoR处理程序可以彼此独立地执行任意操作。他们也可以在任何时候停止进一步传递请求。另一方面，各种装饰器可以扩展对象的行为，同时保持它与基接口的一致性。此外，装饰器不允许中断请求流。</p>
</li>
</ul>
<h1 id="Python中的责任链"><a href="#Python中的责任链" class="headerlink" title="Python中的责任链"></a>Python中的责任链</h1><p>责任链是一种行为设计模式，它允许沿着潜在处理程序链传递请求，直到其中一个处理请求。</p>
<p>该模式允许多个对象处理请求，而无需将发送方类耦合到接收方的具体类。链可以在运行时动态地与遵循标准处理程序接口的任何处理程序组合。</p>
<h2 id="概念示例"><a href="#概念示例" class="headerlink" title="概念示例"></a>概念示例</h2><p>这个例子说明了责任链设计模式的结构。它侧重于回答这些问题：</p>
<ul>
<li>它由哪些类组成？</li>
<li>这些班级扮演什么角色？</li>
<li>模式中的元素是以什么方式联系在一起的？</li>
</ul>
<h4 id="main-py：概念性示例"><a href="#main-py：概念性示例" class="headerlink" title="main.py：概念性示例"></a>main.py：概念性示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Handler interface declares a method for building the chain of handlers.</span></span><br><span class="line"><span class="string">    It also declares a method for executing a request.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_next</span>(<span class="params">self, handler: Handler</span>) -&gt; Handler:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self, request</span>) -&gt; <span class="type">Optional</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractHandler</span>(<span class="title class_ inherited__">Handler</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The default chaining behavior can be implemented inside a base handler</span></span><br><span class="line"><span class="string">    class.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _next_handler: Handler = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_next</span>(<span class="params">self, handler: Handler</span>) -&gt; Handler:</span><br><span class="line">        self._next_handler = handler</span><br><span class="line">        <span class="comment"># Returning a handler from here will let us link handlers in a</span></span><br><span class="line">        <span class="comment"># convenient way like this:</span></span><br><span class="line">        <span class="comment"># monkey.set_next(squirrel).set_next(dog)</span></span><br><span class="line">        <span class="keyword">return</span> handler</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self, request: <span class="type">Any</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> self._next_handler:</span><br><span class="line">            <span class="keyword">return</span> self._next_handler.handle(request)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">All Concrete Handlers either handle a request or pass it to the next handler in</span></span><br><span class="line"><span class="string">the chain.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonkeyHandler</span>(<span class="title class_ inherited__">AbstractHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self, request: <span class="type">Any</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> request == <span class="string">&quot;Banana&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;Monkey: I&#x27;ll eat the <span class="subst">&#123;request&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>().handle(request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquirrelHandler</span>(<span class="title class_ inherited__">AbstractHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self, request: <span class="type">Any</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> request == <span class="string">&quot;Nut&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;Squirrel: I&#x27;ll eat the <span class="subst">&#123;request&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>().handle(request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogHandler</span>(<span class="title class_ inherited__">AbstractHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self, request: <span class="type">Any</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> request == <span class="string">&quot;MeatBall&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;Dog: I&#x27;ll eat the <span class="subst">&#123;request&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>().handle(request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">handler: Handler</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code is usually suited to work with a single handler. In most</span></span><br><span class="line"><span class="string">    cases, it is not even aware that the handler is part of a chain.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> food <span class="keyword">in</span> [<span class="string">&quot;Nut&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cup of coffee&quot;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\nClient: Who wants a <span class="subst">&#123;food&#125;</span>?&quot;</span>)</span><br><span class="line">        result = handler.handle(food)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;result&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;food&#125;</span> was left untouched.&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    monkey = MonkeyHandler()</span><br><span class="line">    squirrel = SquirrelHandler()</span><br><span class="line">    dog = DogHandler()</span><br><span class="line"></span><br><span class="line">    monkey.set_next(squirrel).set_next(dog)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The client should be able to send a request to any handler, not just the</span></span><br><span class="line">    <span class="comment"># first one in the chain.</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Chain: Monkey &gt; Squirrel &gt; Dog&quot;</span>)</span><br><span class="line">    client_code(monkey)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Subchain: Squirrel &gt; Dog&quot;</span>)</span><br><span class="line">    client_code(squirrel)</span><br></pre></td></tr></table></figure>

<h4 id="Output-txt：执行结果"><a href="#Output-txt：执行结果" class="headerlink" title="Output.txt：执行结果"></a>Output.txt：执行结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Chain: Monkey &gt; Squirrel &gt; Dog</span><br><span class="line"></span><br><span class="line">Client: Who wants a Nut?</span><br><span class="line">  Squirrel: I&#x27;ll eat the Nut</span><br><span class="line">Client: Who wants a Banana?</span><br><span class="line">  Monkey: I&#x27;ll eat the Banana</span><br><span class="line">Client: Who wants a Cup of coffee?</span><br><span class="line">  Cup of coffee was left untouched.</span><br><span class="line"></span><br><span class="line">Subchain: Squirrel &gt; Dog</span><br><span class="line"></span><br><span class="line">Client: Who wants a Nut?</span><br><span class="line">  Squirrel: I&#x27;ll eat the Nut</span><br><span class="line">Client: Who wants a Banana?</span><br><span class="line">  Banana was left untouched.</span><br><span class="line">Client: Who wants a Cup of coffee?</span><br><span class="line">  Cup of coffee was left untouched.</span><br></pre></td></tr></table></figure>

<h1 id="Rust中的责任链"><a href="#Rust中的责任链" class="headerlink" title="Rust中的责任链"></a>Rust中的责任链</h1><p>责任链是一种行为设计模式，它允许沿着潜在处理程序链传递请求，直到其中一个处理请求。</p>
<p>该模式允许多个对象处理请求，而无需将发送方类耦合到接收方的具体类。链可以在运行时动态地与遵循标准处理程序接口的任何处理程序组合。</p>
<h2 id="概念示例-1"><a href="#概念示例-1" class="headerlink" title="概念示例"></a>概念示例</h2><p>该示例演示了如何通过一系列部门处理患者。责任链的构成如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Patient <span class="punctuation">-&gt;</span> Reception <span class="punctuation">-&gt;</span> Doctor <span class="punctuation">-&gt;</span> Medical <span class="punctuation">-&gt;</span> Cashier</span><br></pre></td></tr></table></figure>

<p>链是使用 链是使用 <code>Box</code> 指针构建的，这意味着在运行时动态分派。为什么？为什么？使用泛型将实现缩小到严格的编译时类型似乎相当困难：为了构造一个完整链的类型，Rust需要完全了解链中的“下一个”链接。因此，它看起来像这样： 指针构建的，这意味着在运行时动态分派。为什么？为什么？使用泛型将实现缩小到严格的编译时类型似乎相当困难：为了构造一个完整链的类型，Rust需要完全了解链中的“下一个”链接。因此，它看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reception</span> = Reception::&lt;Doctor::&lt;Medical::&lt;Cashier&gt;&gt;&gt;::<span class="title function_ invoke__">new</span>(doctor); <span class="comment">// 😱</span></span><br></pre></td></tr></table></figure>

<p>相反， 相反， <code>Box</code> 允许以任何组合进行链接： 允许以任何组合进行链接：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reception</span> = Reception::<span class="title function_ invoke__">new</span>(doctor); <span class="comment">// 👍</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reception</span> = Reception::<span class="title function_ invoke__">new</span>(cashier); <span class="comment">// 🕵️‍♀️</span></span><br></pre></td></tr></table></figure>

<h4 id="patient-rs-Request"><a href="#patient-rs-Request" class="headerlink" title="patient.rs: Request"></a><strong>patient.rs:</strong> Request</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Patient</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> registration_done: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> doctor_check_up_done: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> medicine_done: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> payment_done: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="department-rs-Handlers"><a href="#department-rs-Handlers" class="headerlink" title="department.rs: Handlers"></a><strong>department.rs:</strong> Handlers</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> cashier;</span><br><span class="line"><span class="keyword">mod</span> doctor;</span><br><span class="line"><span class="keyword">mod</span> medical;</span><br><span class="line"><span class="keyword">mod</span> reception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> cashier::Cashier;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> doctor::Doctor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> medical::Medical;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> reception::Reception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::patient::Patient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A single role of objects that make up a chain.</span></span><br><span class="line"><span class="comment">/// A typical trait implementation must have `handle` and `next` methods,</span></span><br><span class="line"><span class="comment">/// while `execute` is implemented by default and contains a proper chaining</span></span><br><span class="line"><span class="comment">/// logic.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">execute</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, patient: &amp;<span class="keyword">mut</span> Patient) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">handle</span>(patient);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next) = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            next.<span class="title function_ invoke__">execute</span>(patient);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">handle</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, patient: &amp;<span class="keyword">mut</span> Patient);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Department&gt;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Helps to wrap an object into a boxed type.</span></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">self</span>) <span class="keyword">fn</span> <span class="title function_">into_next</span>(</span><br><span class="line">    department: <span class="keyword">impl</span> <span class="title class_">Department</span> + <span class="built_in">Sized</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Department&gt;&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(department))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="department-cashier-rs"><a href="#department-cashier-rs" class="headerlink" title="department&#x2F;cashier.rs"></a><strong>department&#x2F;cashier.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::&#123;Department, Patient&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Cashier</span> &#123;</span><br><span class="line">    next: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Department&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Department</span> <span class="keyword">for</span> <span class="title class_">Cashier</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">handle</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, patient: &amp;<span class="keyword">mut</span> Patient) &#123;</span><br><span class="line">        <span class="keyword">if</span> patient.payment_done &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Payment done&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Cashier getting money from a patient &#123;&#125;&quot;</span>, patient.name);</span><br><span class="line">            patient.payment_done = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Department&gt;&gt; &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="department-doctor-rs"><a href="#department-doctor-rs" class="headerlink" title="department&#x2F;doctor.rs"></a><strong>department&#x2F;doctor.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::&#123;into_next, Department, Patient&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Doctor</span> &#123;</span><br><span class="line">    next: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Department&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Doctor</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(next: <span class="keyword">impl</span> <span class="title class_">Department</span> + <span class="symbol">&#x27;static</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            next: <span class="title function_ invoke__">into_next</span>(next),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Department</span> <span class="keyword">for</span> <span class="title class_">Doctor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">handle</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, patient: &amp;<span class="keyword">mut</span> Patient) &#123;</span><br><span class="line">        <span class="keyword">if</span> patient.doctor_check_up_done &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;A doctor checkup is already done&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Doctor checking a patient &#123;&#125;&quot;</span>, patient.name);</span><br><span class="line">            patient.doctor_check_up_done = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Department&gt;&gt; &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="department-medical-rs"><a href="#department-medical-rs" class="headerlink" title="department&#x2F;medical.rs"></a><strong>department&#x2F;medical.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::&#123;into_next, Department, Patient&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Medical</span> &#123;</span><br><span class="line">    next: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Department&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Medical</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(next: <span class="keyword">impl</span> <span class="title class_">Department</span> + <span class="symbol">&#x27;static</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            next: <span class="title function_ invoke__">into_next</span>(next),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Department</span> <span class="keyword">for</span> <span class="title class_">Medical</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">handle</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, patient: &amp;<span class="keyword">mut</span> Patient) &#123;</span><br><span class="line">        <span class="keyword">if</span> patient.medicine_done &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Medicine is already given to a patient&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Medical giving medicine to a patient &#123;&#125;&quot;</span>, patient.name);</span><br><span class="line">            patient.medicine_done = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Department&gt;&gt; &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="department-reception-rs"><a href="#department-reception-rs" class="headerlink" title="department&#x2F;reception.rs"></a><strong>department&#x2F;reception.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::&#123;into_next, Department, Patient&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Reception</span> &#123;</span><br><span class="line">    next: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Department&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Reception</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(next: <span class="keyword">impl</span> <span class="title class_">Department</span> + <span class="symbol">&#x27;static</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            next: <span class="title function_ invoke__">into_next</span>(next),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Department</span> <span class="keyword">for</span> <span class="title class_">Reception</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">handle</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, patient: &amp;<span class="keyword">mut</span> Patient) &#123;</span><br><span class="line">        <span class="keyword">if</span> patient.registration_done &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Patient registration is already done&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Reception registering a patient &#123;&#125;&quot;</span>, patient.name);</span><br><span class="line">            patient.registration_done = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Department&gt;&gt; &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-rs-Client"><a href="#main-rs-Client" class="headerlink" title="main.rs: Client"></a><strong>main.rs:</strong> Client</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> department;</span><br><span class="line"><span class="keyword">mod</span> patient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> department::&#123;Cashier, Department, Doctor, Medical, Reception&#125;;</span><br><span class="line"><span class="keyword">use</span> patient::Patient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cashier</span> = Cashier::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">medical</span> = Medical::<span class="title function_ invoke__">new</span>(cashier);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">doctor</span> = Doctor::<span class="title function_ invoke__">new</span>(medical);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reception</span> = Reception::<span class="title function_ invoke__">new</span>(doctor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">patient</span> = Patient &#123;</span><br><span class="line">        name: <span class="string">&quot;John&quot;</span>.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        ..Patient::<span class="title function_ invoke__">default</span>()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reception handles a patient passing him to the next link in the chain.</span></span><br><span class="line">    <span class="comment">// Reception -&gt; Doctor -&gt; Medical -&gt; Cashier.</span></span><br><span class="line">    reception.<span class="title function_ invoke__">execute</span>(&amp;<span class="keyword">mut</span> patient);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\nThe patient has been already handled:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    reception.<span class="title function_ invoke__">execute</span>(&amp;<span class="keyword">mut</span> patient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reception registering a patient John</span><br><span class="line">Doctor checking a patient John</span><br><span class="line">Medical giving medicine to a patient John</span><br><span class="line">Cashier getting money from a patient John</span><br><span class="line"></span><br><span class="line">The patient has been already handled:</span><br><span class="line"></span><br><span class="line">Patient registration is already done</span><br><span class="line">A doctor checkup is already done</span><br><span class="line">Medicine is already given to a patient</span><br><span class="line">Payment done</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>classification of patterns</title>
    <url>/2023/11/15/design-pattern/classification-of-patterns/</url>
    <content><![CDATA[<h1 id="Classification-of-patterns"><a href="#Classification-of-patterns" class="headerlink" title="Classification of patterns"></a>Classification of patterns</h1><h1 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h1><p>Design patterns differ by their complexity, level of detail and scale of applicability to the entire system being designed. I like the analogy to road construction: you can make an intersection safer by either installing some traffic lights or building an entire multi-level interchange with underground passages for pedestrians.</p>
<p>设计模式的复杂性、详细程度和对整个设计的系统的适用范围各不相同。我喜欢与道路建设的类比：你可以通过安装一些交通信号灯或建造一个完整的多层立交桥和地下通道来使十字路口更安全。</p>
<p>The most basic and low-level patterns are often called idioms. They usually apply only to a single programming language.</p>
<p>最基本和最底层的模式通常被称为成语。它们通常仅适用于一种编程语言。</p>
<p>The most universal and high-level patterns are architectural patterns. Developers can implement these patterns in virtually any language. Unlike other patterns, they can be used to design the architecture of an entire application.</p>
<p>最通用和高级的模式是体系结构模式。开发人员几乎可以用任何语言实现这些模式。与其他模式不同，它们可用于设计整个应用程序的体系结构。</p>
<p>In addition, all patterns can be categorized by their intent, or purpose. This book covers three main groups of patterns:</p>
<p>此外，所有模式都可以按其意图或目的进行分类。本书涵盖三大类模式：</p>
<ul>
<li><p>Creational patterns provide object creation mechanisms that increase flexibility and reuse of existing code.<br>创建模式提供了对象创建机制，可提高现有代码的灵活性和重用性。</p>
</li>
<li><p>Structural patterns explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.<br>结构模式解释了如何将对象和类组合成更大的结构，同时保持这些结构的灵活性和效率。</p>
</li>
<li><p>Behavioral patterns take care of effective communication and the assignment of responsibilities between objects.<br>行为模式负责对象之间的有效沟通和责任分配。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Command 命令</title>
    <url>/2024/02/05/design-pattern/command/</url>
    <content><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>Command是一种行为设计模式，它将请求转换为包含有关请求的所有信息的独立对象。这种转换允许您将请求作为方法参数传递，延迟或排队请求的执行，并支持可撤消的操作。</p>
<div align="center"> <img src="/images/command-header.png"/></div>


<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假设您正在开发一个新的文本编辑器应用程序，您当前的任务是创建一个工具栏，其中包含一系列用于编辑器各种操作的按钮。您创建了一个非常简洁的 假设您正在开发一个新的文本编辑器应用程序，您当前的任务是创建一个工具栏，其中包含一系列用于编辑器各种操作的按钮。您创建了一个非常简洁的 <code>Button</code> 类，可用于工具栏上的按钮，以及各种对话框中的通用按钮。 类，可用于工具栏上的按钮，以及各种对话框中的通用按钮。</p>
<div align="center"> <img src="/images/command-problem1.png"/>应用程序的所有按钮都派生自同一个类。</div>


<p>虽然所有这些按钮看起来都很相似，但它们都应该做不同的事情。您将把这些按钮的各种单击处理程序的代码放在哪里？最简单的解决方案是为每个使用按钮的地方创建大量的子类。这些子类将包含必须在单击按钮时执行的代码。</p>
<div align="center"> <img src="/images/command-problem2.png"/>应用程序的所有按钮都派生自同一个类。</div>


<p>不久，你就会意识到这种方法有很大的缺陷。首先，您有大量的子类，如果您每次修改基类 不久，你就会意识到这种方法有很大的缺陷。首先，您有大量的子类，如果您每次修改基类 <code>Button</code> 时不会有破坏这些子类中代码的风险，那么这是可以的。简单地说，GUI代码已经变得笨拙地依赖于业务逻辑的易变代码。 时不会有破坏这些子类中代码的风险，那么这是可以的。简单地说，GUI代码已经变得笨拙地依赖于业务逻辑的易变代码。</p>
<div align="center"> <img src="/images/command-problem3.png"/>应用程序的所有按钮都派生自同一个类。</div>


<p>最丑陋的是。某些操作，如复制&#x2F;粘贴文本，需要从多个位置调用。例如，用户可以点击工具栏上的一个小的“复制”按钮，或者通过上下文菜单复制一些东西，或者只是点击键盘上的 最丑陋的是。某些操作，如复制&#x2F;粘贴文本，需要从多个位置调用。例如，用户可以点击工具栏上的一个小的“复制”按钮，或者通过上下文菜单复制一些东西，或者只是点击键盘上的 <code>Ctrl+C</code> 。 </p>
<p>最初，当我们的应用程序只有工具栏时，可以将各种操作的实现放在按钮子类中。换句话说，在 最初，当我们的应用程序只有工具栏时，可以将各种操作的实现放在按钮子类中。换句话说，在 <code>CopyButton</code> 子类中复制文本的代码是可以的。但是，当您实现上下文菜单、快捷方式和其他东西时，您必须在许多类中复制操作代码，或者使菜单依赖于按钮，这是一个更糟糕的选择。 子类中复制文本的代码是可以的。但是，当您实现上下文菜单、快捷方式和其他东西时，您必须在许多类中复制操作代码，或者使菜单依赖于按钮，这是一个更糟糕的选择。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>好的软件设计通常基于关注点分离的原则，这通常会导致将应用程序分解为多个层。最常见的例子：一层用于图形用户界面，另一层用于业务逻辑。GUI层负责在屏幕上呈现美丽的图片，捕获任何输入并显示用户和应用程序正在执行的操作的结果。然而，当涉及到做一些重要的事情时，比如计算月球的轨迹或撰写年度报告，GUI层将工作委托给业务逻辑的底层。</p>
<p>在代码中，它可能看起来像这样：GUI对象调用业务逻辑对象的方法，并向其传递一些参数。这个过程通常被描述为一个对象向另一个对象发送请求。</p>
<div align="center"> <img src="/images/command-solution1.png"/>GUI对象可以直接访问业务逻辑对象。</div>


<p>命令模式建议GUI对象不应该直接发送这些请求。相反，您应该提取所有请求的详细信息，例如被调用的对象，方法的名称和参数列表到一个单独的命令类中，并使用一个触发此请求的方法。</p>
<p>命令对象充当各种GUI和业务逻辑对象之间的链接。从现在开始，GUI对象不需要知道什么业务逻辑对象将接收请求以及如何处理请求。GUI对象只是触发命令，该命令处理所有细节。</p>
<div align="center"> <img src="/images/command-solution2.png"/>通过命令调用业务逻辑层。</div>


<p>下一步是使您的命令实现相同的接口。通常它只有一个不带参数的执行方法。这个接口允许您对同一个请求发送者使用不同的命令，而无需将其耦合到具体的命令类。作为奖励，现在您可以切换链接到发送者的命令对象，有效地改变发送者在运行时的行为。</p>
<p>您可能已经注意到了这个难题中缺少的一个部分，即请求参数。GUI对象可能已经为业务层对象提供了一些参数。由于命令执行方法没有任何参数，我们如何将请求细节传递给接收方？事实证明，该命令应该预先配置了这些数据，或者能够自己获取这些数据。</p>
<div align="center"> <img src="/images/command-solution3.png"/>通过命令调用业务逻辑层。</div>


<p>让我们回到我们的文本编辑器。在我们应用Command模式之后，我们不再需要所有那些按钮子类来实现各种单击行为。将一个字段放入存储命令对象引用的基类 让我们回到我们的文本编辑器。在我们应用Command模式之后，我们不再需要所有那些按钮子类来实现各种单击行为。将一个字段放入存储命令对象引用的基类 <code>Button</code> 中，并使按钮在单击时执行该命令就足够了。 中，并使按钮在单击时执行该命令就足够了。</p>
<p>您将为每个可能的操作实现一组命令类，并根据按钮的预期行为将它们与特定按钮链接。</p>
<p>其他GUI元素，如菜单、快捷方式或整个对话框，也可以用同样的方式实现。它们将被链接到一个命令，当用户与GUI元素交互时，该命令将被执行。正如您现在可能已经猜到的，与相同操作相关的元素将链接到相同的命令，从而防止任何代码重复。</p>
<p>因此，命令成为一个方便的中间层，减少了GUI和业务逻辑层之间的耦合。而这只是命令模式所能提供的好处的一小部分！</p>
<h2 id="现实世界的类比"><a href="#现实世界的类比" class="headerlink" title="现实世界的类比"></a>现实世界的类比</h2><div align="center"> <img src="/images/command-comic1.png"/>在餐馆点菜。</div>


<p>在城市里走了很长一段路后，你来到一家不错的餐馆，坐在靠窗的桌子旁。一个友好的服务员走近你，迅速地把你的订单写在一张纸上。服务员走到厨房，把菜单贴在墙上。过了一段时间，订单到达厨师，谁读它和烹饪相应的饭菜。厨师把饭菜和点菜单一起放在托盘上沿着。服务员发现托盘，检查订单，以确保一切都是你想要的，并把一切都带到你的桌子上。</p>
<p>纸上的命令是命令。在厨师准备上菜之前，它一直处于排队状态。订单包含了烹饪这顿饭所需的所有相关信息。它允许厨师立即开始烹饪，而不是跑来跑去直接向您澄清订单细节。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><div align="center"> <img src="/images/command-structure.png"/></div>


<ol>
<li>类（也称为invoker）负责发起请求。此类必须有一个用于存储对命令对象的引用的字段。发送方触发该命令，而不是直接向接收方发送请求。请注意，发送方不负责创建命令对象。通常，它通过构造函数从客户端获取预先创建的命令。</li>
<li>Command接口通常只声明一个执行命令的方法。</li>
<li>在接收对象上执行方法所需的参数可以在具体命令中声明为字段。通过只允许通过构造函数初始化这些字段，可以使命令对象不可变。</li>
<li>Receiver类包含一些业务逻辑。几乎任何物体都可以充当接收器。大多数命令只处理如何将请求传递给接收方的细节，而接收方本身则执行实际工作。</li>
<li>客户端创建和配置具体的命令对象。客户端必须将所有请求参数（包括接收器实例）传递到命令的构造函数中。在此之后，所得到的命令可以与一个或多个命令相关联。</li>
</ol>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>在本例中，Command模式有助于跟踪已执行操作的历史记录，并在需要时恢复操作。</p>
<div align="center"> <img src="/images/command-example.png"/>文本编辑器中可撤消的操作。</div>


<p>导致更改编辑器状态的命令（例如，剪切和粘贴）在执行与该命令相关联的操作之前制作编辑器状态的备份副本。在命令执行之后，它将与编辑器当时状态的备份副本一起沿着放置到命令历史记录（命令对象的堆栈）中。稍后，如果用户需要恢复操作，应用可以从历史记录中获取最新的命令，读取编辑器状态的相关备份，然后将其恢复。</p>
<p>客户端代码（GUI元素、命令历史等）没有耦合到具体的命令类，因为它通过命令接口处理命令。这种方法允许您将新命令引入到应用程序中，而不会破坏任何现有代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The base command class defines the common interface for all</span></span><br><span class="line"><span class="comment">// concrete commands.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Command</span> is</span><br><span class="line">    <span class="keyword">protected</span> field app: Application</span><br><span class="line">    <span class="keyword">protected</span> field editor: Editor</span><br><span class="line">    <span class="keyword">protected</span> field backup: text</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Command</span><span class="params">(app: Application, editor: Editor)</span> is</span><br><span class="line">        <span class="built_in">this</span>.app = app</span><br><span class="line">        <span class="built_in">this</span>.editor = editor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a backup of the editor&#x27;s state.</span></span><br><span class="line">    method <span class="title function_">saveBackup</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">backup</span> <span class="operator">=</span> editor.text</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore the editor&#x27;s state.</span></span><br><span class="line">    method <span class="title function_">undo</span><span class="params">()</span> is</span><br><span class="line">        editor.text = backup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The execution method is declared abstract to force all</span></span><br><span class="line">    <span class="comment">// concrete commands to provide their own implementations.</span></span><br><span class="line">    <span class="comment">// The method must return true or false depending on whether</span></span><br><span class="line">    <span class="comment">// the command changes the editor&#x27;s state.</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">execute</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The concrete commands go here.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CopyCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> is</span><br><span class="line">    <span class="comment">// The copy command isn&#x27;t saved to the history since it</span></span><br><span class="line">    <span class="comment">// doesn&#x27;t change the editor&#x27;s state.</span></span><br><span class="line">    method <span class="title function_">execute</span><span class="params">()</span> is</span><br><span class="line">        app.clipboard = editor.getSelection()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CutCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> is</span><br><span class="line">    <span class="comment">// The cut command does change the editor&#x27;s state, therefore</span></span><br><span class="line">    <span class="comment">// it must be saved to the history. And it&#x27;ll be saved as</span></span><br><span class="line">    <span class="comment">// long as the method returns true.</span></span><br><span class="line">    method <span class="title function_">execute</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">saveBackup</span><span class="params">()</span></span><br><span class="line">        app.clipboard = editor.getSelection()</span><br><span class="line">        editor.deleteSelection()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PasteCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> is</span><br><span class="line">    method <span class="title function_">execute</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">saveBackup</span><span class="params">()</span></span><br><span class="line">        editor.replaceSelection(app.clipboard)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The undo operation is also a command.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UndoCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> is</span><br><span class="line">    method <span class="title function_">execute</span><span class="params">()</span> is</span><br><span class="line">        app.undo()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The global command history is just a stack.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandHistory</span> is</span><br><span class="line">    <span class="keyword">private</span> field history: array of Command</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Last in...</span></span><br><span class="line">    method <span class="title function_">push</span><span class="params">(c: Command)</span> is</span><br><span class="line">        <span class="comment">// Push the command to the end of the history array.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...first out</span></span><br><span class="line">    method <span class="title function_">pop</span><span class="params">()</span>:Command is</span><br><span class="line">        <span class="comment">// Get the most recent command from the history.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The editor class has actual text editing operations. It plays</span></span><br><span class="line"><span class="comment">// the role of a receiver: all commands end up delegating</span></span><br><span class="line"><span class="comment">// execution to the editor&#x27;s methods.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Editor</span> is</span><br><span class="line">    field text: string</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getSelection</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Return selected text.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">deleteSelection</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Delete selected text.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">replaceSelection</span><span class="params">(text)</span> is</span><br><span class="line">        <span class="comment">// Insert the clipboard&#x27;s contents at the current</span></span><br><span class="line">        <span class="comment">// position.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The application class sets up object relations. It acts as a</span></span><br><span class="line"><span class="comment">// sender: when something needs to be done, it creates a command</span></span><br><span class="line"><span class="comment">// object and executes it.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    field clipboard: string</span><br><span class="line">    field editors: array of Editors</span><br><span class="line">    field activeEditor: Editor</span><br><span class="line">    field history: CommandHistory</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The code which assigns commands to UI objects may look</span></span><br><span class="line">    <span class="comment">// like this.</span></span><br><span class="line">    method <span class="title function_">createUI</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        copy = function() &#123; executeCommand(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CopyCommand</span>(<span class="built_in">this</span>, activeEditor)) &#125;</span><br><span class="line">        copyButton.setCommand(copy)</span><br><span class="line">        shortcuts.onKeyPress(<span class="string">&quot;Ctrl+C&quot;</span>, copy)</span><br><span class="line"></span><br><span class="line">        cut = function() &#123; executeCommand(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CutCommand</span>(<span class="built_in">this</span>, activeEditor)) &#125;</span><br><span class="line">        cutButton.setCommand(cut)</span><br><span class="line">        shortcuts.onKeyPress(<span class="string">&quot;Ctrl+X&quot;</span>, cut)</span><br><span class="line"></span><br><span class="line">        paste = function() &#123; executeCommand(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PasteCommand</span>(<span class="built_in">this</span>, activeEditor)) &#125;</span><br><span class="line">        pasteButton.setCommand(paste)</span><br><span class="line">        shortcuts.onKeyPress(<span class="string">&quot;Ctrl+V&quot;</span>, paste)</span><br><span class="line"></span><br><span class="line">        undo = function() &#123; executeCommand(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UndoCommand</span>(<span class="built_in">this</span>, activeEditor)) &#125;</span><br><span class="line">        undoButton.setCommand(undo)</span><br><span class="line">        shortcuts.onKeyPress(<span class="string">&quot;Ctrl+Z&quot;</span>, undo)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute a command and check whether it has to be added to</span></span><br><span class="line">    <span class="comment">// the history.</span></span><br><span class="line">    method <span class="title function_">executeCommand</span><span class="params">(command)</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(command.execute()</span>)</span><br><span class="line">            history.push(command)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take the most recent command from the history and run its</span></span><br><span class="line">    <span class="comment">// undo method. Note that we don&#x27;t know the class of that</span></span><br><span class="line">    <span class="comment">// command. But we don&#x27;t have to, since the command knows</span></span><br><span class="line">    <span class="comment">// how to undo its own action.</span></span><br><span class="line">    method <span class="title function_">undo</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">command</span> <span class="operator">=</span> history.pop()</span><br><span class="line">        <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">            command.undo()</span><br></pre></td></tr></table></figure>

<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ul>
<li><p><strong>如果要通过操作参数化对象，请使用Command模式。</strong></p>
</li>
<li><p>Command模式可以将特定的方法调用转换为独立的对象。这一变化开启了许多有趣的用途：你可以将命令作为方法参数传递，将它们存储在其他对象中，在运行时切换链接的命令，等等。</p>
<p>下面是一个示例：您正在开发一个GUI组件（如上下文菜单），并且希望您的用户能够配置菜单项，以便在最终用户单击某项时触发操作。</p>
</li>
<li><p>当您希望将操作排队、计划其执行或远程执行时，请使用Command模式。</p>
</li>
<li><p>与任何其他对象一样，命令可以序列化，这意味着将其转换为可以轻松写入文件或数据库的字符串。稍后，该字符串可以恢复为初始命令对象。因此，您可以延迟和调度命令的执行。但还有更多！以同样的方式，您可以通过网络排队，记录或发送命令。</p>
</li>
<li><p><strong>当你想实现可逆操作时，使用命令模式。</strong></p>
</li>
<li><p>虽然有很多方法可以实现撤销&#x2F;重做，但命令模式可能是最流行的。</p>
<p>为了能够还原操作，您需要实现已执行操作的历史记录。命令历史记录是一个堆栈，其中包含所有已执行的命令对象沿着以及应用程序状态的相关备份。</p>
<p>这种方法有两个缺点。首先，保存应用程序的状态并不容易，因为其中一些状态可能是私有的。这个问题可以通过Memento模式来缓解。</p>
<p>其次，状态备份可能会消耗大量RAM。因此，有时您可以采用另一种实现方式：命令执行相反的操作，而不是恢复过去的状态。反向操作也有代价：它可能很难甚至不可能实施。</p>
</li>
</ul>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><ol>
<li><p>使用单个执行方法decompose命令接口。</p>
</li>
<li><p>开始将请求提取到实现命令接口的具体命令类中。每个类都必须有一组字段，用于存储请求参数沿着对实际接收器对象的引用。所有这些值都必须通过命令的构造函数初始化。</p>
</li>
<li><p>确定将充当代理的类。将用于存储命令的字段添加到这些类中。发送者应仅通过命令接口与其命令进行通信。发送方通常不会自己创建命令对象，而是从客户端代码中获取命令对象。</p>
</li>
<li><p>更改发送方，使其执行命令，而不是直接向接收方发送请求。</p>
</li>
<li><p>客户端应按以下顺序初始化对象：</p>
<ul>
<li>创建接收器。</li>
<li>创建命令，并在需要时将它们与接收器相关联。</li>
<li>创建命令行，并将它们与特定命令关联。</li>
</ul>
</li>
</ol>
<h2 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h2><table>
<thead>
<tr>
<th>√ 利</th>
<th>× 弊</th>
</tr>
</thead>
<tbody><tr>
<td>单一责任原则。可以将调用操作的类与执行这些操作的类解耦。</td>
<td>代码可能会变得更加复杂，因为您在接收器和接收器之间引入了一个全新的层。</td>
</tr>
<tr>
<td>开放&#x2F;封闭原则。您可以在应用程序中引入新命令，而不会破坏现有的客户端代码。</td>
<td></td>
</tr>
<tr>
<td>您可以执行undo&#x2F;redo。</td>
<td></td>
</tr>
<tr>
<td>您可以实现操作的延迟执行。</td>
<td></td>
</tr>
<tr>
<td>您可以将一组简单的命令组合成一个复杂的命令。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li><p>责任链、命令、调解器和观察者解决了连接请求的接收者和接收者的各种方式：</p>
<ul>
<li>责任链（Chain of Responsibility）将请求顺序地沿着一个动态的潜在接收者链传递，直到其中一个接收者处理它。</li>
<li>命令在中继器和接收器之间建立单向连接。</li>
<li>Mediator消除了发送者和接收者之间的直接连接，迫使它们通过Mediator对象间接通信。</li>
<li>观察者允许接收者动态订阅和取消订阅接收请求。</li>
</ul>
</li>
<li><p>责任链中的处理程序可以作为命令实现。在这种情况下，您可以对同一个上下文对象（由请求表示）执行许多不同的操作。</p>
<p>然而，还有另一种方法，其中请求本身是一个Command对象。在这种情况下，您可以在链接成链的一系列不同上下文中执行相同的操作。</p>
</li>
<li><p>你可以使用命令和Memento一起实现“撤消”。在这种情况下，命令负责对目标对象执行各种操作，而memento则在执行命令之前保存该对象的状态。</p>
</li>
<li><p>Command和Strategy可能看起来很相似，因为您可以使用这两种方法通过某些操作来参数化对象。然而，他们有非常不同的意图。</p>
<ul>
<li>您可以使用Command将任何操作转换为对象。操作的参数成为该对象的字段。转换允许您延迟操作的执行，将其排队，存储命令的历史记录，将命令发送到远程服务等。</li>
<li>另一方面，Strategy通常描述做同一件事的不同方法，让你在一个上下文类中交换这些算法。</li>
</ul>
</li>
<li><p>当您需要将命令的副本保存到历史记录中时，Prototype可以提供帮助。</p>
</li>
<li><p>您可以将Visitor视为Command模式的强大版本。它的对象可以在不同类的各种对象上执行操作。</p>
</li>
</ul>
<h1 id="Python中的Command"><a href="#Python中的Command" class="headerlink" title="Python中的Command"></a>Python中的Command</h1><p>命令是一种行为设计模式，它将请求或简单操作转换为对象。</p>
<p>转换允许延迟或远程执行命令，存储命令历史等。</p>
<h2 id="概念示例"><a href="#概念示例" class="headerlink" title="概念示例"></a>概念示例</h2><p>这个例子说明了命令设计模式的结构。它侧重于回答这些问题：</p>
<ul>
<li>它由哪些类组成？</li>
<li>这些班级扮演什么角色？</li>
<li>模式中的元素是以什么方式联系在一起的？</li>
</ul>
<h4 id="main-py：概念性示例"><a href="#main-py：概念性示例" class="headerlink" title="main.py：概念性示例"></a>main.py：概念性示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Command interface declares a method for executing a command.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCommand</span>(<span class="title class_ inherited__">Command</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Some commands can implement simple operations on their own.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, payload: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._payload = payload</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;SimpleCommand: See, I can do simple things like printing&quot;</span></span><br><span class="line">              <span class="string">f&quot;(<span class="subst">&#123;self._payload&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComplexCommand</span>(<span class="title class_ inherited__">Command</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    However, some commands can delegate more complex operations to other</span></span><br><span class="line"><span class="string">    objects, called &quot;receivers.&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, receiver: Receiver, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Complex commands can accept one or several receiver objects along with</span></span><br><span class="line"><span class="string">        any context data via the constructor.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self._receiver = receiver</span><br><span class="line">        self._a = a</span><br><span class="line">        self._b = b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Commands can delegate to any methods of a receiver.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ComplexCommand: Complex stuff should be done by a receiver object&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        self._receiver.do_something(self._a)</span><br><span class="line">        self._receiver.do_something_else(self._b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Receiver classes contain some important business logic. They know how to</span></span><br><span class="line"><span class="string">    perform all kinds of operations, associated with carrying out a request. In</span></span><br><span class="line"><span class="string">    fact, any class may serve as a Receiver.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self, a: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\nReceiver: Working on (<span class="subst">&#123;a&#125;</span>.)&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something_else</span>(<span class="params">self, b: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\nReceiver: Also working on (<span class="subst">&#123;b&#125;</span>.)&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Invoker is associated with one or several commands. It sends a request</span></span><br><span class="line"><span class="string">    to the command.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _on_start = <span class="literal">None</span></span><br><span class="line">    _on_finish = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Initialize commands.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_on_start</span>(<span class="params">self, command: Command</span>):</span><br><span class="line">        self._on_start = command</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_on_finish</span>(<span class="params">self, command: Command</span>):</span><br><span class="line">        self._on_finish = command</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something_important</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Invoker does not depend on concrete command or receiver classes. The</span></span><br><span class="line"><span class="string">        Invoker passes a request to a receiver indirectly, by executing a</span></span><br><span class="line"><span class="string">        command.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invoker: Does anybody want something done before I begin?&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(self._on_start, Command):</span><br><span class="line">            self._on_start.execute()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invoker: ...doing something really important...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invoker: Does anybody want something done after I finish?&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(self._on_finish, Command):</span><br><span class="line">            self._on_finish.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code can parameterize an invoker with any commands.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    invoker = Invoker()</span><br><span class="line">    invoker.set_on_start(SimpleCommand(<span class="string">&quot;Say Hi!&quot;</span>))</span><br><span class="line">    receiver = Receiver()</span><br><span class="line">    invoker.set_on_finish(ComplexCommand(</span><br><span class="line">        receiver, <span class="string">&quot;Send email&quot;</span>, <span class="string">&quot;Save report&quot;</span>))</span><br><span class="line"></span><br><span class="line">    invoker.do_something_important()</span><br></pre></td></tr></table></figure>

<h4 id="Output-txt：执行结果"><a href="#Output-txt：执行结果" class="headerlink" title="Output.txt：执行结果"></a>Output.txt：执行结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invoker: Does anybody want something done before I begin?</span><br><span class="line">SimpleCommand: See, I can do simple things like printing (Say Hi!)</span><br><span class="line">Invoker: ...doing something really important...</span><br><span class="line">Invoker: Does anybody want something done after I finish?</span><br><span class="line">ComplexCommand: Complex stuff should be done by a receiver object</span><br><span class="line">Receiver: Working on (Send email.)</span><br><span class="line">Receiver: Also working on (Save report.)</span><br></pre></td></tr></table></figure>

<h1 id="Command-in-Rust"><a href="#Command-in-Rust" class="headerlink" title="Command in Rust"></a><strong>Command</strong> in Rust</h1><p>命令是一种行为设计模式，它将请求或简单操作转换为对象。</p>
<p>转换允许延迟或远程执行命令，存储命令历史等。</p>
<p>在Rust中，命令实例不应该持有对全局上下文的永久引用，相反，后者应该作为“ 在Rust中，命令实例不应该持有对全局上下文的永久引用，相反，后者应该作为“ <code>execute</code> “方法的可变参数从上到下传递： “方法的可变参数从上到下传递：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">execute</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, app: &amp;<span class="keyword">mut</span> cursive::Cursive) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br></pre></td></tr></table></figure>

<h2 id="文本编辑器：命令和撤消"><a href="#文本编辑器：命令和撤消" class="headerlink" title="文本编辑器：命令和撤消"></a>文本编辑器：命令和撤消</h2><p>关键点：</p>
<ul>
<li>每个按钮运行一个单独的命令。</li>
<li>由于命令被表示为对象，因此可以将其推入 由于命令被表示为对象，因此可以将其推入 <code>history</code> 数组，以便稍后撤消。 数组，以便稍后撤消。</li>
<li>TUI使用 TUI使用 <code>cursive</code> crate创建。 crate创建。</li>
</ul>
<h4 id="command-rs：Command-Interface"><a href="#command-rs：Command-Interface" class="headerlink" title="command.rs：Command Interface"></a>command.rs：Command Interface</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> copy;</span><br><span class="line"><span class="keyword">mod</span> cut;</span><br><span class="line"><span class="keyword">mod</span> paste;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> copy::CopyCommand;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> cut::CutCommand;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> paste::PasteCommand;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Declares a method for executing (and undoing) a command.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Each command receives an application context to access</span></span><br><span class="line"><span class="comment">/// visual components (e.g. edit view) and a clipboard.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">execute</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, app: &amp;<span class="keyword">mut</span> cursive::Cursive) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">undo</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, app: &amp;<span class="keyword">mut</span> cursive::Cursive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="command-copy-rs：复制命令"><a href="#command-copy-rs：复制命令" class="headerlink" title="command&#x2F;copy.rs：复制命令"></a>command&#x2F;copy.rs：复制命令</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> cursive::&#123;views::EditView, Cursive&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::Command;</span><br><span class="line"><span class="keyword">use</span> crate::AppContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CopyCommand</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Command</span> <span class="keyword">for</span> <span class="title class_">CopyCommand</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">execute</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, app: &amp;<span class="keyword">mut</span> Cursive) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">editor</span> = app.find_name::&lt;EditView&gt;(<span class="string">&quot;Editor&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">context</span> = app.take_user_data::&lt;AppContext&gt;().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        context.clipboard = editor.<span class="title function_ invoke__">get_content</span>().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">        app.<span class="title function_ invoke__">set_user_data</span>(context);</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">undo</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, _: &amp;<span class="keyword">mut</span> Cursive) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="command-cut-rs：剪切命令"><a href="#command-cut-rs：剪切命令" class="headerlink" title="command&#x2F;cut.rs：剪切命令"></a>command&#x2F;cut.rs：剪切命令</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> cursive::&#123;views::EditView, Cursive&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::Command;</span><br><span class="line"><span class="keyword">use</span> crate::AppContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CutCommand</span> &#123;</span><br><span class="line">    backup: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Command</span> <span class="keyword">for</span> <span class="title class_">CutCommand</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">execute</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, app: &amp;<span class="keyword">mut</span> Cursive) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">editor</span> = app.find_name::&lt;EditView&gt;(<span class="string">&quot;Editor&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        app.<span class="title function_ invoke__">with_user_data</span>(|context: &amp;<span class="keyword">mut</span> AppContext| &#123;</span><br><span class="line">            <span class="keyword">self</span>.backup = editor.<span class="title function_ invoke__">get_content</span>().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">            context.clipboard = <span class="keyword">self</span>.backup.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">            editor.<span class="title function_ invoke__">set_content</span>(<span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">undo</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, app: &amp;<span class="keyword">mut</span> Cursive) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">editor</span> = app.find_name::&lt;EditView&gt;(<span class="string">&quot;Editor&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        editor.<span class="title function_ invoke__">set_content</span>(&amp;<span class="keyword">self</span>.backup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="command-paste-rs：粘贴命令"><a href="#command-paste-rs：粘贴命令" class="headerlink" title="command&#x2F;paste.rs：粘贴命令"></a>command&#x2F;paste.rs：粘贴命令</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> cursive::&#123;views::EditView, Cursive&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::Command;</span><br><span class="line"><span class="keyword">use</span> crate::AppContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PasteCommand</span> &#123;</span><br><span class="line">    backup: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Command</span> <span class="keyword">for</span> <span class="title class_">PasteCommand</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">execute</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, app: &amp;<span class="keyword">mut</span> Cursive) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">editor</span> = app.find_name::&lt;EditView&gt;(<span class="string">&quot;Editor&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        app.<span class="title function_ invoke__">with_user_data</span>(|context: &amp;<span class="keyword">mut</span> AppContext| &#123;</span><br><span class="line">            <span class="keyword">self</span>.backup = editor.<span class="title function_ invoke__">get_content</span>().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">            editor.<span class="title function_ invoke__">set_content</span>(context.clipboard.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">undo</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, app: &amp;<span class="keyword">mut</span> Cursive) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">editor</span> = app.find_name::&lt;EditView&gt;(<span class="string">&quot;Editor&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        editor.<span class="title function_ invoke__">set_content</span>(&amp;<span class="keyword">self</span>.backup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-rs：客户端代码"><a href="#main-rs：客户端代码" class="headerlink" title="main.rs：客户端代码"></a>main.rs：客户端代码</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> cursive::&#123;</span><br><span class="line">    traits::Nameable,</span><br><span class="line">    views::&#123;Dialog, EditView&#125;,</span><br><span class="line">    Cursive,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> command::&#123;Command, CopyCommand, CutCommand, PasteCommand&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An application context to be passed into visual component callbacks.</span></span><br><span class="line"><span class="comment">/// It contains a clipboard and a history of commands to be undone.</span></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppContext</span> &#123;</span><br><span class="line">    clipboard: <span class="type">String</span>,</span><br><span class="line">    history: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Command&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app</span> = cursive::<span class="title function_ invoke__">default</span>();</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_ invoke__">set_user_data</span>(AppContext::<span class="title function_ invoke__">default</span>());</span><br><span class="line">    app.<span class="title function_ invoke__">add_layer</span>(</span><br><span class="line">        Dialog::<span class="title function_ invoke__">around</span>(EditView::<span class="title function_ invoke__">default</span>().<span class="title function_ invoke__">with_name</span>(<span class="string">&quot;Editor&quot;</span>))</span><br><span class="line">            .<span class="title function_ invoke__">title</span>(<span class="string">&quot;Type and use buttons&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">button</span>(<span class="string">&quot;Copy&quot;</span>, |s| <span class="title function_ invoke__">execute</span>(s, CopyCommand::<span class="title function_ invoke__">default</span>()))</span><br><span class="line">            .<span class="title function_ invoke__">button</span>(<span class="string">&quot;Cut&quot;</span>, |s| <span class="title function_ invoke__">execute</span>(s, CutCommand::<span class="title function_ invoke__">default</span>()))</span><br><span class="line">            .<span class="title function_ invoke__">button</span>(<span class="string">&quot;Paste&quot;</span>, |s| <span class="title function_ invoke__">execute</span>(s, PasteCommand::<span class="title function_ invoke__">default</span>()))</span><br><span class="line">            .<span class="title function_ invoke__">button</span>(<span class="string">&quot;Undo&quot;</span>, undo)</span><br><span class="line">            .<span class="title function_ invoke__">button</span>(<span class="string">&quot;Quit&quot;</span>, |s| s.<span class="title function_ invoke__">quit</span>()),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Executes a command and then pushes it to a history array.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">execute</span>(app: &amp;<span class="keyword">mut</span> Cursive, <span class="keyword">mut</span> command: <span class="keyword">impl</span> <span class="title class_">Command</span> + <span class="symbol">&#x27;static</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> command.<span class="title function_ invoke__">execute</span>(app) &#123;</span><br><span class="line">        app.<span class="title function_ invoke__">with_user_data</span>(|context: &amp;<span class="keyword">mut</span> AppContext| &#123;</span><br><span class="line">            context.history.<span class="title function_ invoke__">push</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(command));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Pops the last command and executes an undo action.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">undo</span>(app: &amp;<span class="keyword">mut</span> Cursive) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">context</span> = app.take_user_data::&lt;AppContext&gt;().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">mut</span> command) = context.history.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">        command.<span class="title function_ invoke__">undo</span>(app)</span><br><span class="line">    &#125;</span><br><span class="line">    app.<span class="title function_ invoke__">set_user_data</span>(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h1><div align="center"> <img src="/images/command_output.png"/></div>


]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Composite 部分-整体模式</title>
    <url>/2023/12/07/design-pattern/composite/</url>
    <content><![CDATA[<h1 id="Composite-部分-整体模式"><a href="#Composite-部分-整体模式" class="headerlink" title="Composite 部分-整体模式"></a>Composite 部分-整体模式</h1><p>Also known as: Object Tree<br>也称为：对象树</p>
<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Composite</strong> is a structural design pattern that lets you compose objects into tree structures and then work with these structures as if they were individual objects.<br>复合是一种结构设计模式，可用于将对象组合成树结构，然后像使用单个对象一样处理这些结构。</p>
<div align="center"> <img src="/images/composite-header.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Using the Composite pattern makes sense only when the core model of your app can be represented as a tree.<br>只有当应用的核心模型可以表示为树时，使用复合模式才有意义。</p>
<p>For example, imagine that you have two types of objects: <code>Products</code> and <code>Boxes</code>. A <code>Box</code> can contain several <code>Products</code> as well as a number of smaller <code>Boxes</code>. These little <code>Boxes</code> can also hold some <code>Products</code> or even smaller <code>Boxes</code>, and so on.<br>例如，假设您有两种类型的对象： <code>Products</code> 和 <code>Boxes</code>。 一个 <code>Box</code> 可以包含多个以及多个 <code>Products</code> 较小的 <code>Boxes</code>。这些小的也可以容纳一些 <code>Products</code> 甚至更小 <code>Boxes</code> 的 <code>Boxes</code> ，以此类推。</p>
<p>Say you decide to create an ordering system that uses these classes. Orders could contain simple products without any wrapping, as well as boxes stuffed with products…and other boxes. How would you determine the total price of such an order?<br>假设您决定创建一个使用这些类的排序系统。订单可以包含没有任何包装的简单产品，也可以包含装满产品的盒子……和其他盒子。您如何确定此类订单的总价？</p>
<div align="center"> <img src="/images/composite-problem-en.png"/>An order might comprise various products, packaged in boxes, which are packaged in bigger boxes and so on. The whole structure looks like an upside down tree.</br>一个订单可能包括各种产品，包装在盒子里，这些产品包装在更大的盒子里，依此类推。整个结构看起来像一棵倒置的树。</div>

<p>You could try the direct approach: unwrap all the boxes, go over all the products and then calculate the total. That would be doable in the real world; but in a program, it’s not as simple as running a loop. You have to know the classes of <code>Products</code> and <code>Boxes</code> you’re going through, the nesting level of the boxes and other nasty details beforehand. All of this makes the direct approach either too awkward or even impossible.<br>您可以尝试直接方法：打开所有盒子，检查所有产品，然后计算总数。这在现实世界中是可行的;但在程序中，它并不像运行循环那么简单。你必须事先知道 <code>Boxes</code> 你正在经历的 <code>Products</code> 类别、盒子的嵌套级别和其他令人讨厌的细节。所有这些都使得直接方法要么过于尴尬，甚至不可能。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The Composite pattern suggests that you work with <code>Products</code> and <code>Boxes</code> through a common interface which declares a method for calculating the total price.<br>复合模式建议您使用 <code>Products</code> 并通过 <code>Boxes</code> 一个通用接口进行工作，该接口声明了计算总价的方法。</p>
<p>How would this method work? For a product, it’d simply return the product’s price. For a box, it’d go over each item the box contains, ask its price and then return a total for this box. If one of these items were a smaller box, that box would also start going over its contents and so on, until the prices of all inner components were calculated. A box could even add some extra cost to the final price, such as packaging cost.<br>这种方法如何工作？对于产品，它只会返回产品的价格。对于一个盒子，它会检查盒子里的每件物品，询问它的价格，然后返回这个盒子的总数。如果其中一个物品是一个较小的盒子，那么该盒子也会开始检查其内容，依此类推，直到计算出所有内部组件的价格。一个盒子甚至会给最终价格增加一些额外的成本，比如包装成本。</p>
<div align="center"> <img src="/images/composite-comic-1-en.png"/>The Composite pattern lets you run a behavior recursively over all components of an object tree.</br>Composite 模式允许您以递归方式对对象树的所有组件运行行为。</div>

<p>The greatest benefit of this approach is that you don’t need to care about the concrete classes of objects that compose the tree. You don’t need to know whether an object is a simple product or a sophisticated box. You can treat them all the same via the common interface. When you call a method, the objects themselves pass the request down the tree.<br>这种方法的最大好处是，您不需要关心组成树的具体对象类。您不需要知道一个对象是简单的产品还是复杂的盒子。您可以通过通用界面对它们一视同仁。调用方法时，对象本身会将请求传递到树中。</p>
<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><div align="center"> <img src="/images/composite-live-example.png"/>An example of a military structure.</br>军事结构的一个例子。</div>
Armies of most countries are structured as hierarchies. An army consists of several divisions; a division is a set of brigades, and a brigade consists of platoons, which can be broken down into squads. Finally, a squad is a small group of real soldiers. Orders are given at the top of the hierarchy and passed down onto each level until every soldier knows what needs to be done.
大多数国家的军队都是等级制度。一支军队由几个师组成;一个师是一组旅，一个旅由排组成，排可以分解成小队。最后，小队是一小群真正的士兵。命令在等级制度的顶端下达，并向下传递到每个级别，直到每个士兵都知道需要做什么。

<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/composite-structure-en.png"/></div>

<ol>
<li><p>The <strong>Component</strong> interface describes operations that are common to both simple and complex elements of the tree.<br><strong>Component</strong> 接口描述树的简单元素和复杂元素通用的操作。</p>
</li>
<li><p>The Leaf is a basic element of a tree that doesn’t have sub-elements.<br>叶子是树的基本元素，没有子元素。</p>
</li>
</ol>
<p>Usually, leaf components end up doing most of the real work, since they don’t have anyone to delegate the work to.<br>通常，叶子组件最终会完成大部分实际工作，因为它们没有人可以将工作委派给它们。</p>
<ol start="3">
<li>The <strong>Container</strong> (aka composite) is an element that has sub-elements: leaves or other containers. A container doesn’t know the concrete classes of its children. It works with all sub-elements only via the component interface.<br>容器（又名复合）是一个具有子元素的元素：树叶或其他容器。容器不知道其子项的具体类。它仅通过组件接口处理所有子元素。</li>
</ol>
<p>Upon receiving a request, a container delegates the work to its sub-elements, processes intermediate results and then returns the final result to the client.<br>收到请求后，容器将工作委托给其子元素，处理中间结果，然后将最终结果返回给客户端。</p>
<ol start="4">
<li>The <strong>Client</strong> works with all elements through the component interface. As a result, the client can work in the same way with both simple or complex elements of the tree.<br>客户端通过组件接口处理所有元素。因此，客户端可以以相同的方式处理树的简单或复杂元素。</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>In this example, the <strong>Composite</strong> pattern lets you implement stacking of geometric shapes in a graphical editor.<br>在此示例中，复合模式允许您在图形编辑器中实现几何形状的堆叠。</p>
<div align="center"> <img src="/images/composite-example1.png"/>The geometric shapes editor example.</br>几何形状编辑器示例。</div>

<p>The <code>CompoundGraphic</code> class is a container that can comprise any number of sub-shapes, including other compound shapes. A compound shape has the same methods as a simple shape. However, instead of doing something on its own, a compound shape passes the request recursively to all its children and “sums up” the result.<br>该 <code>CompoundGraphic</code> 类是一个容器，可以包含任意数量的子形状，包括其他复合形状。复合形状与简单形状具有相同的方法。但是，复合形状不是自己执行某些操作，而是以递归方式将请求传递给其所有子项，并“汇总”结果。</p>
<p>The client code works with all shapes through the single interface common to all shape classes. Thus, the client doesn’t know whether it’s working with a simple shape or a compound one. The client can work with very complex object structures without being coupled to concrete classes that form that structure.<br>客户端代码通过所有形状类通用的单个接口处理所有形状。因此，客户不知道它是在处理简单形状还是复合形状。客户端可以使用非常复杂的对象结构，而无需与构成该结构的具体类耦合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The component interface declares common operations for both</span></span><br><span class="line"><span class="comment">// simple and complex objects of a composition.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Graphic</span> is</span><br><span class="line">    method <span class="title function_">move</span><span class="params">(x, y)</span></span><br><span class="line">    method <span class="title function_">draw</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The leaf class represents end objects of a composition. A</span></span><br><span class="line"><span class="comment">// leaf object can&#x27;t have any sub-objects. Usually, it&#x27;s leaf</span></span><br><span class="line"><span class="comment">// objects that do the actual work, while composite objects only</span></span><br><span class="line"><span class="comment">// delegate to their sub-components.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dot</span> <span class="keyword">implements</span> <span class="title class_">Graphic</span> is</span><br><span class="line">    field x, y</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Dot</span><span class="params">(x, y)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">move</span><span class="params">(x, y)</span> is</span><br><span class="line">        <span class="built_in">this</span>.x += x, <span class="built_in">this</span>.y += y</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">draw</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Draw a dot at X and Y.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// All component classes can extend other components.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Dot</span> is</span><br><span class="line">    field radius</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Circle</span><span class="params">(x, y, radius)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">draw</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Draw a circle at X and Y with radius R.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The composite class represents complex components that may</span></span><br><span class="line"><span class="comment">// have children. Composite objects usually delegate the actual</span></span><br><span class="line"><span class="comment">// work to their children and then &quot;sum up&quot; the result.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompoundGraphic</span> <span class="keyword">implements</span> <span class="title class_">Graphic</span> is</span><br><span class="line">    field children: array of Graphic</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A composite object can add or remove other components</span></span><br><span class="line">    <span class="comment">// (both simple or complex) to or from its child list.</span></span><br><span class="line">    method <span class="title function_">add</span><span class="params">(child: Graphic)</span> is</span><br><span class="line">        <span class="comment">// Add a child to the array of children.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">remove</span><span class="params">(child: Graphic)</span> is</span><br><span class="line">        <span class="comment">// Remove a child from the array of children.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">move</span><span class="params">(x, y)</span> is</span><br><span class="line">        <span class="title function_">foreach</span> <span class="params">(child in children)</span> <span class="keyword">do</span></span><br><span class="line">            child.move(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A composite executes its primary logic in a particular</span></span><br><span class="line">    <span class="comment">// way. It traverses recursively through all its children,</span></span><br><span class="line">    <span class="comment">// collecting and summing up their results. Since the</span></span><br><span class="line">    <span class="comment">// composite&#x27;s children pass these calls to their own</span></span><br><span class="line">    <span class="comment">// children and so forth, the whole object tree is traversed</span></span><br><span class="line">    <span class="comment">// as a result.</span></span><br><span class="line">    method <span class="title function_">draw</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// 1. For each child component:</span></span><br><span class="line">        <span class="comment">//     - Draw the component.</span></span><br><span class="line">        <span class="comment">//     - Update the bounding rectangle.</span></span><br><span class="line">        <span class="comment">// 2. Draw a dashed rectangle using the bounding</span></span><br><span class="line">        <span class="comment">// coordinates.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The client code works with all the components via their base</span></span><br><span class="line"><span class="comment">// interface. This way the client code can support simple leaf</span></span><br><span class="line"><span class="comment">// components as well as complex composites.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageEditor</span> is</span><br><span class="line">    field all: CompoundGraphic</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">load</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">all</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompoundGraphic</span>()</span><br><span class="line">        all.add(<span class="keyword">new</span> <span class="title class_">Dot</span>(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        all.add(<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>, <span class="number">3</span>, <span class="number">10</span>))</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Combine selected components into one complex composite</span></span><br><span class="line">    <span class="comment">// component.</span></span><br><span class="line">    method <span class="title function_">groupSelected</span><span class="params">(components: array of Graphic)</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompoundGraphic</span>()</span><br><span class="line">        foreach (component in components) <span class="keyword">do</span></span><br><span class="line">            group.add(component)</span><br><span class="line">            all.remove(component)</span><br><span class="line">        all.add(group)</span><br><span class="line">        <span class="comment">// All components will be drawn.</span></span><br><span class="line">        all.draw()</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p>** Use the Composite pattern when you have to implement a tree-like object structure. 当必须实现树状对象结构时，请使用 Composite 模式。**</p>
</li>
<li><p>The Composite pattern provides you with two basic element types that share a common interface: simple leaves and complex containers. A container can be composed of both leaves and other containers. This lets you construct a nested recursive object structure that resembles a tree.<br>Composite 模式为您提供了两种共享通用接口的基本元素类型：简单叶子和复杂容器。容器可以由叶子和其他容器组成。这使您可以构造类似于树的嵌套递归对象结构。</p>
</li>
<li><p><strong>Use the pattern when you want the client code to treat both simple and complex elements uniformly. 如果希望客户端代码统一处理简单元素和复杂元素，请使用该模式。</strong></p>
</li>
<li><p>All elements defined by the Composite pattern share a common interface. Using this interface, the client doesn’t have to worry about the concrete class of the objects it works with.<br>Composite 模式定义的所有元素共享一个公共接口。使用此接口，客户端不必担心它所处理的对象的具体类。</p>
</li>
</ul>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Make sure that the core model of your app can be represented as a tree structure. Try to break it down into simple elements and containers. Remember that containers must be able to contain both simple elements and other containers.<br>确保应用的核心模型可以表示为树结构。尝试将其分解为简单的元素和容器。请记住，容器必须能够同时包含简单元素和其他容器。</p>
</li>
<li><p>Declare the component interface with a list of methods that make sense for both simple and complex components.<br>使用对简单和复杂组件都有意义的方法列表声明组件接口。</p>
</li>
<li><p>Create a leaf class to represent simple elements. A program may have multiple different leaf classes.<br>创建一个叶类来表示简单元素。一个程序可以有多个不同的叶类。</p>
</li>
</ol>
<p>Create a container class to represent complex elements. In this class, provide an array field for storing references to sub-elements. The array must be able to store both leaves and containers, so make sure it’s declared with the component interface type.<br>创建一个容器类来表示复杂元素。在此类中，提供一个数组字段，用于存储对子元素的引用。数组必须能够存储叶子和容器，因此请确保使用组件接口类型声明它。</p>
<ol start="4">
<li><p>While implementing the methods of the component interface, remember that a container is supposed to be delegating most of the work to sub-elements.<br>在实现组件接口的方法时，请记住，容器应该将大部分工作委托给子元素。</p>
</li>
<li><p>Finally, define the methods for adding and removal of child elements in the container.<br>最后，定义在容器中添加和删除子元素的方法。</p>
</li>
</ol>
<p>Keep in mind that these operations can be declared in the component interface. This would violate the Interface Segregation Principle because the methods will be empty in the leaf class. However, the client will be able to treat all the elements equally, even when composing the tree.<br>请记住，这些操作可以在组件接口中声明。这将违反接口隔离原则，因为方法在叶类中为空。但是，客户端将能够平等地对待所有元素，即使在组成树时也是如此。</p>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>Pros 优点</th>
<th>Cons 缺点</th>
</tr>
</thead>
<tbody><tr>
<td>You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage. 您可以更方便地使用复杂的树结构：使用多态性和递归来发挥自己的优势。</td>
<td>It might be difficult to provide a common interface for classes whose functionality differs too much. In certain scenarios, you’d need to overgeneralize the component interface, making it harder to comprehend.可能很难为功能差异太大的类提供通用接口。在某些情况下，需要过度概括组件接口，使其更难理解。</td>
</tr>
<tr>
<td>Open&#x2F;Closed Principle. You can introduce new element types into the app without breaking the existing code, which now works with the object tree. 开&#x2F;闭原理。您可以在不破坏现有代码的情况下将新的元素类型引入应用程序，这些代码现在适用于对象树。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>You can use <strong>Builder</strong> when creating complex <strong>Composite</strong> trees because you can program its construction steps to work recursively.<br>在创建复杂的复合树时，可以使用 Builder，因为您可以对其构造步骤进行编程以递归方式工作。</p>
</li>
<li><p>Chain of <strong>Responsibility</strong> is often used in conjunction with <strong>Composite</strong>. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.<br>责任链通常与复合结合使用。在这种情况下，当叶组件收到请求时，它可能会通过所有父组件的链向下传递到对象树的根目录。</p>
</li>
<li><p>You can use <strong>Iterators</strong> to traverse <strong>Composite</strong> trees.<br>可以使用迭代器遍历复合树。</p>
</li>
<li><p>You can use Visitor to execute an operation over an entire <strong>Composite</strong> tree.<br>您可以使用 Visitor 对整个复合树执行操作。</p>
</li>
<li><p>You can implement shared leaf nodes of the <strong>Composite</strong> tree as <strong>Flyweights</strong> to save some RAM.<br>您可以将复合树的共享叶节点实现为轻量级，以节省一些 RAM。</p>
</li>
<li><p><strong>Composite</strong> and <strong>Decorator</strong> have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.<br>Composite 和 Decorator 具有相似的结构图，因为两者都依赖于递归组合来组织开放数量的对象。<br>A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.<br>装饰器类似于 Composite，但只有一个子组件。还有另一个显著的区别：Decorator 为包装的对象添加了额外的职责，而 Composite 只是“汇总”其子对象的结果。<br>However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.<br>但是，这些模式也可以协同工作：您可以使用 Decorator 来扩展 <strong>Composite</strong> 树中特定对象的行为。</p>
</li>
<li><p>Designs that make heavy use of <strong>Composite</strong> and <strong>Decorator</strong> can often benefit from using <strong>Prototype</strong>. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.<br>大量使用 <strong>Composite</strong> 和 <strong>Decorator</strong> 的设计通常可以从使用 <strong>Prototype</strong> 中受益。通过应用该模式，您可以克隆复杂的结构，而不是从头开始重新构建它们。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="Python-Conceptual-Example-概念示例"><a href="#Python-Conceptual-Example-概念示例" class="headerlink" title="Python Conceptual Example 概念示例"></a>Python Conceptual Example 概念示例</h3><p>This example illustrates the structure of the Composite design pattern. It focuses on answering these questions:<br>此示例阐释了 Composite 设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些课程扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式的元素以何种方式相关？</li>
</ul>
<h4 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The base Component class declares common operations for both simple and</span></span><br><span class="line"><span class="string">    complex objects of a composition.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self</span>) -&gt; Component:</span><br><span class="line">        <span class="keyword">return</span> self._parent</span><br><span class="line"></span><br><span class="line"><span class="meta">    @parent.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self, parent: Component</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Optionally, the base Component can declare an interface for setting and</span></span><br><span class="line"><span class="string">        accessing a parent of the component in a tree structure. It can also</span></span><br><span class="line"><span class="string">        provide some default implementation for these methods.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self._parent = parent</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    In some cases, it would be beneficial to define the child-management</span></span><br><span class="line"><span class="string">    operations right in the base Component class. This way, you won&#x27;t need to</span></span><br><span class="line"><span class="string">    expose any concrete component classes to the client code, even during the</span></span><br><span class="line"><span class="string">    object tree assembly. The downside is that these methods will be empty for</span></span><br><span class="line"><span class="string">    the leaf-level components.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_composite</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        You can provide a method that lets the client code figure out whether a</span></span><br><span class="line"><span class="string">        component can bear children.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The base Component may implement some default behavior or leave it to</span></span><br><span class="line"><span class="string">        concrete classes (by declaring the method containing the behavior as</span></span><br><span class="line"><span class="string">        &quot;abstract&quot;).</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span>(<span class="title class_ inherited__">Component</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Leaf class represents the end objects of a composition. A leaf can&#x27;t</span></span><br><span class="line"><span class="string">    have any children.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Usually, it&#x27;s the Leaf objects that do the actual work, whereas Composite</span></span><br><span class="line"><span class="string">    objects only delegate to their sub-components.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Leaf&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span>(<span class="title class_ inherited__">Component</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Composite class represents the complex components that may have</span></span><br><span class="line"><span class="string">    children. Usually, the Composite objects delegate the actual work to their</span></span><br><span class="line"><span class="string">    children and then &quot;sum-up&quot; the result.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._children: <span class="type">List</span>[Component] = []</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A composite object can add or remove other components (both simple or</span></span><br><span class="line"><span class="string">    complex) to or from its child list.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._children.append(component)</span><br><span class="line">        component.parent = self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._children.remove(component)</span><br><span class="line">        component.parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_composite</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Composite executes its primary logic in a particular way. It</span></span><br><span class="line"><span class="string">        traverses recursively through all its children, collecting and summing</span></span><br><span class="line"><span class="string">        their results. Since the composite&#x27;s children pass these calls to their</span></span><br><span class="line"><span class="string">        children and so forth, the whole object tree is traversed as a result.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> self._children:</span><br><span class="line">            results.append(child.operation())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Branch(<span class="subst">&#123;<span class="string">&#x27;+&#x27;</span>.join(results)&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code works with all of the components via the base interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;RESULT: <span class="subst">&#123;component.operation()&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code2</span>(<span class="params">component1: Component, component2: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Thanks to the fact that the child-management operations are declared in the</span></span><br><span class="line"><span class="string">    base Component class, the client code can work with any component, simple or</span></span><br><span class="line"><span class="string">    complex, without depending on their concrete classes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> component1.is_composite():</span><br><span class="line">        component1.add(component2)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;RESULT: <span class="subst">&#123;component1.operation()&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># This way the client code can support the simple leaf components...</span></span><br><span class="line">    simple = Leaf()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: I&#x27;ve got a simple component:&quot;</span>)</span><br><span class="line">    client_code(simple)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...as well as the complex composites.</span></span><br><span class="line">    tree = Composite()</span><br><span class="line"></span><br><span class="line">    branch1 = Composite()</span><br><span class="line">    branch1.add(Leaf())</span><br><span class="line">    branch1.add(Leaf())</span><br><span class="line"></span><br><span class="line">    branch2 = Composite()</span><br><span class="line">    branch2.add(Leaf())</span><br><span class="line"></span><br><span class="line">    tree.add(branch1)</span><br><span class="line">    tree.add(branch2)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Now I&#x27;ve got a composite tree:&quot;</span>)</span><br><span class="line">    client_code(tree)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: I don&#x27;t need to check the components classes even when managing the tree:&quot;</span>)</span><br><span class="line">    client_code2(tree, simple)</span><br></pre></td></tr></table></figure>

<h4 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: I&#x27;ve got a simple component:</span><br><span class="line">RESULT: Leaf</span><br><span class="line"></span><br><span class="line">Client: Now I&#x27;ve got a composite tree:</span><br><span class="line">RESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf))</span><br><span class="line"></span><br><span class="line">Client: I don&#x27;t need to check the components classes even when managing the tree:</span><br><span class="line">RESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf)+Leaf)</span><br></pre></td></tr></table></figure>

<h3 id="Rust-Files-and-Folders-文件和文件夹"><a href="#Rust-Files-and-Folders-文件和文件夹" class="headerlink" title="Rust: Files and Folders 文件和文件夹"></a>Rust: Files and Folders 文件和文件夹</h3><p>Let’s try to understand the Composite pattern with an example of an operating system’s file system. In the file system, there are two types of objects: files and folders. There are cases when files and folders should be treated to be the same way. This is where the Composite pattern comes in handy.<br>让我们尝试通过操作系统文件系统的示例来理解 Composite 模式。在文件系统中，有两种类型的对象：文件和文件夹。在某些情况下，文件和文件夹应以相同的方式处理。这就是复合模式派上用场的地方。</p>
<p>File and Directory are both of the trait Component with a single search method. For a file, it will just look into the contents of the file; for a folder, it will go through all files of that folder to find that keyword.<br>File 并且 Directory 都 trait Component 使用单一 search 方法。对于文件，它只会查看文件的内容;对于文件夹，它将遍历该文件夹的所有文件以查找该关键字。</p>
<h4 id="fs-mod-rs"><a href="#fs-mod-rs" class="headerlink" title="fs&#x2F;mod.rs"></a>fs&#x2F;mod.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> file;</span><br><span class="line"><span class="keyword">mod</span> folder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> file::File;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> folder::Folder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">search</span>(&amp;<span class="keyword">self</span>, keyword: &amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fs-file-rs"><a href="#fs-file-rs" class="headerlink" title="fs&#x2F;file.rs"></a>fs&#x2F;file.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; name &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Component</span> <span class="keyword">for</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">search</span>(&amp;<span class="keyword">self</span>, keyword: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Searching for keyword &#123;&#125; in file &#123;&#125;&quot;</span>, keyword, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fs-folder-rs"><a href="#fs-folder-rs" class="headerlink" title="fs&#x2F;folder.rs"></a>fs&#x2F;folder.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Folder</span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>,</span><br><span class="line">    components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Component&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Folder</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            name,</span><br><span class="line">            components: <span class="built_in">vec!</span>[],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, component: <span class="keyword">impl</span> <span class="title class_">Component</span> + <span class="symbol">&#x27;static</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.<span class="title function_ invoke__">push</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(component));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Component</span> <span class="keyword">for</span> <span class="title class_">Folder</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">search</span>(&amp;<span class="keyword">self</span>, keyword: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Searching recursively for keyword &#123;&#125; in folder &#123;&#125;&quot;</span>,</span><br><span class="line">            keyword, <span class="keyword">self</span>.name</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">search</span>(keyword);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a>main.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> fs::&#123;Component, File, Folder&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file1</span> = File::<span class="title function_ invoke__">new</span>(<span class="string">&quot;File 1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file2</span> = File::<span class="title function_ invoke__">new</span>(<span class="string">&quot;File 2&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file3</span> = File::<span class="title function_ invoke__">new</span>(<span class="string">&quot;File 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">folder1</span> = Folder::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Folder 1&quot;</span>);</span><br><span class="line">    folder1.<span class="title function_ invoke__">add</span>(file1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">folder2</span> = Folder::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Folder 2&quot;</span>);</span><br><span class="line">    folder2.<span class="title function_ invoke__">add</span>(file2);</span><br><span class="line">    folder2.<span class="title function_ invoke__">add</span>(file3);</span><br><span class="line">    folder2.<span class="title function_ invoke__">add</span>(folder1);</span><br><span class="line"></span><br><span class="line">    folder2.<span class="title function_ invoke__">search</span>(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Searching recursively for keyword rose in folder Folder 2</span><br><span class="line">Searching for keyword rose in file File 2</span><br><span class="line">Searching for keyword rose in file File 3</span><br><span class="line">Searching recursively for keyword rose in folder Folder 1</span><br><span class="line">Searching for keyword rose in file File 1</span><br><span class="line">------------------------------------</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Decorator 装饰器模式</title>
    <url>/2024/01/28/design-pattern/decorator/</url>
    <content><![CDATA[<h1 id="Decorator-装饰器模式"><a href="#Decorator-装饰器模式" class="headerlink" title="Decorator 装饰器模式"></a>Decorator 装饰器模式</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Decorator</strong>  is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.<br><strong>装饰器</strong>是一种结构化设计模式，它允许您将新行为附加到对象，方法是将这些对象放置在包含行为的特殊包装器对象中。</p>
<div align="center"> <img src="/images/decorator.png"/></div>


<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem  问题"></a>Problem  问题</h2><p>Imagine that you’re working on a notification library which lets other programs notify their users about important events.<br>假设您正在处理一个通知库，该库允许其他程序通知其用户有关重要事件。</p>
<p>The initial version of the library was based on the <code>Notifier</code> class that had only a few fields, a constructor and a single <code>send</code> method. The method could accept a message argument from a client and send the message to a list of emails that were passed to the notifier via its constructor. A third-party app which acted as a client was supposed to create and configure the notifier object once, and then use it each time something important happened.<br>该库的初始版本基于只有几个字段、一个构造函数和一个 <code>send</code> 方法的 <code>Notifier</code> 类。该方法可以接受来自客户端的消息参数，并将消息发送到通过其构造函数传递给通知程序的电子邮件列表。作为客户端的第三方应用程序应该创建和配置一次通知程序对象，然后在每次发生重要事件时使用它。</p>
<div align="center"> <img src="/images/decorator-problem1.png"/>A program could use the notifier class to send notifications about important events to a predefined set of emails.</br>程序可以使用notifier类将有关重要事件的通知发送到一组预定义的电子邮件。</div>


<p>At some point, you realize that users of the library expect more than just email notifications. Many of them would like to receive an SMS about critical issues. Others would like to be notified on Facebook and, of course, the corporate users would love to get Slack notifications.在某种程度上，您意识到图书馆的用户期望的不仅仅是电子邮件通知。他们中的许多人希望收到关于关键问题的短信。其他人希望在Facebook上获得通知，当然，企业用户也希望获得Slack通知。</p>
<div align="center"> <img src="/images/decorator-problem2.png"/>Each notification type is implemented as a notifier’s subclass.</br>每个通知类型都作为通知程序的子类实现。</div>


<p>How hard can that be? You extended the <code>Notifier</code> class and put the additional notification methods into new subclasses. Now the client was supposed to instantiate the desired notification class and use it for all further notifications.<br>这能有多难您扩展了 <code>Notifier</code> 类，并将额外的通知方法放入新的子类中。现在，客户端应该实例化所需的通知类，并将其用于所有进一步的通知。</p>
<p>But then someone reasonably asked you, “Why can’t you use several notification types at once? If your house is on fire, you’d probably want to be informed through every channel.”<br>但是后来有人合理地问你，“为什么你不能同时使用几种通知类型？如果你的房子着火了，你可能希望通过各种渠道得到通知。“</p>
<p>You tried to address that problem by creating special subclasses which combined several notification methods within one class. However, it quickly became apparent that this approach would bloat the code immensely, not only the library code but the client code as well.<br>您试图通过创建特殊的子类来解决这个问题，这些子类在一个类中组合了几个通知方法。然而，很快就发现这种方法会极大地膨胀代码，不仅是库代码，而且还有客户机代码。</p>
<div align="center"> <img src="/images/decorator-problem2.png"/>Combinatorial explosion of subclasses.</br>子类的组合爆炸。</div>


<p>You have to find some other way to structure notifications classes so that their number won’t accidentally break some Guinness record.您必须找到其他方法来构造通知类，以便它们的数量不会意外地打破吉尼斯记录。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution  解决方案"></a>Solution  解决方案</h2><p>Extending a class is the first thing that comes to mind when you need to alter an object’s behavior. However, inheritance has several serious caveats that you need to be aware of.<br>当您需要改变对象的行为时，首先想到的是扩展类。然而，继承有几个严重的警告，你需要知道。</p>
<ul>
<li>Inheritance is static. You can’t alter the behavior of an existing object at runtime. You can only replace the whole object with another one that’s created from a different subclass.<br>继承是静态的。不能在运行时改变现有对象的行为。你只能用另一个从不同子类创建的对象替换整个对象。</li>
<li>Subclasses can have just one parent class. In most languages, inheritance doesn’t let a class inherit behaviors of multiple classes at the same time.<br>子类只能有一个父类。在大多数语言中，继承不会让一个类同时继承多个类的行为。</li>
</ul>
<p>One of the ways to overcome these caveats is by using <em>Aggregation</em> or <em>Composition</em>  instead of <em>Inheritance</em>. Both of the alternatives work almost the same way: one object <em>has a</em> reference to another and delegates it some work, whereas with inheritance, the object itself <em>is</em> able to do that work, inheriting the behavior from its superclass.<br>克服这些警告的方法之一是使用聚合或组合而不是继承。这两种替代方法的工作方式几乎相同：一个对象引用另一个对象并委托它一些工作，而继承，对象本身能够完成这项工作，从其超类继承行为。</p>
<p>With this new approach you can easily substitute the linked “helper” object with another, changing the behavior of the container at runtime. An object can use the behavior of various classes, having references to multiple objects and delegating them all kinds of work. Aggregation&#x2F;composition is the key principle behind many design patterns, including Decorator. On that note, let’s return to the pattern discussion.<br>使用这种新方法，您可以轻松地将链接的“helper”对象替换为另一个对象，从而在运行时更改容器的行为。一个对象可以使用各种类的行为，引用多个对象并将各种工作委托给它们。聚合&#x2F;组合是许多设计模式背后的关键原则，包括Decorator。在这一点上，让我们回到模式讨论。</p>
<div align="center"> <img src="/images/decorator-solution1.png"/>Inheritance vs. Aggregation</br>继承与聚合</div>


<p>“Wrapper” is the alternative nickname for the Decorator pattern that clearly expresses the main idea of the pattern. A <em>wrapper</em> is an object that can be linked with some <em>target</em> object. The wrapper contains the same set of methods as the target and delegates to it all requests it receives. However, the wrapper may alter the result by doing something either before or after it passes the request to the target.<br>“Wrapper”是Decorator模式的另一个昵称，它清楚地表达了该模式的主要思想。包装器是可以与某个目标对象链接的对象。包装器包含与目标相同的方法集，并将其接收的所有请求委托给它。但是，包装器可以在将请求传递给目标之前或之后执行某些操作，从而改变结果。</p>
<p>When does a simple wrapper become the real decorator? As I mentioned, the wrapper implements the same interface as the wrapped object. That’s why from the client’s perspective these objects are identical. Make the wrapper’s reference field accept any object that follows that interface. This will let you cover an object in multiple wrappers, adding the combined behavior of all the wrappers to it.<br>什么时候简单的包装器变成了真实的装饰器？正如我提到的，包装器实现了与被包装对象相同的接口。这就是为什么从客户的角度来看，这些对象是相同的。使包装器的引用字段接受该接口后面的任何对象。这将允许您在多个包装器中覆盖一个对象，并将所有包装器的组合行为添加到该对象中。</p>
<p>In our notifications example, let’s leave the simple email notification behavior inside the base <code>Notifier</code> class, but turn all other notification methods into decorators.<br>在我们的通知示例中，让我们将简单的电子邮件通知行为留在基类 <code>Notifier</code> 中，但将所有其他通知方法转换为装饰器。</p>
<div align="center"> <img src="/images/decorator-solution2.png"/>Various notification methods become decorators.</br>各种通知方法成为装饰器。</div>


<p>The client code would need to wrap a basic notifier object into a set of decorators that match the client’s preferences. The resulting objects will be structured as a stack.客户机代码需要将一个基本的通知程序对象包装到一组符合客户机偏好的装饰器中。生成的对象将被构造为堆栈。</p>
<div align="center"> <img src="/images/decorator-solution2.png"/>Apps might configure complex stacks of notification decorators.</br>应用程序可能会配置复杂的通知装饰器堆栈。</div>


<p>The last decorator in the stack would be the object that the client actually works with. Since all decorators implement the same interface as the base notifier, the rest of the client code won’t care whether it works with the “pure” notifier object or the decorated one.<br>堆栈中的最后一个装饰器将是客户端实际使用的对象。由于所有装饰器都实现了与基本通知器相同的接口，因此客户端代码的其余部分不会关心它是与“纯”通知器对象一起工作还是与装饰的通知器对象一起工作。</p>
<p>We could apply the same approach to other behaviors such as formatting messages or composing the recipient list. The client can decorate the object with any custom decorators, as long as they follow the same interface as the others.<br>我们可以将相同的方法应用于其他行为，例如格式化消息或编写收件人列表。客户端可以使用任何自定义装饰器来装饰对象，只要它们遵循与其他装饰器相同的接口即可。</p>
<h2 id="Real-World-Analogy-现实世界的类比"><a href="#Real-World-Analogy-现实世界的类比" class="headerlink" title="Real-World Analogy  现实世界的类比"></a>Real-World Analogy  现实世界的类比</h2><div align="center"> <img src="/images/decorator-comic-1.png"/>You get a combined effect from wearing multiple pieces of clothing.</br>你会从穿多件衣服中得到一个综合效果。</div>


<p>Wearing clothes is an example of using decorators. When you’re cold, you wrap yourself in a sweater. If you’re still cold with a sweater, you can wear a jacket on top. If it’s raining, you can put on a raincoat. All of these garments “extend” your basic behavior but aren’t part of you, and you can easily take off any piece of clothing whenever you don’t need it.<br>穿衣服是使用装饰器的一个例子。当你冷的时候，你会把自己裹在毛衣里。如果你穿毛衣还是觉得冷，你可以在上面穿一件夹克。如果下雨，你可以穿上雨衣。所有这些衣服都“延伸”了你的基本行为，但不是你的一部分，你可以在不需要的时候轻松地脱掉任何一件衣服。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure  结构"></a>Structure  结构</h2><div align="center"> <img src="/images/decorator-structure1.png"/></div>


<ol>
<li>The <strong>Component</strong> declares the common interface for both wrappers and wrapped objects.<br>组件声明了包装器和包装对象的公共接口。</li>
<li><strong>Concrete Component</strong> is a class of objects being wrapped. It defines the basic behavior, which can be altered by decorators.<br>具体组件是一个被包装的对象类。它定义了基本的行为，可以由装饰器修改。</li>
<li>The <strong>Base Decorator</strong> class has a field for referencing a wrapped object. The field’s type should be declared as the component interface so it can contain both concrete components and decorators. The base decorator delegates all operations to the wrapped object.<br>BaseDecorator类有一个用于引用包装对象的字段。字段的类型应该被声明为组件接口，这样它就可以包含具体的组件和装饰器。基本装饰器将所有操作委托给包装对象。</li>
<li><strong>Concrete Decorators</strong> define extra behaviors that can be added to components dynamically. Concrete decorators override methods of the base decorator and execute their behavior either before or after calling the parent method.<br>具体装饰器定义了可以动态添加到组件的额外行为。具体装饰器覆盖基本装饰器的方法，并在调用父方法之前或之后执行它们的行为。</li>
<li>The <strong>Client</strong> can wrap components in multiple layers of decorators, as long as it works with all objects via the component interface.<br>客户端可以将组件包装在多层装饰器中，只要它通过组件接口与所有对象一起工作。</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode  伪代码"></a>Pseudocode  伪代码</h2><p>In this example, the In this example, the <strong>Decorator</strong> pattern lets you compress and encrypt sensitive data independently from the code that actually uses this data. pattern lets you compress and encrypt sensitive data independently from the code that actually uses this data.在本例中，Decorator模式允许您独立于实际使用敏感数据的代码来压缩和加密这些数据。</p>
<div align="center"> <img src="/images/decorator-example1.png"/>The encryption and compression decorators example.</br>加密和压缩装饰器示例。</div>


<p>The application wraps the data source object with a pair of decorators. Both wrappers change the way the data is written to and read from the disk:<br>应用程序用一对装饰器包装数据源对象。这两种包装器都改变了数据写入磁盘和从磁盘读取的方式：</p>
<ul>
<li>Just before the data is <strong>written to disk</strong>, the decorators encrypt and compress it. The original class writes the encrypted and protected data to the file without knowing about the change.<br>就在数据写入磁盘之前，装饰器加密并压缩数据。原始类将加密和保护的数据写入文件，而不知道更改。</li>
<li>Right after the data is <strong>read from disk</strong>, it goes through the same decorators, which decompress and decode it.<br>在从磁盘读取数据之后，它会经过相同的装饰器，这些装饰器会对数据进行加密和解码。</li>
</ul>
<p>The decorators and the data source class implement the same interface, which makes them all interchangeable in the client code.<br>装饰器和数据源类实现了相同的接口，这使得它们在客户端代码中可以互换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The component interface defines operations that can be</span></span><br><span class="line"><span class="comment">// altered by decorators.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DataSource</span> is</span><br><span class="line">    method <span class="title function_">writeData</span><span class="params">(data)</span></span><br><span class="line">    method <span class="title function_">readData</span><span class="params">()</span>:data</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete components provide default implementations for the</span></span><br><span class="line"><span class="comment">// operations. There might be several variations of these</span></span><br><span class="line"><span class="comment">// classes in a program.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> is</span><br><span class="line">    constructor <span class="title function_">FileDataSource</span><span class="params">(filename)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">        <span class="comment">// Write data to file.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">        <span class="comment">// Read data from file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The base decorator class follows the same interface as the</span></span><br><span class="line"><span class="comment">// other components. The primary purpose of this class is to</span></span><br><span class="line"><span class="comment">// define the wrapping interface for all concrete decorators.</span></span><br><span class="line"><span class="comment">// The default implementation of the wrapping code might include</span></span><br><span class="line"><span class="comment">// a field for storing a wrapped component and the means to</span></span><br><span class="line"><span class="comment">// initialize it.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataSourceDecorator</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> is</span><br><span class="line">    <span class="keyword">protected</span> field wrappee: DataSource</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">DataSourceDecorator</span><span class="params">(source: DataSource)</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">wrappee</span> <span class="operator">=</span> source</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The base decorator simply delegates all work to the</span></span><br><span class="line">    <span class="comment">// wrapped component. Extra behaviors can be added in</span></span><br><span class="line">    <span class="comment">// concrete decorators.</span></span><br><span class="line">    method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">        wrappee.writeData(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Concrete decorators may call the parent implementation of</span></span><br><span class="line">    <span class="comment">// the operation instead of calling the wrapped object</span></span><br><span class="line">    <span class="comment">// directly. This approach simplifies extension of decorator</span></span><br><span class="line">    <span class="comment">// classes.</span></span><br><span class="line">    method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">        <span class="keyword">return</span> wrappee.readData()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete decorators must call methods on the wrapped object,</span></span><br><span class="line"><span class="comment">// but may add something of their own to the result. Decorators</span></span><br><span class="line"><span class="comment">// can execute the added behavior either before or after the</span></span><br><span class="line"><span class="comment">// call to a wrapped object.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EncryptionDecorator</span> <span class="keyword">extends</span> <span class="title class_">DataSourceDecorator</span> is</span><br><span class="line">    method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">        <span class="comment">// 1. Encrypt passed data.</span></span><br><span class="line">        <span class="comment">// 2. Pass encrypted data to the wrappee&#x27;s writeData</span></span><br><span class="line">        <span class="comment">// method.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">        <span class="comment">// 1. Get data from the wrappee&#x27;s readData method.</span></span><br><span class="line">        <span class="comment">// 2. Try to decrypt it if it&#x27;s encrypted.</span></span><br><span class="line">        <span class="comment">// 3. Return the result.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can wrap objects in several layers of decorators.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompressionDecorator</span> <span class="keyword">extends</span> <span class="title class_">DataSourceDecorator</span> is</span><br><span class="line">    method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">        <span class="comment">// 1. Compress passed data.</span></span><br><span class="line">        <span class="comment">// 2. Pass compressed data to the wrappee&#x27;s writeData</span></span><br><span class="line">        <span class="comment">// method.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">        <span class="comment">// 1. Get data from the wrappee&#x27;s readData method.</span></span><br><span class="line">        <span class="comment">// 2. Try to decompress it if it&#x27;s compressed.</span></span><br><span class="line">        <span class="comment">// 3. Return the result.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 1. A simple example of a decorator assembly.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    method <span class="title function_">dumbUsageExample</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDataSource</span>(<span class="string">&quot;somefile.dat&quot;</span>)</span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">        <span class="comment">// The target file has been written with plain data.</span></span><br><span class="line"></span><br><span class="line">        source = <span class="keyword">new</span> <span class="title class_">CompressionDecorator</span>(source)</span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">        <span class="comment">// The target file has been written with compressed</span></span><br><span class="line">        <span class="comment">// data.</span></span><br><span class="line"></span><br><span class="line">        source = <span class="keyword">new</span> <span class="title class_">EncryptionDecorator</span>(source)</span><br><span class="line">        <span class="comment">// The source variable now contains this:</span></span><br><span class="line">        <span class="comment">// Encryption &gt; Compression &gt; FileDataSource</span></span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">        <span class="comment">// The file has been written with compressed and</span></span><br><span class="line">        <span class="comment">// encrypted data.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 2. Client code that uses an external data source.</span></span><br><span class="line"><span class="comment">// SalaryManager objects neither know nor care about data</span></span><br><span class="line"><span class="comment">// storage specifics. They work with a pre-configured data</span></span><br><span class="line"><span class="comment">// source received from the app configurator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalaryManager</span> is</span><br><span class="line">    field source: DataSource</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">SalaryManager</span><span class="params">(source: DataSource)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">load</span><span class="params">()</span> is</span><br><span class="line">        <span class="keyword">return</span> source.readData()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">save</span><span class="params">()</span> is</span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">    <span class="comment">// ...Other useful methods...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The app can assemble different stacks of decorators at</span></span><br><span class="line"><span class="comment">// runtime, depending on the configuration or environment.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationConfigurator</span> is</span><br><span class="line">    method <span class="title function_">configurationExample</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDataSource</span>(<span class="string">&quot;salary.dat&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (enabledEncryption)</span><br><span class="line">            source = <span class="keyword">new</span> <span class="title class_">EncryptionDecorator</span>(source)</span><br><span class="line">        <span class="keyword">if</span> (enabledCompression)</span><br><span class="line">            source = <span class="keyword">new</span> <span class="title class_">CompressionDecorator</span>(source)</span><br><span class="line"></span><br><span class="line">        logger = <span class="keyword">new</span> <span class="title class_">SalaryManager</span>(source)</span><br><span class="line">        salary = logger.load()</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability  适用性"></a>Applicability  适用性</h2><ul>
<li><p>Use the Decorator pattern when you need to be able to assign extra behaviors to objects at runtime without breaking the code that uses these objects.<br>当您需要能够在运行时为对象分配额外的行为而不破坏使用这些对象的代码时，请使用装饰器模式。</p>
</li>
<li><p>The Decorator lets you structure your business logic into layers, create a decorator for each layer and compose objects with various combinations of this logic at runtime. The client code can treat all these objects in the same way, since they all follow a common interface.<br>Decorator允许您将业务逻辑结构化到层中，为每一层创建一个装饰器，并在运行时使用此逻辑的各种组合来组合对象。客户端代码可以以相同的方式处理所有这些对象，因为它们都遵循一个公共接口。</p>
</li>
<li><p>Use the pattern when it’s awkward or not possible to extend an object’s behavior using inheritance.<br>当难以或不可能使用继承扩展对象的行为时，请使用该模式。</p>
</li>
<li><p>Many programming languages have the <code>final</code> keyword that can be used to prevent further extension of a class. For a final class, the only way to reuse the existing behavior would be to wrap the class with your own wrapper, using the Decorator pattern.<br>许多编程语言都有 <code>final</code> 关键字，可以用来防止类的进一步扩展。对于最后一个类，重用现有行为的唯一方法是使用自己的包装器（使用Decorator模式）包装该类。</p>
</li>
</ul>
<h2 id="How-to-Implement-如何实施"><a href="#How-to-Implement-如何实施" class="headerlink" title="How to Implement 如何实施"></a>How to Implement 如何实施</h2><ol>
<li>Make sure your business domain can be represented as a primary component with multiple optional layers over it.<br>确保您的业务域可以表示为一个主要组件，在其上有多个可选层。</li>
<li>Figure out what methods are common to both the primary component and the optional layers. Create a component interface and declare those methods there.<br>找出主要组件和可选层共有的方法。创建一个组件接口并在那里声明这些方法。</li>
<li>Create a concrete component class and define the base behavior in it.<br>创建一个具体的组件类，并在其中定义基本行为。</li>
<li>Create a base decorator class. It should have a field for storing a reference to a wrapped object. The field should be declared with the component interface type to allow linking to concrete components as well as decorators. The base decorator must delegate all work to the wrapped object.<br>创建一个基本装饰器类。它应该有一个用于存储对包装对象的引用的字段。该字段应该用组件接口类型声明，以允许链接到具体的组件以及装饰器。基本装饰器必须将所有工作委托给包装对象。</li>
<li>Make sure all classes implement the component interface.<br>确保所有类都实现组件接口。</li>
<li>Create concrete decorators by extending them from the base decorator. A concrete decorator must execute its behavior before or after the call to the parent method (which always delegates to the wrapped object).<br>通过从基本装饰器扩展它们来创建具体的装饰器。一个具体的装饰器必须在调用父方法之前或之后执行它的行为（父方法总是委托给被包装的对象）。</li>
<li>The client code must be responsible for creating decorators and composing them in the way the client needs.<br>客户端代码必须负责创建装饰器并以客户端需要的方式组合它们。</li>
</ol>
<h2 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h2><p>利弊</p>
<ul>
<li><p> You can extend an object’s behavior without making a new subclass.<br>你可以扩展一个对象的行为而不需要创建一个新的子类。</p>
</li>
<li><p> You can add or remove responsibilities from an object at runtime.<br>您可以在运行时添加或删除对象的责任。</p>
</li>
<li><p> You can combine several behaviors by wrapping an object into multiple decorators.<br>通过将一个对象包装到多个装饰器中，可以联合收割机组合多种行为。</p>
</li>
<li><p> <em>Single Responsibility Principle</em>. You can divide a monolithic class that implements many possible variants of behavior into several smaller classes.<br>单一责任原则。您可以将实现许多可能的行为变体的单体类划分为几个较小的类。</p>
</li>
<li><p> It’s hard to remove a specific wrapper from the wrappers stack.<br>很难从wrapper堆栈中删除特定的wrapper。</p>
</li>
<li><p> It’s hard to implement a decorator in such a way that its behavior doesn’t depend on the order in the decorators stack.<br>很难实现一个装饰器，使其行为不依赖于装饰器堆栈中的顺序。</p>
</li>
<li><p> The initial configuration code of layers might look pretty ugly.<br>层的初始配置代码可能看起来很难看。</p>
</li>
</ul>
<h2 id="Relations-with-Other-Patterns"><a href="#Relations-with-Other-Patterns" class="headerlink" title="Relations with Other Patterns"></a>Relations with Other Patterns</h2><p>与其他模式的关系</p>
<ul>
<li><p><a href="https://refactoring.guru/design-patterns/adapter">Adapter</a> provides a completely different interface for accessing an existing object. On the other hand, with the <a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> pattern the interface either stays the same or gets extended. In addition, <em>Decorator</em> supports recursive composition, which isn’t possible when you use <em>Adapter</em>.<br>Adapter为访问现有对象提供了一个完全不同的接口。另一方面，对于Decorator模式，接口要么保持不变，要么得到扩展。此外，Decorator支持递归组合，这在使用Adapter时是不可能的。</p>
</li>
<li><p>With <a href="https://refactoring.guru/design-patterns/adapter">Adapter</a> you access an existing object via different interface. With <a href="https://refactoring.guru/design-patterns/proxy">Proxy</a>, the interface stays the same. With <a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> you access the object via an enhanced interface.<br>使用Adapter，您可以通过不同的接口访问现有对象。使用Proxy，接口保持不变。使用Decorator，您可以通过增强的接口访问对象。</p>
</li>
<li><p><a href="https://refactoring.guru/design-patterns/chain-of-responsibility">Chain of Responsibility</a> and <a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.<br>Chain of Responsibility和Decorator具有非常相似的类结构。这两种模式都依赖于递归组合来通过一系列对象传递执行。然而，有几个关键的区别。</p>
<p>The <em>CoR</em> handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various <em>Decorators</em> can extend the object’s behavior while keeping it consistent with the base interface. In addition, decorators aren’t allowed to break the flow of the request.</p>
</li>
</ul>
<p>CoR处理程序可以彼此独立地执行任意操作。他们也可以在任何时候停止进一步传递请求。另一方面，各种装饰器可以扩展对象的行为，同时保持它与基接口的一致性。此外，装饰器不允许中断请求流。</p>
<ul>
<li><p><a href="https://refactoring.guru/design-patterns/composite">Composite</a> and <a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.<br>Composite和Decorator具有类似的结构图，因为它们都依赖于递归组合来组织开放数量的对象。</p>
<p>A <em>Decorator</em> is like a <em>Composite</em> but only has one child component. There’s another significant difference: <em>Decorator</em> adds additional responsibilities to the wrapped object, while <em>Composite</em> just “sums up” its children’s results.</p>
</li>
</ul>
<p>Decorator类似于Composite，但只有一个子组件。还有另一个显著的区别：Decorator为包装的对象添加了额外的责任，而Composite只是“总结”其子对象的结果。</p>
<p>  However, the patterns can also cooperate: you can use <em>Decorator</em> to extend the behavior of a specific object in the <em>Composite</em> tree.<br>然而，模式也可以合作：您可以使用Decorator来扩展Composite树中特定对象的行为。</p>
<ul>
<li>Designs that make heavy use of <a href="https://refactoring.guru/design-patterns/composite">Composite</a> and <a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> can often benefit from using <a href="https://refactoring.guru/design-patterns/prototype">Prototype</a>. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.<br>大量使用Composite和Decorator的设计通常可以从使用Prototype中受益。应用该模式可以克隆复杂的结构，而不是从头开始重新构造它们。</li>
<li><a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> lets you change the skin of an object, while <a href="https://refactoring.guru/design-patterns/strategy">Strategy</a> lets you change the guts.<br>Decorator允许您更改对象的皮肤，而Strategy允许您更改内部。</li>
<li><a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> and <a href="https://refactoring.guru/design-patterns/proxy">Proxy</a> have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a <em>Proxy</em> usually manages the life cycle of its service object on its own, whereas the composition of <em>Decorators</em> is always controlled by the client.<br>Decorator和Proxy具有类似的结构，但意图非常不同。这两种模式都建立在组合原则上，其中一个对象应该将一些工作委托给另一个对象。不同之处在于，Proxy通常自己管理其服务对象的生命周期，而Decorators的组成始终由客户端控制。</li>
</ul>
<h1 id="Decorator-in-Python-Python中的Decorator"><a href="#Decorator-in-Python-Python中的Decorator" class="headerlink" title="Decorator in Python Python中的Decorator"></a><strong>Decorator</strong> in Python Python中的Decorator</h1><p><strong>Decorator</strong> is a structural pattern that allows adding new behaviors to objects dynamically by placing them inside special wrapper objects, called <em>decorators</em>.<br>装饰器是一种结构化模式，它允许通过将对象放置在特殊的包装器对象（称为装饰器）中来动态地向对象添加新行为。</p>
<p>Using decorators you can wrap objects countless number of times since both target objects and decorators follow the same interface. The resulting object will get a stacking behavior of all wrappers.<br>使用装饰器，你可以无数次地包装对象，因为目标对象和装饰器都遵循相同的接口。结果对象将获得所有包装器的堆叠行为。</p>
<h2 id="Conceptual-Example-概念示例"><a href="#Conceptual-Example-概念示例" class="headerlink" title="Conceptual Example 概念示例"></a>Conceptual Example 概念示例</h2><p>This example illustrates the structure of the <strong>Decorator</strong> design pattern. It focuses on answering these questions:<br>这个例子说明了装饰器设计模式的结构。它侧重于回答这些问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些班级扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式中的元素是以什么方式联系在一起的？</li>
</ul>
<h4 id="main-py：概念性示例"><a href="#main-py：概念性示例" class="headerlink" title="main.py：概念性示例"></a>main.py：概念性示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The base Component interface defines operations that can be altered by</span></span><br><span class="line"><span class="string">    decorators.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span>(<span class="title class_ inherited__">Component</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Concrete Components provide default implementations of the operations. There</span></span><br><span class="line"><span class="string">    might be several variations of these classes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConcreteComponent&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span>(<span class="title class_ inherited__">Component</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The base Decorator class follows the same interface as the other components.</span></span><br><span class="line"><span class="string">    The primary purpose of this class is to define the wrapping interface for</span></span><br><span class="line"><span class="string">    all concrete decorators. The default implementation of the wrapping code</span></span><br><span class="line"><span class="string">    might include a field for storing a wrapped component and the means to</span></span><br><span class="line"><span class="string">    initialize it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _component: Component = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._component = component</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">component</span>(<span class="params">self</span>) -&gt; Component:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Decorator delegates all work to the wrapped component.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self._component</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> self._component.operation()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecoratorA</span>(<span class="title class_ inherited__">Decorator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Concrete Decorators call the wrapped object and alter its result in some</span></span><br><span class="line"><span class="string">    way.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Decorators may call parent implementation of the operation, instead of</span></span><br><span class="line"><span class="string">        calling the wrapped object directly. This approach simplifies extension</span></span><br><span class="line"><span class="string">        of decorator classes.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;ConcreteDecoratorA(<span class="subst">&#123;self.component.operation()&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecoratorB</span>(<span class="title class_ inherited__">Decorator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Decorators can execute their behavior either before or after the call to a</span></span><br><span class="line"><span class="string">    wrapped object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;ConcreteDecoratorB(<span class="subst">&#123;self.component.operation()&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code works with all objects using the Component interface. This</span></span><br><span class="line"><span class="string">    way it can stay independent of the concrete classes of components it works</span></span><br><span class="line"><span class="string">    with.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;RESULT: <span class="subst">&#123;component.operation()&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># This way the client code can support both simple components...</span></span><br><span class="line">    simple = ConcreteComponent()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: I&#x27;ve got a simple component:&quot;</span>)</span><br><span class="line">    client_code(simple)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...as well as decorated ones.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Note how decorators can wrap not only simple components but the other</span></span><br><span class="line">    <span class="comment"># decorators as well.</span></span><br><span class="line">    decorator1 = ConcreteDecoratorA(simple)</span><br><span class="line">    decorator2 = ConcreteDecoratorB(decorator1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Now I&#x27;ve got a decorated component:&quot;</span>)</span><br><span class="line">    client_code(decorator2)</span><br></pre></td></tr></table></figure>

<h4 id="Output-txt：执行结果"><a href="#Output-txt：执行结果" class="headerlink" title="Output.txt：执行结果"></a>Output.txt：执行结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: I&#x27;ve got a simple component:</span><br><span class="line">RESULT: ConcreteComponent</span><br><span class="line"></span><br><span class="line">Client: Now I&#x27;ve got a decorated component:</span><br><span class="line">RESULT: ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))</span><br></pre></td></tr></table></figure>

<h1 id="Decorator-in-Rust-饰Rust"><a href="#Decorator-in-Rust-饰Rust" class="headerlink" title="Decorator in Rust 饰Rust"></a><strong>Decorator</strong> in Rust 饰Rust</h1><p><strong>Decorator</strong> is a structural pattern that allows adding new behaviors to objects dynamically by placing them inside special wrapper objects, called <em>decorators</em>.<br>装饰器是一种结构化模式，它允许通过将对象放置在特殊的包装器对象（称为装饰器）中来动态地向对象添加新行为。</p>
<p>Using decorators you can wrap objects countless number of times since both target objects and decorators follow the same interface. The resulting object will get a stacking behavior of all wrappers.<br>使用装饰器，你可以无数次地包装对象，因为目标对象和装饰器都遵循相同的接口。结果对象将获得所有包装器的堆叠行为。</p>
<h2 id="Input-streams-decoration"><a href="#Input-streams-decoration" class="headerlink" title="Input streams decoration"></a>Input streams decoration</h2><p>输入流装饰</p>
<p>There is a <em><strong>practical example</strong></em>  in Rust’s standard library for input&#x2F;output operations.<br>在Rust的标准库中有一个实际的输入&#x2F;输出操作示例。</p>
<p>A buffered reader decorates a vector reader adding buffered behavior.<br>缓冲读取器装饰添加缓冲行为的向量读取器。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = BufReader::<span class="title function_ invoke__">new</span>(Cursor::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Input data&quot;</span>));</span><br><span class="line">input.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf).<span class="title function_ invoke__">ok</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a><strong>main.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;BufReader, Cursor, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0u8</span>; <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A buffered reader decorates a vector reader which wraps input data.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = BufReader::<span class="title function_ invoke__">new</span>(Cursor::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Input data&quot;</span>));</span><br><span class="line"></span><br><span class="line">    input.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf).<span class="title function_ invoke__">ok</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;Read from a buffered reader: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">byte</span> <span class="keyword">in</span> buf &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="type">char</span>::<span class="title function_ invoke__">from</span>(byte));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Read from a buffered reader: Input data</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Facade 门面（外观）模式</title>
    <url>/2024/01/29/design-pattern/facade/</url>
    <content><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>Facade是一种结构化设计模式，它为库、框架或任何其他复杂的类集提供了一个简化的接口。</p>
<div align="center"> <img src="/images/facade.png"/></div>


<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>设想一下，您必须让代码处理属于复杂库或框架的大量对象。通常，您需要初始化所有这些对象，跟踪依赖关系，以正确的顺序执行方法，等等。</p>
<p>因此，类的业务逻辑将与第三方类的实现细节紧密耦合，从而难以理解和维护。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>Facade是一个类，它为包含许多移动部件的复杂子系统提供简单的接口。与直接使用子系统相比，外观可能提供有限的功能。但是，它只包含客户真正关心的那些功能。</p>
<p>Having a facade is handy when you need to integrate your app with a sophisticated library that has dozens of features, but you just need a tiny bit of its functionality.<br>当你需要将你的应用与一个复杂的库集成时，拥有一个外观是很方便的，这个库有几十个功能，但你只需要它的一小部分功能。</p>
<p>例如，一个将猫的搞笑短视频上传到社交媒体的应用程序可能会使用专业的视频转换库。然而，它真正需要的只是一个带有单一方法 <code>encode(filename, format)</code> 的类。在创建这样一个类并将其与视频转换库连接之后，您将拥有第一个外观。</p>
<h2 id="现实世界的类比"><a href="#现实世界的类比" class="headerlink" title="现实世界的类比"></a>现实世界的类比</h2><div align="center"> <img src="/images/facade-live-example.png"/>通过电话订购。</div>


<p>当你打电话给一家商店下电话订单时，接线员是你对商店所有服务和部门的门面。运营商为您提供一个简单的语音界面，用于订购系统、支付网关和各种交付服务。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><div align="center"> <img src="/images/facade-structure.png"/></div>


<ol>
<li><strong>Facade</strong>提供了对子系统功能的特定部分的方便访问。它知道在哪里引导客户的请求，以及如何操作所有的活动部件。</li>
<li>可以创建一个<strong>Additional Facade</strong>类，以防止使用不相关的功能污染单个facade，这些功能可能会使其成为另一个复杂的结构。客户端和其他立面都可以使用其他立面。</li>
<li><strong>复杂子系统</strong>由几十个不同的对象组成。为了让它们都做一些有意义的事情，你必须深入研究子系统的实现细节，比如以正确的顺序初始化对象，并以正确的格式为它们提供数据。子系统类不知道facade的存在。他们在系统内运作，并直接相互合作。</li>
<li>客户端使用facade而不是直接调用子系统对象。</li>
</ol>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>在本例中，Facade模式简化了与复杂视频转换框架的交互。</p>
<div align="center"> <img src="/images/facade-example1.png"/>在一个facade类中隔离多个依赖项的示例。</div>


<p>与其让你的代码直接与几十个框架类一起工作，不如创建一个facade类来封装这些功能，并将其隐藏在代码的其余部分中。这种结构还可以帮助您最大限度地减少升级到框架的未来版本或用另一个版本替换它的工作。你在应用中唯一需要改变的是facade方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// These are some of the classes of a complex 3rd-party video</span></span><br><span class="line"><span class="comment">// conversion framework. We don&#x27;t control that code, therefore</span></span><br><span class="line"><span class="comment">// can&#x27;t simplify it.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoFile</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OggCompressionCodec</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MPEG4CompressionCodec</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CodecFactory</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitrateReader</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioMixer</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// We create a facade class to hide the framework&#x27;s complexity</span></span><br><span class="line"><span class="comment">// behind a simple interface. It&#x27;s a trade-off between</span></span><br><span class="line"><span class="comment">// functionality and simplicity.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoConverter</span> is</span><br><span class="line">    method <span class="title function_">convert</span><span class="params">(filename, format)</span>:File <span class="type">is</span></span><br><span class="line">        <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoFile</span>(filename)</span><br><span class="line">        sourceCodec = (<span class="keyword">new</span> <span class="title class_">CodecFactory</span>).extract(file)</span><br><span class="line">        <span class="keyword">if</span> (format == <span class="string">&quot;mp4&quot;</span>)</span><br><span class="line">            destinationCodec = <span class="keyword">new</span> <span class="title class_">MPEG4CompressionCodec</span>()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            destinationCodec = <span class="keyword">new</span> <span class="title class_">OggCompressionCodec</span>()</span><br><span class="line">        buffer = BitrateReader.read(filename, sourceCodec)</span><br><span class="line">        result = BitrateReader.convert(buffer, destinationCodec)</span><br><span class="line">        result = (<span class="keyword">new</span> <span class="title class_">AudioMixer</span>()).fix(result)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Application classes don&#x27;t depend on a billion classes</span></span><br><span class="line"><span class="comment">// provided by the complex framework. Also, if you decide to</span></span><br><span class="line"><span class="comment">// switch frameworks, you only need to rewrite the facade class.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">convertor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoConverter</span>()</span><br><span class="line">        mp4 = convertor.convert(<span class="string">&quot;funny-cats-video.ogg&quot;</span>, <span class="string">&quot;mp4&quot;</span>)</span><br><span class="line">        mp4.save()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ul>
<li><strong>当您需要一个有限但直接的接口到一个复杂的子系统时，请使用Facade模式。</strong></li>
<li>通常，子系统会随着时间的推移变得更加复杂。即使应用设计模式通常也会导致创建更多的类。子系统可能变得更加灵活，更容易在各种上下文中重用，但它需要从客户端获得的配置和样板代码的数量越来越大。Facade试图通过提供子系统最常用功能的快捷方式来解决这个问题，以满足大多数客户的需求。</li>
<li>当你想把一个子系统组织成层时，使用Facade。</li>
<li>创建外观以定义子系统每个级别的入口点。您可以通过要求多个子系统仅通过外观进行通信来减少它们之间的耦合。例如，让我们回到我们的视频转换框架。它可以分为两个层次：视频和音频相关。对于每一层，您可以创建一个外观，然后使每一层的类通过这些外观相互通信。这种方法看起来与Mediator模式非常相似。</li>
</ul>
<h2 id="如何实施"><a href="#如何实施" class="headerlink" title="如何实施"></a>如何实施</h2><ol>
<li>检查是否有可能提供比现有子系统已经提供的接口更简单的接口。如果这个接口使客户机代码独立于许多子系统的类，那么您就走对了路。</li>
<li>在一个新的facade类中decompose并实现这个接口。facade应该将客户端代码的调用重定向到子系统的适当对象。facade应该负责初始化子系统并管理其进一步的生命周期，除非客户端代码已经这样做了。</li>
<li>要从模式中获得全部好处，请使所有客户机代码仅通过外观与子系统通信。现在，客户端代码受到保护，不受子系统代码中任何更改的影响。例如，当子系统升级到新版本时，您只需要修改外观中的代码。</li>
<li>如果外观变得太大，考虑将其行为的一部分提取到一个新的、改进的外观类中。</li>
</ol>
<h2 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h2><ul>
<li>利：您可以将代码与子系统的复杂性隔离开来。</li>
<li> 弊：facade可以成为耦合到应用程序的所有类的god对象。</li>
</ul>
<h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li><p>Facade为现有对象定义了一个新的接口，而Adapter试图使现有接口可用。Adapter通常只包装一个对象，而Facade则处理整个对象子系统。</p>
</li>
<li><p>当您只想隐藏从客户端代码创建子系统对象的方式时，抽象工厂可以作为Facade的替代方案。</p>
</li>
<li><p>Flyweight展示了如何制作许多小对象，而Facade展示了如何制作代表整个子系统的单个对象。</p>
</li>
<li><p>Facade和Mediator有着类似的工作：它们试图组织许多紧密耦合的类之间的协作。</p>
<ul>
<li>Facade为对象子系统定义了一个简化的接口，但它没有引入任何新功能。子系统本身不知道facade。子系统内的对象可以直接通信。</li>
<li>Mediator集中系统组件之间的通信。组件只知道中介对象，不直接通信。</li>
</ul>
</li>
<li><p>Facade类通常可以转换为Singleton，因为在大多数情况下，单个facade对象就足够了。</p>
</li>
<li><p>Facade与Proxy类似，都缓冲一个复杂的实体并自己初始化它。与Facade不同，Proxy与其服务对象具有相同的接口，这使得它们可以互换。</p>
</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h1 id="Python中的Facade"><a href="#Python中的Facade" class="headerlink" title="Python中的Facade"></a>Python中的Facade</h1><p>Facade是一种结构化设计模式，它为复杂的类、库或框架系统提供了一个简化的（但有限的）接口。</p>
<p>虽然Facade降低了应用程序的整体复杂性，但它也有助于将不需要的依赖项移到一个地方。</p>
<h2 id="概念示例"><a href="#概念示例" class="headerlink" title="概念示例"></a>概念示例</h2><p>这个例子说明了Facade设计模式的结构。它侧重于回答这些问题：</p>
<ul>
<li>它由哪些类组成？</li>
<li>这些班级扮演什么角色？</li>
<li>模式中的元素是以什么方式联系在一起的？</li>
</ul>
<h4 id="main-py：概念性示例"><a href="#main-py：概念性示例" class="headerlink" title="main.py：概念性示例"></a>main.py：概念性示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Facade class provides a simple interface to the complex logic of one or</span></span><br><span class="line"><span class="string">    several subsystems. The Facade delegates the client requests to the</span></span><br><span class="line"><span class="string">    appropriate objects within the subsystem. The Facade is also responsible for</span></span><br><span class="line"><span class="string">    managing their lifecycle. All of this shields the client from the undesired</span></span><br><span class="line"><span class="string">    complexity of the subsystem.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, subsystem1: Subsystem1, subsystem2: Subsystem2</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Depending on your application&#x27;s needs, you can provide the Facade with</span></span><br><span class="line"><span class="string">        existing subsystem objects or force the Facade to create them on its</span></span><br><span class="line"><span class="string">        own.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self._subsystem1 = subsystem1 <span class="keyword">or</span> Subsystem1()</span><br><span class="line">        self._subsystem2 = subsystem2 <span class="keyword">or</span> Subsystem2()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Facade&#x27;s methods are convenient shortcuts to the sophisticated</span></span><br><span class="line"><span class="string">        functionality of the subsystems. However, clients get only to a fraction</span></span><br><span class="line"><span class="string">        of a subsystem&#x27;s capabilities.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        results = []</span><br><span class="line">        results.append(<span class="string">&quot;Facade initializes subsystems:&quot;</span>)</span><br><span class="line">        results.append(self._subsystem1.operation1())</span><br><span class="line">        results.append(self._subsystem2.operation1())</span><br><span class="line">        results.append(<span class="string">&quot;Facade orders subsystems to perform the action:&quot;</span>)</span><br><span class="line">        results.append(self._subsystem1.operation_n())</span><br><span class="line">        results.append(self._subsystem2.operation_z())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\n&quot;</span>.join(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subsystem1</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Subsystem can accept requests either from the facade or client directly.</span></span><br><span class="line"><span class="string">    In any case, to the Subsystem, the Facade is yet another client, and it&#x27;s</span></span><br><span class="line"><span class="string">    not a part of the Subsystem.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation1</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Subsystem1: Ready!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation_n</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Subsystem1: Go!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subsystem2</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Some facades can work with multiple subsystems at the same time.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation1</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Subsystem2: Get ready!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation_z</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Subsystem2: Fire!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">facade: Facade</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code works with complex subsystems through a simple interface</span></span><br><span class="line"><span class="string">    provided by the Facade. When a facade manages the lifecycle of the</span></span><br><span class="line"><span class="string">    subsystem, the client might not even know about the existence of the</span></span><br><span class="line"><span class="string">    subsystem. This approach lets you keep the complexity under control.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(facade.operation(), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code may have some of the subsystem&#x27;s objects already created.</span></span><br><span class="line">    <span class="comment"># In this case, it might be worthwhile to initialize the Facade with these</span></span><br><span class="line">    <span class="comment"># objects instead of letting the Facade create new instances.</span></span><br><span class="line">    subsystem1 = Subsystem1()</span><br><span class="line">    subsystem2 = Subsystem2()</span><br><span class="line">    facade = Facade(subsystem1, subsystem2)</span><br><span class="line">    client_code(facade)</span><br></pre></td></tr></table></figure>

<h4 id="Output-txt：执行结果"><a href="#Output-txt：执行结果" class="headerlink" title="Output.txt：执行结果"></a>Output.txt：执行结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Facade initializes subsystems:</span><br><span class="line">Subsystem1: Ready!</span><br><span class="line">Subsystem2: Get ready!</span><br><span class="line">Facade orders subsystems to perform the action:</span><br><span class="line">Subsystem1: Go!</span><br><span class="line">Subsystem2: Fire!</span><br></pre></td></tr></table></figure>

<h1 id="Facade-in-Rust"><a href="#Facade-in-Rust" class="headerlink" title="Facade in Rust"></a><strong>Facade</strong> in Rust</h1><p>Facade是一种结构化设计模式，它为复杂的类、库或框架系统提供了一个简化的（但有限的）接口。</p>
<p>虽然Facade降低了应用程序的整体复杂性，但它也有助于将不需要的依赖项移到一个地方。</p>
<h2 id="概念示例-1"><a href="#概念示例-1" class="headerlink" title="概念示例"></a>概念示例</h2><p><code>pub struct WalletFacade</code> 在其API背后隐藏了复杂的逻辑。一个方法 <code>add_money_to_wallet</code> 在后台与账户、代码、钱包、通知和账本进行交互。</p>
<h4 id="wallet-facade-rs"><a href="#wallet-facade-rs" class="headerlink" title="wallet_facade.rs"></a><strong>wallet_facade.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    account::Account, ledger::Ledger, notification::Notification, security_code::SecurityCode,</span><br><span class="line">    wallet::Wallet,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Facade hides a complex logic behind the API.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WalletFacade</span> &#123;</span><br><span class="line">    account: Account,</span><br><span class="line">    wallet: Wallet,</span><br><span class="line">    code: SecurityCode,</span><br><span class="line">    notification: Notification,</span><br><span class="line">    ledger: Ledger,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">WalletFacade</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(account_id: <span class="type">String</span>, code: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Starting create account&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">this</span> = <span class="keyword">Self</span> &#123;</span><br><span class="line">            account: Account::<span class="title function_ invoke__">new</span>(account_id),</span><br><span class="line">            wallet: Wallet::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            code: SecurityCode::<span class="title function_ invoke__">new</span>(code),</span><br><span class="line">            notification: Notification,</span><br><span class="line">            ledger: Ledger,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Account created&quot;</span>);</span><br><span class="line">        this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_money_to_wallet</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        account_id: &amp;<span class="type">String</span>,</span><br><span class="line">        security_code: <span class="type">u32</span>,</span><br><span class="line">        amount: <span class="type">u32</span>,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Starting add money to wallet&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.account.<span class="title function_ invoke__">check</span>(account_id)?;</span><br><span class="line">        <span class="keyword">self</span>.code.<span class="title function_ invoke__">check</span>(security_code)?;</span><br><span class="line">        <span class="keyword">self</span>.wallet.<span class="title function_ invoke__">credit_balance</span>(amount);</span><br><span class="line">        <span class="keyword">self</span>.notification.<span class="title function_ invoke__">send_wallet_credit_notification</span>();</span><br><span class="line">        <span class="keyword">self</span>.ledger.<span class="title function_ invoke__">make_entry</span>(account_id, <span class="string">&quot;credit&quot;</span>.<span class="title function_ invoke__">into</span>(), amount);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">deduct_money_from_wallet</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        account_id: &amp;<span class="type">String</span>,</span><br><span class="line">        security_code: <span class="type">u32</span>,</span><br><span class="line">        amount: <span class="type">u32</span>,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Starting debit money from wallet&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.account.<span class="title function_ invoke__">check</span>(account_id)?;</span><br><span class="line">        <span class="keyword">self</span>.code.<span class="title function_ invoke__">check</span>(security_code)?;</span><br><span class="line">        <span class="keyword">self</span>.wallet.<span class="title function_ invoke__">debit_balance</span>(amount);</span><br><span class="line">        <span class="keyword">self</span>.notification.<span class="title function_ invoke__">send_wallet_debit_notification</span>();</span><br><span class="line">        <span class="keyword">self</span>.ledger.<span class="title function_ invoke__">make_entry</span>(account_id, <span class="string">&quot;debit&quot;</span>.<span class="title function_ invoke__">into</span>(), amount);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="wallet-rs"><a href="#wallet-rs" class="headerlink" title="wallet.rs"></a><strong>wallet.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    balance: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; balance: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">credit_balance</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, amount: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">debit_balance</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, amount: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.balance</span><br><span class="line">            .<span class="title function_ invoke__">checked_sub</span>(amount)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Balance is not sufficient&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="account-rs"><a href="#account-rs" class="headerlink" title="account.rs"></a><strong>account.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; name &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">check</span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> &amp;<span class="keyword">self</span>.name != name &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Account name is incorrect&quot;</span>.<span class="title function_ invoke__">into</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Account verified&quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ledger-rs"><a href="#ledger-rs" class="headerlink" title="ledger.rs"></a><strong>ledger.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Ledger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Ledger</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">make_entry</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, account_id: &amp;<span class="type">String</span>, txn_type: <span class="type">String</span>, amount: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Make ledger entry for accountId &#123;&#125; with transaction type &#123;&#125; for amount &#123;&#125;&quot;</span>,</span><br><span class="line">            account_id, txn_type, amount</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="notification-rs"><a href="#notification-rs" class="headerlink" title="notification.rs"></a><strong>notification.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Notification</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">send_wallet_credit_notification</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Sending wallet credit notification&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">send_wallet_debit_notification</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Sending wallet debit notification&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="security-code-rs"><a href="#security-code-rs" class="headerlink" title="security_code.rs"></a><strong>security_code.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SecurityCode</span> &#123;</span><br><span class="line">    code: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SecurityCode</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(code: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; code &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">check</span>(&amp;<span class="keyword">self</span>, code: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.code != code &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Security code is incorrect&quot;</span>.<span class="title function_ invoke__">into</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Security code verified&quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a><strong>main.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> account;</span><br><span class="line"><span class="keyword">mod</span> ledger;</span><br><span class="line"><span class="keyword">mod</span> notification;</span><br><span class="line"><span class="keyword">mod</span> security_code;</span><br><span class="line"><span class="keyword">mod</span> wallet;</span><br><span class="line"><span class="keyword">mod</span> wallet_facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> wallet_facade::WalletFacade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">wallet</span> = WalletFacade::<span class="title function_ invoke__">new</span>(<span class="string">&quot;abc&quot;</span>.<span class="title function_ invoke__">into</span>(), <span class="number">1234</span>);</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wallet Facade interacts with the account, code, wallet, notification and</span></span><br><span class="line">    <span class="comment">// ledger behind the scenes.</span></span><br><span class="line">    wallet.<span class="title function_ invoke__">add_money_to_wallet</span>(&amp;<span class="string">&quot;abc&quot;</span>.<span class="title function_ invoke__">into</span>(), <span class="number">1234</span>, <span class="number">10</span>)?;</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    wallet.<span class="title function_ invoke__">deduct_money_from_wallet</span>(&amp;<span class="string">&quot;abc&quot;</span>.<span class="title function_ invoke__">into</span>(), <span class="number">1234</span>, <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting create account</span><br><span class="line">Account created</span><br><span class="line"></span><br><span class="line">Starting add money to wallet</span><br><span class="line">Account verified</span><br><span class="line">Security code verified</span><br><span class="line">Sending wallet credit notification</span><br><span class="line">Make ledger entry for accountId abc with transaction type credit for amount 10</span><br><span class="line"></span><br><span class="line">Starting debit money from wallet</span><br><span class="line">Account verified</span><br><span class="line">Security code verified</span><br><span class="line">Sending wallet debit notification</span><br><span class="line">Make ledger entry for accountId abc with transaction type debit for amount 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Factory Method</title>
    <url>/2023/11/16/design-pattern/factory-method/</url>
    <content><![CDATA[<h1 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h1><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>Also known as: Virtual Constructor<br>也称为： Virtual Constructor</p>
<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p>Factory Method is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.</p>
<p>工厂方法是一种创建设计模式，它提供了一个接口，用于在超类中创建对象，但允许子类更改将要创建的对象的类型。<br><img src="/images/factory-method-en.png"></p>
<p>Factory Method pattern</p>
<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Imagine that you’re creating a logistics management application. The first version of your app can only handle transportation by trucks, so the bulk of your code lives inside the Truck class.<br>假设您正在创建一个物流管理应用程序。应用的第一个版本只能处理卡车运输，因此大部分代码都位于 Truck 类中。</p>
<p>After a while, your app becomes pretty popular. Each day you receive dozens of requests from sea transportation companies to incorporate sea logistics into the app.</p>
<p>一段时间后，您的应用程序变得非常受欢迎。每天，您都会收到数十个来自海运公司的请求，要求将海运物流纳入应用程序。</p>
<div align="center"> <img src="/images/problem1-en.png"/> Adding a new class to the program isn’t that simple if the rest of the code is already coupled to existing classes.</br>如果代码的其余部分已经耦合到现有类，则向程序添加新类并不那么简单。 </div>

<p>Great news, right? But how about the code? At present, most of your code is coupled to the <code>Truck</code> class. Adding <code>Ships</code> into the app would require making changes to the entire codebase. Moreover, if later you decide to add another type of transportation to the app, you will probably need to make all of these changes again.<br>好消息，对吧？但是代码呢？目前，您的大部分代码都与类 Truck 耦合。添加到 Ships 应用程序中需要对整个代码库进行更改。此外，如果您以后决定向应用程序添加另一种类型的交通工具，您可能需要再次进行所有这些更改。</p>
<p>As a result, you will end up with pretty nasty code, riddled with conditionals that switch the app’s behavior depending on the class of transportation objects.<br>结果，你最终会得到非常讨厌的代码，其中充斥着条件，这些条件根据运输对象的类别来切换应用程序的行为。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The Factory Method pattern suggests that you replace direct object construction calls (using the new operator) with calls to a special factory method. Don’t worry: the objects are still created via the new operator, but it’s being called from within the factory method. Objects returned by a factory method are often referred to as products.<br>工厂方法模式建议将直接对象构造调用（使用运 new 算符）替换为对特殊工厂方法的调用。不用担心：对象仍然是通过运算符 new 创建的，但它是从工厂方法中调用的。工厂方法返回的对象通常称为产品。</p>
<div align="center"> <img src="/images/solution1.png"/> Subclasses can alter the class of objects being returned by the factory method.</br>子类可以更改工厂方法返回的对象的类。</div>

<p>At first glance, this change may look pointless: we just moved the constructor call from one part of the program to another. However, consider this: now you can override the factory method in a subclass and change the class of products being created by the method.</p>
<p>乍一看，这种变化可能看起来毫无意义：我们只是将构造函数调用从程序的一部分移动到另一部分。但是，请考虑以下情况：现在您可以在子类中重写工厂方法，并更改该方法创建的产品类。</p>
<p>There’s a slight limitation though: subclasses may return different types of products only if these products have a common base class or interface. Also, the factory method in the base class should have its return type declared as this interface.</p>
<p>但是有一个轻微的限制：只有当这些产品具有共同的基类或接口时，子类才能返回不同类型的产品。此外，基类中的工厂方法应将其返回类型声明为此接口。</p>
<p>The structure of the products hierarchy<br>All products must follow the same interface.<br>所有产品必须遵循相同的界面。</p>
<div align="center"> <img src="/images/solution1.png"/>All products must follow the same interface.</br>所有产品必须遵循相同的界面。</div>

<p>For example, both <code>Truck</code> and <code>Ship</code> classes should implement the <code>Transport</code> interface, which declares a method called <code>deliver</code>. Each class implements this method differently: trucks deliver cargo by land, ships deliver cargo by sea. The factory method in the <code>RoadLogistics</code> class returns truck objects, whereas the factory method in the <code>SeaLogistics</code> class returns ships.<br>例如，和类都应该 <code>Truck</code> 实现接口 <code>Transport</code> ，该接口声明了一个名为 <code>deliver</code> . <code>Ship</code> 每个类别都以不同的方式实现这种方法：卡车通过陆路运送货物，船舶通过海上运送货物。 <code>RoadLogistics</code> 类中的 <code>factory</code> 方法返回 <code>truck</code> 对象，而 <code>SeaLogistics</code> 类中的 <code>factory</code> 方法返回 <code>ships</code>。</p>
<div align="center"> <img src="/images/solution2.png"/>As long as all product classes implement a common interface, you can pass their objects to the client code without breaking it.</br>只要所有产品类都实现一个通用接口，就可以将其对象传递给客户端代码，而不会中断它。</div>

<p>The code that uses the factory method (often called the client code) doesn’t see a difference between the actual products returned by various subclasses. The client treats all the products as abstract <code>Transport</code>. The client knows that all transport objects are supposed to have the <code>deliver</code> method, but exactly how it works isn’t important to the client.<br>使用工厂方法的代码（通常称为客户端代码）看不到各个子类返回的实际产品之间的差异。客户将所有产品视为抽象 <code>Transport</code> 产品。客户端知道所有传输对象都应该具有该 <code>deliver</code> 方法，但其工作方式对客户端来说并不重要。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/structure.png"/></div>

<h4 id="1-Prodcut"><a href="#1-Prodcut" class="headerlink" title="1.Prodcut"></a>1.Prodcut</h4><p>The Product declares the interface, which is common to all objects that can be produced by the creator and its subclasses.</p>
<p>Product 声明接口，该接口对于创建者及其子类可以生成的所有对象都是通用的。</p>
<h4 id="2-Concrete-Products"><a href="#2-Concrete-Products" class="headerlink" title="2.Concrete Products"></a>2.Concrete Products</h4><p>Concrete Products are different implementations of the product interface.<br>具体产品是产品接口的不同实现。</p>
<h4 id="3-Creator"><a href="#3-Creator" class="headerlink" title="3.Creator"></a>3.Creator</h4><p>The Creator class declares the factory method that returns new product objects. It’s important that the return type of this method matches the product interface.</p>
<p>Creator 类声明返回新产品对象的工厂方法。此方法的返回类型必须与产品接口匹配，这一点很重要。</p>
<p>You can declare the factory method as abstract to force all subclasses to implement their own versions of the method. As an alternative, the base factory method can return some default product type.</p>
<p>您可以声明工厂方法，以 abstract 强制所有子类实现其自己的方法版本。或者，基工厂方法可以返回一些默认产品类型。</p>
<p>Note, despite its name, product creation is not the primary responsibility of the creator. Usually, the creator class already has some core business logic related to products. The factory method helps to decouple this logic from the concrete product classes. Here is an analogy: a large software development company can have a training department for programmers. However, the primary function of the company as a whole is still writing code, not producing programmers.</p>
<p>请注意，尽管它的名字，产品创建并不是创建者的主要责任。通常，creator 类已经有一些与产品相关的核心业务逻辑。工厂方法有助于将此逻辑与具体的产品类分离。打个比方：一家大型软件开发公司可以有一个程序员培训部门。然而，整个公司的主要职能仍然是编写代码，而不是培养程序员。</p>
<h4 id="4-Concrete-Creators"><a href="#4-Concrete-Creators" class="headerlink" title="4.Concrete Creators"></a>4.Concrete Creators</h4><p>Concrete Creators override the base factory method so it returns a different type of product.<br>Concrete Creators 会重写基本工厂方法，因此它会返回不同类型的产品。</p>
<p>Note that the factory method doesn’t have to create new instances all the time. It can also return existing objects from a cache, an object pool, or another source.<br>请注意，工厂方法不必一直创建新实例。它还可以从缓存、对象池或其他源返回现有对象。</p>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example illustrates how the Factory Method can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes.</p>
<p>此示例演示如何使用 Factory 方法创建跨平台 UI 元素，而无需将客户端代码耦合到具体的 UI 类。</p>
<div align="center"> <img src="/images/example.png"/>The cross-platform dialog example.</br>跨平台对话框示例。</div>

<p>The base <code>Dialog</code> class uses different UI elements to render its window. Under various operating systems, these elements may look a little bit different, but they should still behave consistently. A button in Windows is still a button in Linux.<br>基 <code>Dialog</code> 类使用不同的 UI 元素来呈现其窗口。在各种操作系统下，这些元素可能看起来略有不同，但它们的行为仍应一致。Windows 中的按钮仍然是 Linux 中的按钮。</p>
<p>When the factory method comes into play, you don’t need to rewrite the logic of the <code>Dialog</code> class for each operating system. If we declare a factory method that produces buttons inside the base <code>Dialog</code> class, we can later create a subclass that returns Windows-styled buttons from the factory method. The subclass then inherits most of the code from the base class, but, thanks to the factory method, can render Windows-looking buttons on the screen.<br>当工厂方法发挥作用时，无需为每个操作系统重写 <code>Dialog</code> 类的逻辑。如果我们声明一个在基 <code>Dialog</code> 类中生成按钮的工厂方法，我们稍后可以创建一个子类，该子类从工厂方法返回 Windows 样式的按钮。然后，该子类从基类继承大部分代码，但是，由于工厂方法，可以在屏幕上呈现具有 Windows 外观的按钮。</p>
<p>For this pattern to work, the base <code>Dialog</code> class must work with abstract buttons: a base class or an interface that all concrete buttons follow. This way the code within <code>Dialog</code> remains functional, whichever type of buttons it works with.<br>要使此模式起作用，基类必须使用抽象按钮：所有具体按钮都遵循的基 <code>Dialog</code> 类或接口。这样，无论使用哪种类型的按钮，其中 <code>Dialog</code> 的代码都可以正常工作。</p>
<p>Of course, you can apply this approach to other UI elements as well. However, with each new factory method you add to the <code>Dialog</code>, you get closer to the Abstract Factory pattern. Fear not, we’ll talk about this pattern later.<br>当然，您也可以将此方法应用于其他 UI 元素。但是，随着您添加到 <code>Dialog</code> 的每个新工厂方法，您都更接近抽象工厂模式。不要害怕，我们稍后会讨论这种模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The creator class declares the factory method that must</span></span><br><span class="line"><span class="comment">// return an object of a product class. The creator&#x27;s subclasses</span></span><br><span class="line"><span class="comment">// usually provide the implementation of this method.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> is</span><br><span class="line">    <span class="comment">// The creator may also provide some default implementation</span></span><br><span class="line">    <span class="comment">// of the factory method.</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note that, despite its name, the creator&#x27;s primary</span></span><br><span class="line">    <span class="comment">// responsibility isn&#x27;t creating products. It usually</span></span><br><span class="line">    <span class="comment">// contains some core business logic that relies on product</span></span><br><span class="line">    <span class="comment">// objects returned by the factory method. Subclasses can</span></span><br><span class="line">    <span class="comment">// indirectly change that business logic by overriding the</span></span><br><span class="line">    <span class="comment">// factory method and returning a different type of product</span></span><br><span class="line">    <span class="comment">// from it.</span></span><br><span class="line">    method <span class="title function_">render</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Call the factory method to create a product object.</span></span><br><span class="line">        <span class="type">Button</span> <span class="variable">okButton</span> <span class="operator">=</span> createButton()</span><br><span class="line">        <span class="comment">// Now use the product.</span></span><br><span class="line">        okButton.onClick(closeDialog)</span><br><span class="line">        okButton.render()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete creators override the factory method to change the</span></span><br><span class="line"><span class="comment">// resulting product&#x27;s type.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HTMLButton</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The product interface declares the operations that all</span></span><br><span class="line"><span class="comment">// concrete products must implement.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">render</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">onClick</span><span class="params">(f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete products provide various implementations of the</span></span><br><span class="line"><span class="comment">// product interface.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">render</span><span class="params">(a, b)</span> is</span><br><span class="line">        <span class="comment">// Render a button in Windows style.</span></span><br><span class="line">    method <span class="title function_">onClick</span><span class="params">(f)</span> is</span><br><span class="line">        <span class="comment">// Bind a native OS click event.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">render</span><span class="params">(a, b)</span> is</span><br><span class="line">        <span class="comment">// Return an HTML representation of a button.</span></span><br><span class="line">    method <span class="title function_">onClick</span><span class="params">(f)</span> is</span><br><span class="line">        <span class="comment">// Bind a web browser click event.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    field dialog: Dialog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The application picks a creator&#x27;s type depending on the</span></span><br><span class="line">    <span class="comment">// current configuration or environment settings.</span></span><br><span class="line">    method <span class="title function_">initialize</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">config</span> <span class="operator">=</span> readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config.OS == <span class="string">&quot;Windows&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsDialog</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (config.OS == <span class="string">&quot;Web&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebDialog</span>()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Error! Unknown operating system.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The client code works with an instance of a concrete</span></span><br><span class="line">    <span class="comment">// creator, albeit through its base interface. As long as</span></span><br><span class="line">    <span class="comment">// the client keeps working with the creator via the base</span></span><br><span class="line">    <span class="comment">// interface, you can pass it any creator&#x27;s subclass.</span></span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.initialize()</span><br><span class="line">        dialog.render()</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><p><strong>Use the Factory Method when you don’t know beforehand the exact types and dependencies of the objects your code should work with.</strong><br><strong>当您事先不知道代码应使用的对象的确切类型和依赖项时，请使用工厂方法。</strong></p>
<p>The Factory Method separates product construction code from the code that actually uses the product. Therefore it’s easier to extend the product construction code independently from the rest of the code.</p>
<p>Factory 方法将产品构造代码与实际使用产品的代码分开。因此，独立于代码的其余部分扩展产品构造代码更容易。</p>
<p>For example, to add a new product type to the app, you’ll only need to create a new creator subclass and override the factory method in it.</p>
<p>例如，要向应用添加新的产品类型，只需创建一个新的创建者子类并重写其中的工厂方法。</p>
<p><strong>Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components.</strong><br><strong>如果要为库或框架的用户提供扩展其内部组件的方法，请使用工厂方法。</strong></p>
<p>Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component?<br>继承可能是扩展库或框架默认行为的最简单方法。但是，框架如何识别应该使用您的子类而不是标准组件呢？</p>
<p>The solution is to reduce the code that constructs components across the framework into a single factory method and let anyone override this method in addition to extending the component itself.<br>解决方案是将跨框架构造组件的代码简化为单个工厂方法，并允许任何人在扩展组件本身之外重写此方法。</p>
<p>Let’s see how that would work. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard <code>Button</code> class with a glorious <code>RoundButton</code> subclass. But now you need to tell the main <code>UIFramework</code> class to use the new button subclass instead of a default one.<br>让我们看看这将如何工作。想象一下，你使用开源 UI 框架编写一个应用。你的应用应该有圆形按钮，但框架只提供方形按钮。你用一个光荣的 <code>RoundButton</code> 子类扩展了标准 Button 类。但是现在你需要告诉主 <code>UIFramework</code> 类使用新的按钮子类，而不是默认的子类。</p>
<p>To achieve this, you create a subclass <code>UIWithRoundButtons</code> from a base framework class and override its createButton method. While this method returns <code>Button</code> objects in the base class, you make your subclass return <code>RoundButton</code> objects. Now use the <code>UIWithRoundButtons</code> class instead of <code>UIFramework</code>. And that’s about it!<br>为此，可以从基框架类创建一个子类 <code>UIWithRoundButtons</code> 并重写其 createButton 方法。当此方法返回基类中的对象时，您可以使子类返回 Button <code>RoundButton</code> 对象。现在使用类 <code>UIWithRoundButtons</code> 而不是 <code>UIFramework</code> .仅此而已！</p>
<p><strong>Use the Factory Method when you want to save system resources by reusing existing objects instead of rebuilding them each time.</strong><br><strong>如果要通过重用现有对象而不是每次都重新生成它们来节省系统资源，请使用工厂方法。</strong></p>
<p>You often experience this need when dealing with large, resource-intensive objects such as database connections, file systems, and network resources.<br>在处理大型资源密集型对象（如数据库连接、文件系统和网络资源）时，您经常会遇到这种需求。</p>
<p>Let’s think about what has to be done to reuse an existing object:<br>让我们考虑一下重用现有对象必须做些什么：</p>
<ul>
<li>First, you need to create some storage to keep track of all of the created objects.<br>首先，您需要创建一些存储来跟踪所有创建的对象。</li>
<li>When someone requests an object, the program should look for a free object inside that pool.<br>当有人请求某个对象时，程序应该在该池中查找一个空闲对象。</li>
<li>… and then return it to the client code.<br>…，然后将其返回给客户端代码。</li>
<li>If there are no free objects, the program should create a new one (and add it to the pool).<br>如果没有空闲对象，程序应创建一个新对象（并将其添加到池中）。</li>
</ul>
<p>That’s a lot of code! And it must all be put into a single place so that you don’t pollute the program with duplicate code.<br>这是一大堆代码！而且必须将它们全部放在一个地方，这样您就不会用重复的代码污染程序。</p>
<p>Probably the most obvious and convenient place where this code could be placed is the constructor of the class whose objects we’re trying to reuse. However, a constructor must always return <strong>new objects</strong> by definition. It can’t return existing instances.<br>放置此代码的最明显和最方便的位置可能是我们尝试重用其对象的类的构造函数。但是，根据定义，构造函数必须始终返回<strong>new objects</strong>。它无法返回现有实例。</p>
<p>Therefore, you need to have a regular method capable of creating new objects as well as reusing existing ones. That sounds very much like a factory method.<br>因此，您需要有一个能够创建新对象以及重用现有对象的常规方法。这听起来很像工厂方法。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ul>
<li><p>Make all products follow the same interface. This interface should declare methods that make sense in every product.<br>使所有产品都遵循相同的界面。此接口应声明在每个产品中都有意义的方法。</p>
</li>
<li><p>Add an empty factory method inside the creator class. The return type of the method should match the common product interface.<br>在 creator 类中添加一个空的工厂方法。方法的返回类型应与通用产品接口匹配。</p>
</li>
<li><p>In the creator’s code find all references to product constructors. One by one, replace them with calls to the factory method, while extracting the product creation code into the factory method.<br>在创建者的代码中，找到对产品构造函数的所有引用。将它们逐个替换为对工厂方法的调用，同时将产品创建代码提取到工厂方法中。</p>
</li>
</ul>
<p>You might need to add a temporary parameter to the factory method to control the type of returned product.<br>您可能需要向工厂方法添加临时参数，以控制返回产品的类型。</p>
<p>At this point, the code of the factory method may look pretty ugly. It may have a large <code>switch</code> statement that picks which product class to instantiate. But don’t worry, we’ll fix it soon enough.<br>在这一点上，工厂方法的代码可能看起来很丑陋。它可能有一个大 <code>switch</code> 语句，用于选择要实例化的产品类。但别担心，我们会尽快修复它。</p>
<ul>
<li><p>Now, create a set of creator subclasses for each type of product listed in the factory method. Override the factory method in the subclasses and extract the appropriate bits of construction code from the base method.<br>现在，为 factory 方法中列出的每种类型的产品创建一组创建者子类。重写子类中的工厂方法，并从基方法中提取适当的构造代码位。</p>
</li>
<li><p>If there are too many product types and it doesn’t make sense to create subclasses for all of them, you can reuse the control parameter from the base class in subclasses.<br>如果产品类型太多，并且为所有产品类型创建子类没有意义，则可以在子类中重用基类中的控制参数。</p>
</li>
</ul>
<p>For instance, imagine that you have the following hierarchy of classes: the base <code>Mail</code> class with a couple of subclasses: <code>AirMail</code> and <code>GroundMail</code>; the <code>Transport</code> classes are <code>Plane</code>, <code>Truck</code> and <code>Train</code>. While the <code>AirMail</code> class only uses <code>Plane</code> objects, <code>GroundMail</code> may work with both <code>Truck</code> and <code>Train</code> objects. You can create a new subclass (say <code>TrainMail</code>) to handle both cases, but there’s another option. The client code can pass an argument to the factory method of the <code>GroundMail</code> class to control which product it wants to receive.<br>例如，假设您有以下类层次结构：具有几个子类的基 <code>Mail</code> 类： <code>AirMail</code> 和 <code>GroundMail</code> ; <code>Transport</code> 这些类是 <code>Plane</code>,  <code>Truck</code>和 <code>Train</code> 。虽然该 <code>AirMail</code> 类仅使用 <code>Plane</code> 对象， <code>GroundMail</code> 但可以同时 <code>Truck</code> 使用和 <code>Train</code> 对象。您可以创建一个新的子类（例如 <code>TrainMail</code> ）来处理这两种情况，但还有另一种选择。客户端代码可以将参数传递给 <code>GroundMail</code> 类的工厂方法，以控制它要接收的产品。</p>
<ul>
<li>If, after all of the extractions, the base factory method has become empty, you can make it abstract. If there’s something left, you can make it a default behavior of the method.<br>如果在所有提取之后，基本工厂方法已变为空，则可以将其抽象化。如果还剩下一些东西，可以将其设置为方法的默认行为。</li>
</ul>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><h4 id="Pros-优点"><a href="#Pros-优点" class="headerlink" title="Pros 优点"></a>Pros 优点</h4><ul>
<li>You avoid tight coupling between the creator and the concrete products.<br>您可以避免创建者和具体产品之间的紧密耦合。</li>
<li>Single Responsibility Principle. You can move the product creation code into one place in the program, making the code easier to support.<br>单一责任原则。您可以将产品创建代码移动到程序中的一个位置，使代码更易于支持。</li>
<li>Open&#x2F;Closed Principle. You can introduce new types of products into the program without breaking existing client code.<br>开&#x2F;闭原理。您可以在不破坏现有客户端代码的情况下将新类型的产品引入程序。</li>
</ul>
<h4 id="Cons-缺点"><a href="#Cons-缺点" class="headerlink" title="Cons 缺点"></a>Cons 缺点</h4><p>The code may become more complicated since you need to introduce a lot of new subclasses to implement the pattern. The best case scenario is when you’re introducing the pattern into an existing hierarchy of creator classes.<br>代码可能会变得更加复杂，因为您需要引入许多新的子类来实现该模式。最好的情况是将模式引入到创建者类的现有层次结构中。</p>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).<br>许多设计从使用工厂方法（不那么复杂，通过子类更可定制）开始，然后发展到抽象工厂、原型或构建器（更灵活，但更复杂）。</p>
</li>
<li><p>Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.<br>抽象工厂类通常基于一组工厂方法，但您也可以使用 Prototype 来组合这些类的方法。</p>
</li>
<li><p>You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.<br>可以将工厂方法与迭代器一起使用，让集合子类返回与集合兼容的不同类型的迭代器。</p>
</li>
<li><p>Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.<br>原型不是基于继承的，所以它没有缺点。另一方面，Prototype 需要对克隆对象进行复杂的初始化。工厂方法基于继承，但不需要初始化步骤。</p>
</li>
<li><p>Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.<br>工厂方法是模板方法的专业化。同时，工厂方法可以作为大型模板方法中的一个步骤。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><ul>
<li><p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Creator</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Creator class declares the factory method that is supposed to return an</span></span><br><span class="line"><span class="string">    object of a Product class. The Creator&#x27;s subclasses usually provide the</span></span><br><span class="line"><span class="string">    implementation of this method.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">factory_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Note that the Creator may also provide some default implementation of</span></span><br><span class="line"><span class="string">        the factory method.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Also note that, despite its name, the Creator&#x27;s primary responsibility</span></span><br><span class="line"><span class="string">        is not creating products. Usually, it contains some core business logic</span></span><br><span class="line"><span class="string">        that relies on Product objects, returned by the factory method.</span></span><br><span class="line"><span class="string">        Subclasses can indirectly change that business logic by overriding the</span></span><br><span class="line"><span class="string">        factory method and returning a different type of product from it.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Call the factory method to create a Product object.</span></span><br><span class="line">        product = self.factory_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Now, use the product.</span></span><br><span class="line">        result = <span class="string">f&quot;Creator: The same creator&#x27;s code has just worked with <span class="subst">&#123;product.operation()&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Creators override the factory method in order to change the resulting</span></span><br><span class="line"><span class="string">product&#x27;s type.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreator1</span>(<span class="title class_ inherited__">Creator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Note that the signature of the method still uses the abstract product type,</span></span><br><span class="line"><span class="string">    even though the concrete product is actually returned from the method. This</span></span><br><span class="line"><span class="string">    way the Creator can stay independent of concrete product classes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">factory_method</span>(<span class="params">self</span>) -&gt; Product:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProduct1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreator2</span>(<span class="title class_ inherited__">Creator</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">factory_method</span>(<span class="params">self</span>) -&gt; Product:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProduct2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Product interface declares the operations that all concrete products</span></span><br><span class="line"><span class="string">    must implement.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Products provide various implementations of the Product interface.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span>(<span class="title class_ inherited__">Product</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;Result of the ConcreteProduct1&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span>(<span class="title class_ inherited__">Product</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;Result of the ConcreteProduct2&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">creator: Creator</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code works with an instance of a concrete creator, albeit through</span></span><br><span class="line"><span class="string">    its base interface. As long as the client keeps working with the creator via</span></span><br><span class="line"><span class="string">    the base interface, you can pass it any creator&#x27;s subclass.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Client: I&#x27;m not aware of the creator&#x27;s class, but it still works.\n&quot;</span></span><br><span class="line">          <span class="string">f&quot;<span class="subst">&#123;creator.some_operation()&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;App: Launched with the ConcreteCreator1.&quot;</span>)</span><br><span class="line">    client_code(ConcreteCreator1())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;App: Launched with the ConcreteCreator2.&quot;</span>)</span><br><span class="line">    client_code(ConcreteCreator2())</span><br></pre></td></tr></table></figure>
<p><strong>Output.txt: Execution result</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">App: Launched <span class="keyword">with</span> the ConcreteCreator1.</span><br><span class="line">Client: I<span class="string">&#x27;m not aware of the creator&#x27;</span>s <span class="keyword">class</span>, but it still works.</span><br><span class="line">Creator: The same creato<span class="string">r&#x27;s code has just worked with &#123;Result of the ConcreteProduct1&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">App: Launched with the ConcreteCreator2.</span></span><br><span class="line"><span class="string">Client: I&#x27;</span>m <span class="keyword">not</span> aware of the creato<span class="string">r&#x27;s class, but it still works.</span></span><br><span class="line"><span class="string">Creator: The same creator&#x27;</span>s code has just worked <span class="keyword">with</span> &#123;Result of the ConcreteProduct2&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>Rust<br><strong>gui.rs:Prodcut &amp; Creator</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_click</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Dialog has a factory method `create_button`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// It creates different buttons depending on a factory implementation.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Dialog</span> &#123;</span><br><span class="line">    <span class="comment">/// The factory method. It must be overridden with a concrete implementation.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Button&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">button</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">        button.<span class="title function_ invoke__">render</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">refresh</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dialog - Refresh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>html_gui.rs: Concrete creator</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::gui::&#123;Button, Dialog&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HtmlButton</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Button</span> <span class="keyword">for</span> <span class="title class_">HtmlButton</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&lt;button&gt;Test Button&lt;/button&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">on_click</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_click</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Click! Button says - &#x27;Hello World!&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HtmlDialog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dialog</span> <span class="keyword">for</span> <span class="title class_">HtmlDialog</span> &#123;</span><br><span class="line">    <span class="comment">/// Creates an HTML button.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Button&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(HtmlButton)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>windows_gui.rs: Another concrete creator</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::gui::&#123;Button, Dialog&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WindowsButton</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Button</span> <span class="keyword">for</span> <span class="title class_">WindowsButton</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Drawing a Windows button&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">on_click</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_click</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Click! Hello, Windows!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WindowsDialog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dialog</span> <span class="keyword">for</span> <span class="title class_">WindowsDialog</span> &#123;</span><br><span class="line">    <span class="comment">/// Creates a Windows button.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Button&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(WindowsButton)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>init.rs: Initialization code</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::gui::Dialog;</span><br><span class="line"><span class="keyword">use</span> crate::html_gui::HtmlDialog;</span><br><span class="line"><span class="keyword">use</span> crate::windows_gui::WindowsDialog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">initialize</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">dyn</span> Dialog &#123;</span><br><span class="line">    <span class="comment">// The dialog type is selected depending on the environment settings or configuration.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cfg!</span>(windows) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;-- Windows detected, creating Windows GUI --&quot;</span>);</span><br><span class="line">        &amp;WindowsDialog</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;-- No OS detected, creating the HTML GUI --&quot;</span>);</span><br><span class="line">        &amp;HtmlDialog</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main.rs: Client code main.rs</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> gui;</span><br><span class="line"><span class="keyword">mod</span> html_gui;</span><br><span class="line"><span class="keyword">mod</span> init;</span><br><span class="line"><span class="keyword">mod</span> windows_gui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> init::initialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// The rest of the code doesn&#x27;t depend on specific dialog types, because</span></span><br><span class="line">    <span class="comment">// it works with all dialog objects via the abstract `Dialog` trait</span></span><br><span class="line">    <span class="comment">// which is defined in the `gui` module.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dialog</span> = <span class="title function_ invoke__">initialize</span>();</span><br><span class="line">    dialog.<span class="title function_ invoke__">render</span>();</span><br><span class="line">    dialog.<span class="title function_ invoke__">refresh</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Output</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;Test Button&lt;/button&gt;</span><br><span class="line">Click! Button says - <span class="symbol">&#x27;Hello</span> World!&#x27;</span><br><span class="line">Dialog - Refresh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>History of patterns</title>
    <url>/2023/11/14/design-pattern/history-of-patterns/</url>
    <content><![CDATA[<h1 id="History-of-patterns"><a href="#History-of-patterns" class="headerlink" title="History of patterns"></a>History of patterns</h1><h1 id="模式的历史"><a href="#模式的历史" class="headerlink" title="模式的历史"></a>模式的历史</h1><p>Who invented patterns? That’s a good, but not a very accurate, question. Design patterns aren’t obscure, sophisticated concepts—quite the opposite. Patterns are typical solutions to common problems in object-oriented design. When a solution gets repeated over and over in various projects, someone eventually puts a name to it and describes the solution in detail. That’s basically how a pattern gets discovered.<br>谁发明了模式？这是一个很好的问题，但不是很准确。设计模式不是晦涩难懂的复杂概念，恰恰相反。模式是面向对象设计中常见问题的典型解决方案。当一个解决方案在各种项目中一遍又一遍地重复时，最终会有人给它起一个名字并详细描述该解决方案。这基本上就是发现模式的方式。</p>
<p>The concept of patterns was first described by Christopher Alexander in A Pattern Language: Towns, Buildings, Construction. The book describes a “language” for designing the urban environment. The units of this language are patterns. They may describe how high windows should be, how many levels a building should have, how large green areas in a neighborhood are supposed to be, and so on.<br>模式的概念最早由克里斯托弗·亚历山大（Christopher Alexander）在《模式语言：城镇、建筑、建筑》中描述。该书描述了一种设计城市环境的“语言”。这种语言的单位是模式。它们可能会描述窗户应该有多高，建筑物应该有多少层，社区中的绿地应该有多大，等等。</p>
<p>The idea was picked up by four authors: Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm. In 1994, they published Design Patterns: Elements of Reusable Object-Oriented Software, in which they applied the concept of design patterns to programming. The book featured 23 patterns solving various problems of object-oriented design and became a best-seller very quickly. Due to its lengthy name, people started to call it “the book by the gang of four” which was soon shortened to simply “the GoF book”.<br>这个想法被四位作者采纳：Erich Gamma、John Vlissides、Ralph Johnson 和 Richard Helm。1994 年，他们出版了《设计模式：可重用面向对象软件的元素》，其中他们将设计模式的概念应用于编程。该书收录了 23 种模式，解决了面向对象设计的各种问题，并很快成为畅销书。由于名字很长，人们开始称它为“四人团的书”，很快就简称为《The GoF book》。</p>
<p>Since then, dozens of other object-oriented patterns have been discovered. The “pattern approach” became very popular in other programming fields, so lots of other patterns now exist outside of object-oriented design as well.<br>从那时起，已经发现了许多其他面向对象的模式。“模式方法”在其他编程领域变得非常流行，因此在面向对象设计之外也存在许多其他模式。</p>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Flyweight 享元模式</title>
    <url>/2024/01/30/design-pattern/flyweight/</url>
    <content><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>Flyweight是一种结构化的设计模式，通过在多个对象之间共享状态的公共部分，而不是保留每个对象中的所有数据，可以将更多的对象放入可用的RAM中。</p>
<div align="center"> <img src="/images/flyweight.png"/></div>


<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为了在长时间的工作后找点乐子，你决定创建一个简单的视频游戏：玩家在地图上移动并互相射击。您选择实现一个逼真的粒子系统，并使其成为游戏的独特功能。大量的子弹、导弹和爆炸产生的弹片应该在地图上到处飞，给玩家带来惊心动魄的体验。</p>
<p>完成后，你推送了最后一次提交，构建了游戏并将其发送给你的朋友进行测试。虽然游戏在你的机器上运行得很顺利，但你的朋友不能玩很长时间。在他的电脑上，游戏在玩了几分钟后就不断崩溃。在花了几个小时挖掘调试日志后，您发现游戏崩溃是因为RAM不足。原来你朋友的钻机比你自己的电脑功能差得多，这就是为什么问题在他的机器上出现得这么快。</p>
<p>实际的问题与你的粒子系统有关。每一个粒子，比如一颗子弹、一枚导弹或一块弹片，都由一个包含大量数据的单独对象来表示。在某些时候，当玩家屏幕上的大屠杀达到高潮时，新创建的粒子不再适合剩余的RAM，因此程序崩溃。</p>
<div align="center"> <img src="/images/flyweight-problem-en.png"/></div>


<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>仔细查看 仔细查看 <code>Particle</code> 类，您可能会注意到color和sprite字段比其他字段占用更多的内存。更糟糕的是，这两个字段存储的所有粒子的数据几乎相同。例如，所有项目符号都具有相同的颜色和子画面。 类，您可能会注意到color和sprite字段比其他字段占用更多的内存。更糟糕的是，这两个字段存储的所有粒子的数据几乎相同。例如，所有项目符号都具有相同的颜色和子画面。</p>
<div align="center"> <img src="/images/flyweight-solution1-en.png"/></div>


<p>粒子状态的其他部分，如坐标、运动矢量和速度，对于每个粒子都是唯一的。毕竟，这些字段的值会随着时间的推移而变化。该数据表示粒子存在的始终变化的上下文，而每个粒子的颜色和子画面保持不变。</p>
<p>对象的这种恒定数据通常称为固有状态。它存在于物体内部;其他对象只能读取它，而不能改变它。对象的其余状态，通常被其他对象“从外部”改变，称为外部状态。</p>
<p>Flyweight模式建议您停止在对象内部存储外部状态。相反，你应该把这个状态传递给依赖它的特定方法。只有内在状态留在对象中，让你在不同的上下文中重用它。因此，您需要更少的这些对象，因为它们只在内在状态上有所不同，而内在状态的变化要比外在状态少得多。</p>
<div align="center"> <img src="/images/flyweight-solution3.png"/></div>


<p>让我们回到我们的游戏。假设我们已经从粒子类中提取了外部状态，那么只有三个不同的对象就足以代表游戏中的所有粒子：一颗子弹、一枚导弹和一块弹片。正如你现在可能已经猜到的，一个只存储固有状态的对象被称为flyweight。</p>
<h4 id="外部状态存储器"><a href="#外部状态存储器" class="headerlink" title="外部状态存储器"></a>外部状态存储器</h4><p>外在的状态向何处去？一些类应该仍然存储它，对吗？在大多数情况下，它会被移动到容器对象中，容器对象在我们应用模式之前聚合对象。</p>
<p>在我们的例子中，这是主要的 在我们的例子中，这是主要的 <code>Game</code> 对象，它将所有粒子存储在  对象，它将所有粒子存储在  对象，它将所有粒子存储在 <code>particles</code> 场中。要将外部状态移动到这个类中，需要创建几个数组字段来存储每个粒子的坐标、向量和速度。但这还不是全部。您需要另一个数组来存储对表示粒子的特定flyweight的引用。这些数组必须同步，以便您可以使用相同的索引访问粒子的所有数据。 场中。要将外部状态移动到这个类中，需要创建几个数组字段来存储每个粒子的坐标、向量和速度。但这还不是全部。您需要另一个数组来存储对表示粒子的特定flyweight的引用。这些数组必须同步，以便您可以使用相同的索引访问粒子的所有数据。</p>
<div align="center"> <img src="/images/flyweight-solution4.png"/></div>


<p>一个更优雅的解决方案是创建一个单独的上下文类，它将存储外部状态沿着对flyweight对象的引用。这种方法只需要容器类中有一个数组。</p>
<p>等一下！难道我们不需要像一开始那样，有很多这样的上下文对象吗？严格来说是的但问题是，这些物体比以前小得多。最消耗内存的字段已经被移到几个flyweight对象中。现在，1000个小的上下文对象可以重用一个重flyweight对象，而不是存储其数据的1000个副本。</p>
<h4 id="Flyweight和不变性"><a href="#Flyweight和不变性" class="headerlink" title="Flyweight和不变性"></a>Flyweight和不变性</h4><p>由于同一个flyweight对象可以在不同的上下文中使用，因此必须确保其状态不能被修改。一个flyweight应该只初始化它的状态一次，通过构造函数参数。它不应该向其他对象公开任何setter或公共字段。</p>
<h4 id="Flyweight工厂"><a href="#Flyweight工厂" class="headerlink" title="Flyweight工厂"></a>Flyweight工厂</h4><p>为了更方便地访问各种flyweight，您可以创建一个工厂方法来管理现有flyweight对象的池。该方法从客户端接受所需flyweight的内部状态，查找与此状态匹配的现有flyweight对象，如果找到则返回它。如果没有，则创建一个新的flyweight并将其添加到池中。</p>
<p>有几种选择可以放置这种方法。最明显的地方是flyweight容器。或者，您可以创建一个新的工厂类。或者你可以让工厂方法静态化，并把它放在一个实际的flyweight类中。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><div align="center"> <img src="/images/flyweight-structure.png"/></div>


<ol>
<li>Flyweight模式仅仅是一种优化。在应用它之前，请确保您的程序确实存在与内存中同时存在大量类似对象相关的RAM消耗问题。确保这个问题不能以任何其他有意义的方式解决。</li>
<li>Flyweight类包含原始对象的状态中可以在多个对象之间共享的部分。同一个flyweight对象可以在许多不同的上下文中使用。存储在flyweight中的状态称为intrinsic。传递给flyweight方法的状态称为extrinsic。</li>
<li>Context类包含外部状态，在所有原始对象中是唯一的。当上下文与其中一个flyweight对象配对时，它表示原始对象的完整状态。</li>
<li>通常，原始对象的行为保留在flyweight类中。在这种情况下，无论谁调用flyweight的方法，都必须将外部状态的适当位传递到方法的参数中。另一方面，行为可以被移动到上下文类，它将链接的flyweight仅仅作为一个数据对象。</li>
<li>客户端计算或存储flyweights的外部状态。从客户端的角度来看，flyweight是一个模板对象，可以在运行时通过将一些上下文数据传递到其方法的参数中进行配置。</li>
<li>Flyweight Factory管理现有的Flyweight。使用工厂，客户不直接创建flyweights。相反，它们调用工厂，向其传递所需flyweight的内部状态位。工厂检查以前创建的flyweights，并返回一个与搜索条件匹配的现有flyweights，或者如果没有找到任何内容，则创建一个新的flyweights。</li>
</ol>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>在本例中，Flyweight模式有助于在画布上渲染数百万个树对象时减少内存使用。</p>
<div align="center"> <img src="/images/flyweight-example.png"/></div>


<p>该模式从主类 该模式从主类 <code>Tree</code> 中提取重复的固有状态，并将其移动到flyweight类  中提取重复的固有状态，并将其移动到flyweight类  中提取重复的固有状态，并将其移动到flyweight类 <code>TreeType</code> 中。</p>
<p>现在，不再将相同的数据存储在多个对象中，而是将其保存在几个flyweight对象中，并链接到适当的 现在，不再将相同的数据存储在多个对象中，而是将其保存在几个flyweight对象中，并链接到适当的 <code>Tree</code> 对象，这些对象充当上下文。客户端代码使用flyweight工厂创建新的树对象，该工厂封装了搜索正确对象并在需要时重用它的复杂性。 对象，这些对象充当上下文。客户端代码使用flyweight工厂创建新的树对象，该工厂封装了搜索正确对象并在需要时重用它的复杂性。</p>
<p>现在，不再将相同的数据存储在多个对象中，而是将其保存在几个flyweight对象中，并链接到适当的 现在，不再将相同的数据存储在多个对象中，而是将其保存在几个flyweight对象中，并链接到适当的 <code>Tree</code> 对象，这些对象充当上下文。客户端代码使用flyweight工厂创建新的树对象，该工厂封装了搜索正确对象并在需要时重用它的复杂性。 对象，这些对象充当上下文。客户端代码使用flyweight工厂创建新的树对象，该工厂封装了搜索正确对象并在需要时重用它的复杂性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The flyweight class contains a portion of the state of a</span></span><br><span class="line"><span class="comment">// tree. These fields store values that are unique for each</span></span><br><span class="line"><span class="comment">// particular tree. For instance, you won&#x27;t find here the tree</span></span><br><span class="line"><span class="comment">// coordinates. But the texture and colors shared between many</span></span><br><span class="line"><span class="comment">// trees are here. Since this data is usually BIG, you&#x27;d waste a</span></span><br><span class="line"><span class="comment">// lot of memory by keeping it in each tree object. Instead, we</span></span><br><span class="line"><span class="comment">// can extract texture, color and other repeating data into a</span></span><br><span class="line"><span class="comment">// separate object which lots of individual tree objects can</span></span><br><span class="line"><span class="comment">// reference.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeType</span> is</span><br><span class="line">    field name</span><br><span class="line">    field color</span><br><span class="line">    field texture</span><br><span class="line">    constructor <span class="title function_">TreeType</span><span class="params">(name, color, texture)</span> &#123; ... &#125;</span><br><span class="line">    method <span class="title function_">draw</span><span class="params">(canvas, x, y)</span> is</span><br><span class="line">        <span class="comment">// 1. Create a bitmap of a given type, color &amp; texture.</span></span><br><span class="line">        <span class="comment">// 2. Draw the bitmap on the canvas at X and Y coords.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flyweight factory decides whether to re-use existing</span></span><br><span class="line"><span class="comment">// flyweight or to create a new object.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeFactory</span> is</span><br><span class="line">    <span class="keyword">static</span> field treeTypes: collection of tree types</span><br><span class="line">    <span class="keyword">static</span> method <span class="title function_">getTreeType</span><span class="params">(name, color, texture)</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">type</span> <span class="operator">=</span> treeTypes.find(name, color, texture)</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>)</span><br><span class="line">            type = <span class="keyword">new</span> <span class="title class_">TreeType</span>(name, color, texture)</span><br><span class="line">            treeTypes.add(type)</span><br><span class="line">        <span class="keyword">return</span> type</span><br><span class="line"></span><br><span class="line"><span class="comment">// The contextual object contains the extrinsic part of the tree</span></span><br><span class="line"><span class="comment">// state. An application can create billions of these since they</span></span><br><span class="line"><span class="comment">// are pretty small: just two integer coordinates and one</span></span><br><span class="line"><span class="comment">// reference field.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span> is</span><br><span class="line">    field x,y</span><br><span class="line">    field type: TreeType</span><br><span class="line">    constructor <span class="title function_">Tree</span><span class="params">(x, y, type)</span> &#123; ... &#125;</span><br><span class="line">    method <span class="title function_">draw</span><span class="params">(canvas)</span> is</span><br><span class="line">        type.draw(canvas, <span class="built_in">this</span>.x, <span class="built_in">this</span>.y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The Tree and the Forest classes are the flyweight&#x27;s clients.</span></span><br><span class="line"><span class="comment">// You can merge them if you don&#x27;t plan to develop the Tree</span></span><br><span class="line"><span class="comment">// class any further.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Forest</span> is</span><br><span class="line">    field trees: collection of Trees</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">plantTree</span><span class="params">(x, y, name, color, texture)</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">type</span> <span class="operator">=</span> TreeFactory.getTreeType(name, color, texture)</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">Tree</span>(x, y, type)</span><br><span class="line">        trees.add(tree)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">draw</span><span class="params">(canvas)</span> is</span><br><span class="line">        <span class="title function_">foreach</span> <span class="params">(tree in trees)</span> <span class="keyword">do</span></span><br><span class="line">            tree.draw(canvas)</span><br></pre></td></tr></table></figure>

<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ul>
<li><p><strong>只有当你的程序必须支持大量的对象，而这些对象几乎不能容纳在可用的RAM中时，才使用Flyweight模式。</strong></p>
</li>
<li><p>应用该模式的好处在很大程度上取决于如何以及在何处使用它。它在以下情况下最有用：</p>
<ul>
<li>应用程序需要产生大量的类似对象</li>
<li>这会耗尽目标设备上的所有可用RAM</li>
<li>对象包含可以在多个对象之间提取和共享的重复状态</li>
</ul>
</li>
</ul>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><ol>
<li><p>将一个类的字段分成两部分，这两部分将成为一个flyweight：</p>
<ul>
<li>内部状态：包含跨多个对象复制的不变数据的字段</li>
<li>外部状态：包含每个对象唯一的上下文数据的字段</li>
</ul>
</li>
<li><p>将表示内部状态的字段保留在类中，但要确保它们是不可变的。它们应该只在构造函数内部取初始值。</p>
</li>
<li><p>检查使用外部状态字段的方法。对于方法中使用的每个字段，引入一个新参数并使用它来代替字段。</p>
</li>
<li><p>或者，创建一个工厂类来管理flyweights池。它应该在创建新的flyweight之前检查现有的flyweight。一旦工厂到位，客户端必须通过它请求flyweight。他们应该通过将其内在状态传递给工厂来描述所需的flyweight。</p>
</li>
<li><p>客户端必须存储或计算外部状态（上下文）的值，以便能够调用flyweight对象的方法。为了方便起见，可以将外部状态沿着飞权引用字段一起移动到单独的上下文类。</p>
</li>
</ol>
<h2 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h2><table>
<thead>
<tr>
<th>利√</th>
<th>弊×</th>
</tr>
</thead>
<tbody><tr>
<td>你可以保存大量的RAM，假设你的程序有很多类似的对象。</td>
<td>当每次有人调用flyweight方法时都需要重新计算一些上下文数据时，您可能会在CPU周期上牺牲RAM。</td>
</tr>
<tr>
<td></td>
<td>代码变得更加复杂。新的团队成员总是想知道为什么实体的状态以这种方式分离。</td>
</tr>
</tbody></table>
<h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li><p>您可以将复合树的共享叶节点实现为Flyweights，以保存一些RAM。</p>
</li>
<li><p>Flyweight展示了如何制作许多小对象，而Facade展示了如何制作代表整个子系统的单个对象。</p>
</li>
<li><p>如果你设法将对象的所有共享状态减少到一个flyweight对象，那么Flyweight就类似于Singleton。但这些模式之间有两个根本区别：</p>
<ul>
<li>应该只有一个Singleton实例，而Flyweight类可以有多个具有不同内部状态的实例。</li>
<li>Singleton对象可以是可变的。Flyweight对象是不可变的。</li>
</ul>
</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h1 id="Python中的Flyweight模式"><a href="#Python中的Flyweight模式" class="headerlink" title="Python中的Flyweight模式"></a>Python中的Flyweight模式</h1><p>Flyweight是一种结构化设计模式，它允许程序通过保持低内存消耗来支持大量对象。</p>
<p>该模式通过在多个对象之间共享对象状态的一部分来实现。换句话说，Flyweight通过缓存不同对象使用的相同数据来节省RAM。</p>
<h2 id="概念示例"><a href="#概念示例" class="headerlink" title="概念示例"></a>概念示例</h2><p>这个例子说明了Flyweight设计模式的结构。它侧重于回答这些问题：</p>
<ul>
<li>它由哪些类组成？</li>
<li>这些班级扮演什么角色？</li>
<li>模式中的元素是以什么方式联系在一起的？</li>
</ul>
<h4 id="main-py：概念性示例"><a href="#main-py：概念性示例" class="headerlink" title="main.py：概念性示例"></a>main.py：概念性示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flyweight</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Flyweight stores a common portion of the state (also called intrinsic</span></span><br><span class="line"><span class="string">    state) that belongs to multiple real business entities. The Flyweight</span></span><br><span class="line"><span class="string">    accepts the rest of the state (extrinsic state, unique for each entity) via</span></span><br><span class="line"><span class="string">    its method parameters.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, shared_state: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._shared_state = shared_state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self, unique_state: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        s = json.dumps(self._shared_state)</span><br><span class="line">        u = json.dumps(unique_state)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Flyweight: Displaying shared (<span class="subst">&#123;s&#125;</span>) and unique (<span class="subst">&#123;u&#125;</span>) state.&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightFactory</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Flyweight Factory creates and manages the Flyweight objects. It ensures</span></span><br><span class="line"><span class="string">    that flyweights are shared correctly. When the client requests a flyweight,</span></span><br><span class="line"><span class="string">    the factory either returns an existing instance or creates a new one, if it</span></span><br><span class="line"><span class="string">    doesn&#x27;t exist yet.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _flyweights: <span class="type">Dict</span>[<span class="built_in">str</span>, Flyweight] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initial_flyweights: <span class="type">Dict</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> initial_flyweights:</span><br><span class="line">            self._flyweights[self.get_key(state)] = Flyweight(state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_key</span>(<span class="params">self, state: <span class="type">Dict</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns a Flyweight&#x27;s string hash for a given state.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;_&quot;</span>.join(<span class="built_in">sorted</span>(state))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_flyweight</span>(<span class="params">self, shared_state: <span class="type">Dict</span></span>) -&gt; Flyweight:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns an existing Flyweight with a given state or creates a new one.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        key = self.get_key(shared_state)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._flyweights.get(key):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;FlyweightFactory: Can&#x27;t find a flyweight, creating new one.&quot;</span>)</span><br><span class="line">            self._flyweights[key] = Flyweight(shared_state)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;FlyweightFactory: Reusing existing flyweight.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self._flyweights[key]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list_flyweights</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        count = <span class="built_in">len</span>(self._flyweights)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;FlyweightFactory: I have <span class="subst">&#123;count&#125;</span> flyweights:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, self._flyweights.keys())), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_car_to_police_database</span>(<span class="params"></span></span><br><span class="line"><span class="params">    factory: FlyweightFactory, plates: <span class="built_in">str</span>, owner: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    brand: <span class="built_in">str</span>, model: <span class="built_in">str</span>, color: <span class="built_in">str</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n\nClient: Adding a car to database.&quot;</span>)</span><br><span class="line">    flyweight = factory.get_flyweight([brand, model, color])</span><br><span class="line">    <span class="comment"># The client code either stores or calculates extrinsic state and passes it</span></span><br><span class="line">    <span class="comment"># to the flyweight&#x27;s methods.</span></span><br><span class="line">    flyweight.operation([plates, owner])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code usually creates a bunch of pre-populated flyweights in the</span></span><br><span class="line"><span class="string">    initialization stage of the application.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    factory = FlyweightFactory([</span><br><span class="line">        [<span class="string">&quot;Chevrolet&quot;</span>, <span class="string">&quot;Camaro2018&quot;</span>, <span class="string">&quot;pink&quot;</span>],</span><br><span class="line">        [<span class="string">&quot;Mercedes Benz&quot;</span>, <span class="string">&quot;C300&quot;</span>, <span class="string">&quot;black&quot;</span>],</span><br><span class="line">        [<span class="string">&quot;Mercedes Benz&quot;</span>, <span class="string">&quot;C500&quot;</span>, <span class="string">&quot;red&quot;</span>],</span><br><span class="line">        [<span class="string">&quot;BMW&quot;</span>, <span class="string">&quot;M5&quot;</span>, <span class="string">&quot;red&quot;</span>],</span><br><span class="line">        [<span class="string">&quot;BMW&quot;</span>, <span class="string">&quot;X6&quot;</span>, <span class="string">&quot;white&quot;</span>],</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    factory.list_flyweights()</span><br><span class="line"></span><br><span class="line">    add_car_to_police_database(</span><br><span class="line">        factory, <span class="string">&quot;CL234IR&quot;</span>, <span class="string">&quot;James Doe&quot;</span>, <span class="string">&quot;BMW&quot;</span>, <span class="string">&quot;M5&quot;</span>, <span class="string">&quot;red&quot;</span>)</span><br><span class="line"></span><br><span class="line">    add_car_to_police_database(</span><br><span class="line">        factory, <span class="string">&quot;CL234IR&quot;</span>, <span class="string">&quot;James Doe&quot;</span>, <span class="string">&quot;BMW&quot;</span>, <span class="string">&quot;X1&quot;</span>, <span class="string">&quot;red&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    factory.list_flyweights()</span><br></pre></td></tr></table></figure>

<h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FlyweightFactory: I have 5 flyweights:</span><br><span class="line">Camaro2018_Chevrolet_pink</span><br><span class="line">C300_Mercedes Benz_black</span><br><span class="line">C500_Mercedes Benz_red</span><br><span class="line">BMW_M5_red</span><br><span class="line">BMW_X6_white</span><br><span class="line"></span><br><span class="line">Client: Adding a car to database.</span><br><span class="line">FlyweightFactory: Reusing existing flyweight.</span><br><span class="line">Flyweight: Displaying shared ([&quot;BMW&quot;, &quot;M5&quot;, &quot;red&quot;]) and unique ([&quot;CL234IR&quot;, &quot;James Doe&quot;]) state.</span><br><span class="line"></span><br><span class="line">Client: Adding a car to database.</span><br><span class="line">FlyweightFactory: Can&#x27;t find a flyweight, creating new one.</span><br><span class="line">Flyweight: Displaying shared ([&quot;BMW&quot;, &quot;X1&quot;, &quot;red&quot;]) and unique ([&quot;CL234IR&quot;, &quot;James Doe&quot;]) state.</span><br><span class="line"></span><br><span class="line">FlyweightFactory: I have 6 flyweights:</span><br><span class="line">Camaro2018_Chevrolet_pink</span><br><span class="line">C300_Mercedes Benz_black</span><br><span class="line">C500_Mercedes Benz_red</span><br><span class="line">BMW_M5_red</span><br><span class="line">BMW_X6_white</span><br><span class="line">BMW_X1_red</span><br></pre></td></tr></table></figure>

<h1 id="Rust中的Flyweight模式"><a href="#Rust中的Flyweight模式" class="headerlink" title="Rust中的Flyweight模式"></a>Rust中的Flyweight模式</h1><p>Flyweight是一种结构化设计模式，它允许程序通过保持低内存消耗来支持大量对象。</p>
<p>该模式通过在多个对象之间共享对象状态的一部分来实现。换句话说，Flyweight通过缓存不同对象使用的相同数据来节省RAM。</p>
<h2 id="字符的Flyweight"><a href="#字符的Flyweight" class="headerlink" title="字符的Flyweight"></a>字符的Flyweight</h2><p>在这个例子中，我们将为字符创建一个Flyweight模式，在这个模式中我们共享共同的字符对象以保存内存。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Flyweight Character trait</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Character implementation</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConcreteCharacter</span> &#123;</span><br><span class="line">    symbol: <span class="type">char</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Character</span> <span class="keyword">for</span> <span class="title class_">ConcreteCharacter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Character: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.symbol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flyweight factory for characters</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CharacterFactory</span> &#123;</span><br><span class="line">    characters: std::collections::HashMap&lt;<span class="type">char</span>, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Character&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">CharacterFactory</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        CharacterFactory &#123;</span><br><span class="line">            characters: std::collections::HashMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_character</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, symbol: <span class="type">char</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Character&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.characters</span><br><span class="line">            .<span class="title function_ invoke__">entry</span>(symbol)</span><br><span class="line">            .<span class="title function_ invoke__">or_insert</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(ConcreteCharacter &#123; symbol &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">character_factory</span> = CharacterFactory::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_a</span> = character_factory.<span class="title function_ invoke__">get_character</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_b</span> = character_factory.<span class="title function_ invoke__">get_character</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_a2</span> = character_factory.<span class="title function_ invoke__">get_character</span>(<span class="string">&#x27;A&#x27;</span>); <span class="comment">// Reusing &#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line">    char_a.<span class="title function_ invoke__">display</span>();</span><br><span class="line">    char_b.<span class="title function_ invoke__">display</span>();</span><br><span class="line">    char_a2.<span class="title function_ invoke__">display</span>(); <span class="comment">// The same instance as &#x27;A&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<p>我们定义了一个包含 我们定义了一个包含 <code>display</code> 方法的  方法的  方法的 <code>Character</code> trait。</p>
<p><code>ConcreteCharacter</code> 结构体实现了  结构体实现了  结构体实现了 <code>Character</code> trait，并表示一个具体的字符对象。 trait，并表示一个具体的字符对象。</p>
<p><code>CharacterFactory</code> 结构体充当一个flyweight工厂，用于创建和管理角色对象。它使用HashMap来存储共享的角色对象。 结构体充当一个flyweight工厂，用于创建和管理角色对象。它使用HashMap来存储共享的角色对象。</p>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>iterator 迭代器模式</title>
    <url>/2024/02/19/design-pattern/iterator/</url>
    <content><![CDATA[<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent  意图"></a>Intent  意图</h2><p>迭代器是一种行为设计模式，它允许您遍历集合的元素，而不暴露其底层表示（列表、堆栈、树等）。</p>
<div align="center"> <img src="/images/iterator-header.png"/></div>


<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem  问题"></a>Problem  问题</h2><p>集合是编程中最常用的数据类型之一。尽管如此，集合只是一组对象的容器。</p>
<div align="center"> <img src="/images/iterator-problem1.png"/>各种类型的集合</div>


<p>大多数集合将它们的元素存储在简单的列表中。然而，其中一些是基于堆栈，树，图和其他复杂的数据结构。</p>
<p>但无论集合是如何构造的，它都必须提供某种访问其元素的方法，以便其他代码可以使用这些元素。应该有一种方法可以遍历集合中的每个元素，而不必反复访问相同的元素。</p>
<p>如果你有一个基于列表的集合，这听起来可能是一个简单的工作。你只需遍历所有元素。但是，如何顺序遍历复杂数据结构（如树）的元素呢？例如，有一天您可能会很好地使用深度优先遍历树。但是第二天你可能需要广度优先遍历。接下来的一周，你可能需要一些其他的东西，比如对树元素的随机访问。</p>
<div align="center"> <img src="/images/iterator-problem2.png"/>同一个集合可以用几种不同的方式遍历。</div>


<p>向集合中添加越来越多的遍历算法逐渐模糊了它的主要职责，即高效的数据存储。此外，有些算法可能是为特定的应用程序定制的，因此将它们包含到泛型集合类中会很奇怪。</p>
<p>另一方面，应该处理各种集合的客户端代码可能甚至不关心它们如何存储元素。但是，由于集合都提供了访问其元素的不同方式，因此除了将代码耦合到特定的集合类之外，您别无选择。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>迭代器模式的主要思想是将集合的遍历行为提取到称为迭代器的单独对象中。</p>
<div align="center"> <img src="/images/iterator-solution1.png"/>迭代器实现各种遍历算法。多个迭代器对象可以同时遍历同一个集合。</div>


<p>除了实现算法本身之外，迭代器对象还封装了所有遍历细节，比如当前位置和最后还剩多少元素。因此，多个迭代器可以同时遍历同一个集合，彼此独立。</p>
<p>通常，迭代器提供了一个获取集合元素的主要方法。客户端可以继续运行这个方法，直到它不返回任何东西，这意味着迭代器已经遍历了所有的元素。</p>
<p>所有迭代器必须实现相同的接口。这使得客户端代码与任何集合类型或任何遍历算法兼容，只要有合适的迭代器即可。如果你需要一种特殊的方法来遍历一个集合，你只需要创建一个新的迭代器类，而不必改变集合或客户端。</p>
<h2 id="Real-World-Analogy-现实世界的类比"><a href="#Real-World-Analogy-现实世界的类比" class="headerlink" title="Real-World Analogy  现实世界的类比"></a>Real-World Analogy  现实世界的类比</h2><div align="center"> <img src="/images/iterator-comic-1-en.png"/>在罗马有各种各样的步行方式。</div>


<p>另一方面，你可以为你的智能手机购买一个虚拟指南应用程序，并将其用于导航。这是智能和廉价的，你可以留在一些有趣的地方，只要你想。</p>
<p>第三种选择是，你可以花一些旅行的预算，聘请一个当地导游谁知道城市像他的手背。导游将能够根据您的喜好量身定制旅游，向您展示每一个景点，并讲述许多令人兴奋的故事。那会更有趣;但是，唉，也更贵了。</p>
<p>所有这些选项–你脑中随机产生的方向、智能手机导航器或人类向导–都是位于罗马的大量景点和景点的迭代器。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure  结构"></a>Structure  结构</h2><div align="center"> <img src="/images/iterator-structure.png"/>在罗马有各种各样的步行方式。</div>


<ol>
<li><p>Iterator接口声明了遍历集合所需的操作：获取下一个元素，检索当前位置，重新开始迭代等。</p>
</li>
<li><p>具体迭代器实现了遍历集合的特定算法。迭代器对象应该自己跟踪遍历进度。这允许多个迭代器彼此独立地遍历同一集合。</p>
</li>
<li><p>Collection接口声明了一个或多个方法来获取与集合兼容的迭代器。注意，方法的返回类型必须声明为迭代器接口，以便具体集合可以返回各种迭代器。</p>
</li>
<li><p>每次客户端请求一个具体迭代器类时，具体集合返回一个特定具体迭代器类的新实例。您可能会想，集合的其余代码在哪里？别担心，应该在同一个班级。只是这些细节对实际的模式并不重要，所以我们省略了它们。</p>
</li>
<li><p>客户端通过集合和迭代器的接口与它们一起工作。这样，客户端就不会耦合到具体的类，从而允许您在同一客户端代码中使用各种集合和迭代器。</p>
<p>通常，客户端不会自己创建迭代器，而是从集合中获取迭代器。然而，在某些情况下，客户端可以直接创建一个;例如，当客户端定义自己的特殊迭代器时。</p>
</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode  伪代码"></a>Pseudocode  伪代码</h2><p>在本例中，迭代器模式用于遍历一种特殊的集合，该集合封装了对Facebook社交图的访问。该集合提供了几个迭代器，它们可以以各种方式遍历概要文件。</p>
<div align="center"> <img src="/images/iterator-example.png"/>迭代社交配置文件的示例。</div>


<p>“friends”迭代器可用于查看给定配置文件的好友。“colleagues”迭代器做同样的事情，只是它忽略了与目标人不在同一家公司工作的朋友。这两个迭代器都实现了一个公共接口，允许客户端获取配置文件，而无需深入研究实现细节，如身份验证和发送REST请求。</p>
<p>客户端代码没有耦合到具体的类，因为它只通过接口与集合和迭代器一起工作。如果您决定将应用连接到新的社交网络，则只需提供新的集合和迭代器类，而无需更改现有代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The collection interface must declare a factory method for</span></span><br><span class="line"><span class="comment">// producing iterators. You can declare several methods if there</span></span><br><span class="line"><span class="comment">// are different kinds of iteration available in your program.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SocialNetwork</span> is</span><br><span class="line">    method <span class="title function_">createFriendsIterator</span><span class="params">(profileId)</span>:ProfileIterator</span><br><span class="line">    method <span class="title function_">createCoworkersIterator</span><span class="params">(profileId)</span>:ProfileIterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Each concrete collection is coupled to a set of concrete</span></span><br><span class="line"><span class="comment">// iterator classes it returns. But the client isn&#x27;t, since the</span></span><br><span class="line"><span class="comment">// signature of these methods returns iterator interfaces.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facebook</span> <span class="keyword">implements</span> <span class="title class_">SocialNetwork</span> is</span><br><span class="line">    <span class="comment">// ... The bulk of the collection&#x27;s code should go here ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterator creation code.</span></span><br><span class="line">    method <span class="title function_">createFriendsIterator</span><span class="params">(profileId)</span> is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FacebookIterator</span>(<span class="built_in">this</span>, profileId, <span class="string">&quot;friends&quot;</span>)</span><br><span class="line">    method <span class="title function_">createCoworkersIterator</span><span class="params">(profileId)</span> is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FacebookIterator</span>(<span class="built_in">this</span>, profileId, <span class="string">&quot;coworkers&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The common interface for all iterators.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProfileIterator</span> is</span><br><span class="line">    method <span class="title function_">getNext</span><span class="params">()</span>:Profile</span><br><span class="line">    method <span class="title function_">hasMore</span><span class="params">()</span>:bool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The concrete iterator class.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FacebookIterator</span> <span class="keyword">implements</span> <span class="title class_">ProfileIterator</span> is</span><br><span class="line">    <span class="comment">// The iterator needs a reference to the collection that it</span></span><br><span class="line">    <span class="comment">// traverses.</span></span><br><span class="line">    <span class="keyword">private</span> field facebook: Facebook</span><br><span class="line">    <span class="keyword">private</span> field profileId, type: string</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An iterator object traverses the collection independently</span></span><br><span class="line">    <span class="comment">// from other iterators. Therefore it has to store the</span></span><br><span class="line">    <span class="comment">// iteration state.</span></span><br><span class="line">    <span class="keyword">private</span> field currentPosition</span><br><span class="line">    <span class="keyword">private</span> field cache: array of Profile</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">FacebookIterator</span><span class="params">(facebook, profileId, type)</span> is</span><br><span class="line">        <span class="built_in">this</span>.facebook = facebook</span><br><span class="line">        <span class="built_in">this</span>.profileId = profileId</span><br><span class="line">        <span class="built_in">this</span>.type = type</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> method <span class="title function_">lazyInit</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(cache == <span class="literal">null</span>)</span></span><br><span class="line">            cache = facebook.socialGraphRequest(profileId, type)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Each concrete iterator class has its own implementation</span></span><br><span class="line">    <span class="comment">// of the common iterator interface.</span></span><br><span class="line">    method <span class="title function_">getNext</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(hasMore()</span>)</span><br><span class="line">            result = cache[currentPosition]</span><br><span class="line">            currentPosition++</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">hasMore</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">lazyInit</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">return</span> currentPosition &lt; cache.length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is another useful trick: you can pass an iterator to a</span></span><br><span class="line"><span class="comment">// client class instead of giving it access to a whole</span></span><br><span class="line"><span class="comment">// collection. This way, you don&#x27;t expose the collection to the</span></span><br><span class="line"><span class="comment">// client.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// And there&#x27;s another benefit: you can change the way the</span></span><br><span class="line"><span class="comment">// client works with the collection at runtime by passing it a</span></span><br><span class="line"><span class="comment">// different iterator. This is possible because the client code</span></span><br><span class="line"><span class="comment">// isn&#x27;t coupled to concrete iterator classes.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SocialSpammer</span> is</span><br><span class="line">    method <span class="title function_">send</span><span class="params">(iterator: ProfileIterator, message: string)</span> is</span><br><span class="line">        <span class="title function_">while</span> <span class="params">(iterator.hasMore()</span>)</span><br><span class="line">            profile = iterator.getNext()</span><br><span class="line">            System.sendEmail(profile.getEmail(), message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The application class configures collections and iterators</span></span><br><span class="line"><span class="comment">// and then passes them to the client code.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    field network: SocialNetwork</span><br><span class="line">    field spammer: SocialSpammer</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">config</span><span class="params">()</span> is</span><br><span class="line">        <span class="keyword">if</span> working with Facebook</span><br><span class="line">            <span class="built_in">this</span>.network = <span class="keyword">new</span> <span class="title class_">Facebook</span>()</span><br><span class="line">        <span class="keyword">if</span> working with LinkedIn</span><br><span class="line">            <span class="built_in">this</span>.network = <span class="keyword">new</span> <span class="title class_">LinkedIn</span>()</span><br><span class="line">        <span class="built_in">this</span>.spammer = <span class="keyword">new</span> <span class="title class_">SocialSpammer</span>()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">sendSpamToFriends</span><span class="params">(profile)</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">iterator</span> <span class="operator">=</span> network.createFriendsIterator(profile.getId())</span><br><span class="line">        spammer.send(iterator, <span class="string">&quot;Very important message&quot;</span>)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">sendSpamToCoworkers</span><span class="params">(profile)</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">iterator</span> <span class="operator">=</span> network.createCoworkersIterator(profile.getId())</span><br><span class="line">        spammer.send(iterator, <span class="string">&quot;Very important message&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability  适用性"></a>Applicability  适用性</h2><ul>
<li><strong>当您的集合具有复杂的数据结构时，请使用迭代器模式，但您希望对客户机隐藏其复杂性（出于方便或安全原因）。</strong></li>
<li>迭代器封装了处理复杂数据结构的细节，为客户端提供了几种访问集合元素的简单方法。虽然这种方法对客户端来说非常方便，但它也可以保护集合免受客户端在直接使用集合时可能执行的粗心或恶意操作的影响。</li>
<li><strong>使用该模式可以减少应用中重复的遍历代码。</strong></li>
<li>非平凡迭代算法的代码往往非常庞大。当放置在应用程序的业务逻辑中时，它可能会模糊原始代码的责任，并使其减少维护。将遍历代码移动到指定的迭代器可以帮助您使应用程序的代码更加精简和干净。</li>
<li><strong>当你希望你的代码能够遍历不同的数据结构，或者这些结构的类型事先是未知的时，使用迭代器。</strong></li>
<li>该模式为集合和迭代器提供了两个泛型接口。假设你的代码现在使用这些接口，如果你传递给它实现这些接口的各种集合和迭代器，它仍然可以工作。</li>
</ul>
<h2 id="How-to-Implement-如何实施"><a href="#How-to-Implement-如何实施" class="headerlink" title="How to Implement 如何实施"></a>How to Implement 如何实施</h2><ol>
<li>对迭代器接口进行Declare。至少，它必须有一个从集合中获取下一个元素的方法。但是为了方便起见，您可以添加其他一些方法，例如获取前一个元素，跟踪当前位置，以及检查迭代的结束。</li>
<li>decode集合接口并描述获取迭代器的方法。返回类型应该等于迭代器接口的返回类型。如果你计划有几个不同的迭代器组，你可以声明类似的方法。</li>
<li>为您希望使用迭代器遍历的集合实现具体的迭代器类。迭代器对象必须与单个集合实例链接。通常，这个链接是通过迭代器的构造函数建立的。</li>
<li>在集合类中实现集合接口。主要思想是为客户端提供一个创建迭代器的快捷方式，为特定的集合类定制。集合对象必须将自身传递给迭代器的构造函数，以在它们之间建立链接。</li>
<li>检查客户端代码，使用迭代器替换所有集合遍历代码。客户端每次需要遍历集合元素时都会获取一个新的迭代器对象。</li>
</ol>
<h2 id="Pros-and-Cons-利弊"><a href="#Pros-and-Cons-利弊" class="headerlink" title="Pros and Cons 利弊"></a>Pros and Cons 利弊</h2><table>
<thead>
<tr>
<th>√ 利</th>
<th>× 弊</th>
</tr>
</thead>
<tbody><tr>
<td>单一责任原则。您可以通过将庞大的遍历算法提取到单独的类中来清理客户机代码和集合。</td>
<td>如果你的应用只处理简单的集合，那么应用这种模式可能会有些矫枉过正。</td>
</tr>
<tr>
<td>开放&#x2F;封闭原则。您可以实现新类型的集合和迭代器，并将它们传递给现有代码，而不会破坏任何东西。</td>
<td>使用迭代器可能比直接遍历某些专用集合的元素效率更低。</td>
</tr>
<tr>
<td>可以并行遍历同一个集合，因为每个迭代器对象都包含自己的迭代状态。</td>
<td></td>
</tr>
<tr>
<td>出于同样的原因，您可以延迟迭代并在需要时继续它。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns"><a href="#Relations-with-Other-Patterns" class="headerlink" title="Relations with Other Patterns"></a>Relations with Other Patterns</h2><p>与其他模式的关系</p>
<ul>
<li>你可以使用迭代器来遍历复合树。</li>
<li>可以将工厂方法沿着使用迭代器，让集合子类返回与集合兼容的不同类型的迭代器。</li>
<li>您可以使用Memento沿着Iterator来捕获当前的迭代状态，并在必要时将其回滚。</li>
<li>您可以使用Visitor沿着Iterator来遍历复杂的数据结构，并对其元素执行某些操作，即使它们都具有不同的类。</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples  代码示例"></a>Code Examples  代码示例</h2><h1 id="Python中的迭代器"><a href="#Python中的迭代器" class="headerlink" title="Python中的迭代器"></a>Python中的迭代器</h1><p>迭代器是一种行为设计模式，它允许顺序遍历复杂的数据结构，而不暴露其内部细节。</p>
<h2 id="Conceptual-Example-概念示例"><a href="#Conceptual-Example-概念示例" class="headerlink" title="Conceptual Example 概念示例"></a>Conceptual Example 概念示例</h2><p>这个例子说明了迭代器设计模式的结构。它侧重于回答这些问题：</p>
<ul>
<li>它由哪些类组成？</li>
<li>这些班级扮演什么角色？</li>
<li>模式中的元素是以什么方式联系在一起的？</li>
</ul>
<h4 id="main-py：概念性示例"><a href="#main-py：概念性示例" class="headerlink" title="main.py：概念性示例"></a>main.py：概念性示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">To create an iterator in Python, there are two abstract classes from the built-</span></span><br><span class="line"><span class="string">in `collections` module - Iterable,Iterator. We need to implement the</span></span><br><span class="line"><span class="string">`__iter__()` method in the iterated object (collection), and the `__next__ ()`</span></span><br><span class="line"><span class="string">method in theiterator.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlphabeticalOrderIterator</span>(<span class="title class_ inherited__">Iterator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Concrete Iterators implement various traversal algorithms. These classes</span></span><br><span class="line"><span class="string">    store the current traversal position at all times.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    `_position` attribute stores the current traversal position. An iterator may</span></span><br><span class="line"><span class="string">    have a lot of other fields for storing iteration state, especially when it</span></span><br><span class="line"><span class="string">    is supposed to work with a particular kind of collection.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _position: <span class="built_in">int</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This attribute indicates the traversal direction.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _reverse: <span class="built_in">bool</span> = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, collection: WordsCollection, reverse: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._collection = collection</span><br><span class="line">        self._reverse = reverse</span><br><span class="line">        self._position = -<span class="number">1</span> <span class="keyword">if</span> reverse <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The __next__() method must return the next item in the sequence. On</span></span><br><span class="line"><span class="string">        reaching the end, and in subsequent calls, it must raise StopIteration.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = self._collection[self._position]</span><br><span class="line">            self._position += -<span class="number">1</span> <span class="keyword">if</span> self._reverse <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordsCollection</span>(<span class="title class_ inherited__">Iterable</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Concrete Collections provide one or several methods for retrieving fresh</span></span><br><span class="line"><span class="string">    iterator instances, compatible with the collection class.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, collection: <span class="built_in">list</span>[<span class="type">Any</span>] | <span class="literal">None</span> = <span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._collection = collection <span class="keyword">or</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">        <span class="keyword">return</span> self._collection[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>) -&gt; AlphabeticalOrderIterator:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The __iter__() method returns the iterator object itself, by default we</span></span><br><span class="line"><span class="string">        return the iterator in ascending order.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> AlphabeticalOrderIterator(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_reverse_iterator</span>(<span class="params">self</span>) -&gt; AlphabeticalOrderIterator:</span><br><span class="line">        <span class="keyword">return</span> AlphabeticalOrderIterator(self, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_item</span>(<span class="params">self, item: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._collection.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code may or may not know about the Concrete Iterator or</span></span><br><span class="line">    <span class="comment"># Collection classes, depending on the level of indirection you want to keep</span></span><br><span class="line">    <span class="comment"># in your program.</span></span><br><span class="line">    collection = WordsCollection()</span><br><span class="line">    collection.add_item(<span class="string">&quot;First&quot;</span>)</span><br><span class="line">    collection.add_item(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line">    collection.add_item(<span class="string">&quot;Third&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Straight traversal:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>.join(collection))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Reverse traversal:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>.join(collection.get_reverse_iterator()), end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Output-txt：执行结果"><a href="#Output-txt：执行结果" class="headerlink" title="Output.txt：执行结果"></a>Output.txt：执行结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Straight traversal:</span><br><span class="line">First</span><br><span class="line">Second</span><br><span class="line">Third</span><br><span class="line"></span><br><span class="line">Reverse traversal:</span><br><span class="line">Third</span><br><span class="line">Second</span><br><span class="line">First</span><br></pre></td></tr></table></figure>

<h1 id="Rust中的迭代器"><a href="#Rust中的迭代器" class="headerlink" title="Rust中的迭代器"></a>Rust中的迭代器</h1><p>迭代器是一种行为设计模式，它允许顺序遍历复杂的数据结构，而不暴露其内部细节。</p>
<h2 id="Standard-Iterator-标准迭代器"><a href="#Standard-Iterator-标准迭代器" class="headerlink" title="Standard Iterator 标准迭代器"></a>Standard Iterator 标准迭代器</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array</span> = &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">iterator</span> = array.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Traversal over each element of the vector.</span></span><br><span class="line">iterator.<span class="title function_ invoke__">for_each</span>(|e| <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;, &quot;</span>, e));</span><br></pre></td></tr></table></figure>

<h2 id="Custom-Iterator-自定义迭代器"><a href="#Custom-Iterator-自定义迭代器" class="headerlink" title="Custom Iterator 自定义迭代器"></a>Custom Iterator 自定义迭代器</h2><p>在Rust中，定义自定义迭代器的推荐方法是使用标准的 在Rust中，定义自定义迭代器的推荐方法是使用标准的 <code>Iterator</code> trait。该示例不包含合成迭代器接口，因为建议使用惯用的Rust方式。 trait。该示例不包含合成迭代器接口，因为建议使用惯用的Rust方式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">users</span> = UserCollection::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iterator</span> = users.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">iterator.<span class="title function_ invoke__">next</span>();</span><br></pre></td></tr></table></figure>

<p><code>next</code> 方法是唯一必须实现的  方法是唯一必须实现的  方法是唯一必须实现的 <code>Iterator</code> trait方法。它可以访问大量的标准方法，例如  trait方法。它可以访问大量的标准方法，例如  trait方法。它可以访问大量的标准方法，例如 <code>fold</code> ， <code>map</code> ， <code>for_each</code> 。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">UserIterator</span>&lt;<span class="symbol">&#x27;_</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="users-rs：集合和迭代器"><a href="#users-rs：集合和迭代器" class="headerlink" title="users.rs：集合和迭代器"></a>users.rs：集合和迭代器</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UserCollection</span> &#123;</span><br><span class="line">    users: [&amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>; <span class="number">3</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A custom collection contains an arbitrary user array under the hood.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">UserCollection</span> &#123;</span><br><span class="line">    <span class="comment">/// Returns a custom user collection.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            users: [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Carl&quot;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Returns an iterator over a user collection.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// The method name may be different, however, `iter` is used as a de facto</span></span><br><span class="line">    <span class="comment">/// standard in a Rust naming convention.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">iter</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> UserIterator &#123;</span><br><span class="line">        UserIterator &#123;</span><br><span class="line">            index: <span class="number">0</span>,</span><br><span class="line">            user_collection: <span class="keyword">self</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// UserIterator allows sequential traversal through a complex user collection</span></span><br><span class="line"><span class="comment">/// without exposing its internal details.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UserIterator</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    index: <span class="type">usize</span>,</span><br><span class="line">    user_collection: &amp;<span class="symbol">&#x27;a</span> UserCollection,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// `Iterator` is a standard interface for dealing with iterators</span></span><br><span class="line"><span class="comment">/// from the Rust standard library.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">UserIterator</span>&lt;<span class="symbol">&#x27;_</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A `next` method is the only `Iterator` trait method which is mandatory to be</span></span><br><span class="line">    <span class="comment">/// implemented. It makes accessible a huge range of standard methods,</span></span><br><span class="line">    <span class="comment">/// e.g. `fold`, `map`, `for_each`.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.index &lt; <span class="keyword">self</span>.user_collection.users.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">user</span> = <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.user_collection.users[<span class="keyword">self</span>.index]);</span><br><span class="line">            <span class="keyword">self</span>.index += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-rs：客户端代码"><a href="#main-rs：客户端代码" class="headerlink" title="main.rs：客户端代码"></a>main.rs：客户端代码</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::users::UserCollection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;Iterators are widely used in the standard library: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">array</span> = &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">iterator</span> = array.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traversal over each element of the array.</span></span><br><span class="line">    iterator.<span class="title function_ invoke__">for_each</span>(|e| <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, e));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n\nLet&#x27;s test our own iterator.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">users</span> = UserCollection::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iterator</span> = users.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1nd element: &#123;:?&#125;&quot;</span>, iterator.<span class="title function_ invoke__">next</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;2nd element: &#123;:?&#125;&quot;</span>, iterator.<span class="title function_ invoke__">next</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;3rd element: &#123;:?&#125;&quot;</span>, iterator.<span class="title function_ invoke__">next</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;4th element: &#123;:?&#125;&quot;</span>, iterator.<span class="title function_ invoke__">next</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;\nAll elements in user collection: &quot;</span>);</span><br><span class="line">    users.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">for_each</span>(|e| <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, e));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterators are widely used in the standard library: 1 2 3</span><br><span class="line"></span><br><span class="line">Let&#x27;s test our own iterator.</span><br><span class="line"></span><br><span class="line">1nd element: Some(&quot;Alice&quot;)</span><br><span class="line">2nd element: Some(&quot;Bob&quot;)</span><br><span class="line">3rd element: Some(&quot;Carl&quot;)</span><br><span class="line">4th element: None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">All elements in user collection: Alice Bob Carl</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>通过重视注释和代码来减少技术债务</title>
    <url>/2024/04/27/design-pattern/java-comments-reduce-technical-debt/</url>
    <content><![CDATA[<h1 id="通过重视注释和代码来减少技术债务"><a href="#通过重视注释和代码来减少技术债务" class="headerlink" title="通过重视注释和代码来减少技术债务"></a>通过重视注释和代码来减少技术债务</h1><h2 id="好的代码注释可以帮助维护者理解你的编码决策。"><a href="#好的代码注释可以帮助维护者理解你的编码决策。" class="headerlink" title="好的代码注释可以帮助维护者理解你的编码决策。"></a>好的代码注释可以帮助维护者理解你的编码决策。</h2><p>长期以来，注释在开发人员的输出中一直占据着明显的次要位置。注释是如此次要，而且被如此低估，以至于在今天的代码中，它们很少出现，除了作为文件顶部的常规版权和许可标头。这是一个错失的机会，因为积极维护的良好注释是减少技术债务的最有效方法之一，也就是说，它们减轻了未来将处理代码的程序员的工作量。</p>
<p>由于许多开发组织的文化低估了注释的价值，因此团队领导（和经理）允许注释与代码不同步，从而增加而不是减少技术债务。</p>
<p>而且，由于低估是常态，开发人员学会了责怪注释，而不是允许他们与代码不同步的文化。Bob Martin 断言，每条注释都代表着“未能在代码中表达自己”（见图 1），从而表达了这种消极观点。请注意，Martin 在他的《Clean Code》一书中发表了这个奇怪的声明，然后用了 15 页的篇幅列举了注释非常有用的许多例子。</p>
<h2 id="为什么要写注释？"><a href="#为什么要写注释？" class="headerlink" title="为什么要写注释？"></a>为什么要写注释？</h2><p>注释以多种方式消除了技术债务。</p>
<p>注释解释了代码的用途。文件开头的注释解释了代码中可以找到的功能，无需通读所有方法来收集对文件的理解。如果您正在寻找特定文件，能够阅读描述其内容的单个句子可以大大加快搜索速度。出于这个原因，大多数编码标准都敦促在每个文件中只包含这样的注释。</p>
<p>在文件级注释中使用关键字可以进一步方便在大型代码库中搜索特定功能。</p>
<p>类开始时的 Javadoc 注释可以替代文件级注释。如果注释描述了该类在更大项目中的角色，它们将进一步帮助读者。描述为什么需要该类（如果不明显）有助于其他人理解该类的作用。这些注释对于在类的 API 中呈现任何异常信息特别有用。</p>
<p><strong>注释对代码进行说明。</strong>许多开发人员有一种堂吉诃德式的信念，即如果代码足够清晰，他们就不需要使用注释。这就是 Bob Martin 在图 1 中断言的内容。这是一个可爱的前提，根本不成立。第一个问题是，大多数开发人员都承受着巨大的时间压力，没有时间使代码变得如此清晰，以至于不需要进一步的代码注释。事实上，程序员更常见的经历是看着他们六个月前写的代码，然后想“我简直不敢相信是我写的！不要自欺欺人地认为你可以写得如此清晰，以至于不需要注释就能理解。</p>
<p>明码异议的另一个局限性是，代码只解释了一件事是如何完成的，而不是为什么这样做的，尤其是在有明显的替代方案的情况下;如果原因不明显和明显，那么在没有解释的情况下就会产生技术债务。请注意，如果没有这样的解释性注释，代码可能非常难以维护，因为没有人敢碰它，而这正是技术债务的定义。</p>
<p><strong>代码注释突出显示了潜在的陷阱。</strong>例如，Google 的 Java 指南要求每当 switch 中的 case 语句进入下一个 case 时都要添加注释。同样，该指南要求注意和解释一个空的异常捕获块，以及所有其他可能被忽略的、非常规的或不受欢迎但偶尔必要的步骤的项目。</p>
<p><strong>代码注释为未来的工作提供了里程碑。</strong>术语“自我承认的技术债务”是指代码库中经常遇到的 TODO 和 FIXME 注释。从表面上看，这些看起来像是好心的程序员留下的碎屑，他们随后被其他任务所占据。然而，一项关于维护良好的开源项目的有趣研究，“关于消除自我承认的技术债务的实证研究”发现，74%的此类条目在180天内被删除，最常见的是将它们放在那里的开发人员。换言之，这些代码注释往往代表了未来工作的有用里程碑，而不是碎屑。</p>
<p>虽然不是专门针对技术债务的对策，但我使用第三个标记 CURR 来表示“当前”。这是一个面包屑，它告诉我我从哪里开始编码。我经常包括几行代码注释，其中包含恢复工作时可能需要的信息。我在一个代码库中只允许一个 CURR，所以如果我在其他地方恢复工作，我会将现有的 CURR 转换为 TODO。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a string object with EMBSTR encoding if it is smaller than</span></span><br><span class="line"><span class="comment"> * OBJ_ENCODING_EMBSTR_SIZE_LIMIT, otherwise =the RAW encoding is used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The current limit of 44 is chosen so that the biggest string object</span></span><br><span class="line"><span class="comment"> * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> #define OBJ_ENCODING_EMBSTR_SIZE_LIMIT <span class="number">44</span></span><br><span class="line"> robj *CreateStringObject(const <span class="type">char</span> *ptr, size_t len) &#123;</span><br><span class="line">     <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">         <span class="keyword">return</span> CreateEmbeddedStringObject(ptr, len);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> CreateRawStringObject(ptr, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same as CreateRawStringObject, can return NULL if allocation fails */</span></span><br><span class="line">robj *tryCreateRawStringObject(const <span class="type">char</span> *ptr, size_t len) &#123;</span><br><span class="line">    <span class="type">sds</span> <span class="variable">str</span> <span class="operator">=</span> sdstrynewlen(ptr, len);</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> NULL;</span><br><span class="line">    <span class="keyword">return</span> CreateObject(OBJ_STRING, str); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same as CreateRawStringObject, can return NULL if allocation fails */</span></span><br><span class="line">robj *tryCreateRawStringObject(const <span class="type">char</span> *ptr, size_t len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> CreateEmbeddedStringObject(ptr, len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> CreateRawStringObject(ptr, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Ousterhout-的注释方法"><a href="#Ousterhout-的注释方法" class="headerlink" title="Ousterhout 的注释方法"></a>Ousterhout 的注释方法</h2><p>在前面的方案中，注释的好处是不可否认的。它们减少了技术债务，维护良好的注释也使新团队成员更容易理解代码库，而无需花费数小时在死胡同中摸索或向现有员工提出数百个问题。</p>
<p>然而，重视代码注释的文化可以鼓励它们用于远远超出技术债务的补救。</p>
<p>John Ousterhout 的优秀著作《软件设计哲学》（A Philosophy of Software Design）描述了大型代码库的最佳实践;它接续了马丁离开的地方，更倾向于现实世界的情况。Ousterhout 是 Tcl 语言的设计者和实现者;后来，他与他人共同创立了Electric Cloud，这是一家专门从事大规模代码库（即代码行超过100万行的代码库）的DevOps工具的公司。</p>
<p>虽然 Ousterhout 的书只有 175 页，但它用了整整两章来讲代码注释。第一章回答了对撰写和重视代码注释的最常见反对意见;第二个重点是提高代码注释的质量。</p>
<p>Ousterhout 的一般格言是，代码中的注释应该传达程序员脑海中无法准确反映在代码本身中的任何内容。这是一个很好的指导方针，它直接反驳了“每条代码注释都是失败的”的论点。真正的失败是省略了后续编码人员可能需要的澄清和上下文信息。</p>
<p>代码注释还可以帮助您理清自己的想法。不止一次，当我为一段代码编写注释时，我意识到我的实现存在缺陷。这与向同事描述问题并在解释问题时出现解决方案的感觉大致相同——这是一种常见的体验。在之前的文章中，我描述了这种优势在混合方法中的扩展，该方法从Ousterhout的书中获取了元素。</p>
<p>创建类时，请考虑使用以下有用的步骤，这些步骤是对注释使用的重大扩展：</p>
<ul>
<li>首先编写类接口注释。</li>
<li>编写最重要的公共方法的接口注释和签名，但将方法主体留空。</li>
<li>为最重要的实例变量编写注释和声明。</li>
<li>填写方法的正文，并在进行时添加实现注释。</li>
<li>当您发现需要更多方法时，请在正文之前写下注释。</li>
<li>根据 Ousterhout 的经验，这些步骤的好处是三方面的。</li>
<li>代码完成后，会正确注释，并且注释完全是最新的。</li>
<li>注释优先的方法使您能够专注于抽象，而不是被实现分散注意力。</li>
<li>注释揭示了代码的复杂性 - 如果方法或变量需要冗长而复杂的注释，则可能需要重新考虑和简化。</li>
</ul>
<p>这有很多好处！</p>
<p>在Ousterhout看来，最重要的内容是抽象（很难通过阅读实现代码来梳理）和对代码存在原因的解释。总之，第一次处理代码的开发人员应该能够扫描类的注释，并很好地了解类的作用并理解最重要的实现方面。</p>
<p>如果这种方法对你有吸引力——就像它对我一样——Ousterhout 建议你使用它，直到你习惯了以这种方式编写代码。他争辩说，我同意，这样做会通过提供更干净、更清晰的代码来改变你。</p>
<h2 id="Javadoc-的奢华"><a href="#Javadoc-的奢华" class="headerlink" title="Javadoc 的奢华"></a>Javadoc 的奢华</h2><p>Java 开发人员有一个很好的工具来追求这种更深入的方法：Javadoc 注解。如果你用一种以上的语言编写代码，你很快就会意识到注释选项在其他语言中是多么微不足道。大多数语言没有任何内置的 Javadoc 对应物。或者，就像 Go 和其他一些语言一样，如果它们有对应的语言，相比之下，它就很无聊了。</p>
<p>Javadoc 允许您将注释转换为优雅、格式良好且可用的文档。从JDK发行版的优秀文档中可以看出，Java团队在深思熟虑、认真的纪律中充分利用了该工具。（顺便说一句，JVM 本身存在广泛的代码注释。</p>
<h2 id="开源项目中的注释"><a href="#开源项目中的注释" class="headerlink" title="开源项目中的注释"></a>开源项目中的注释</h2><p>最后一点：如果你正在为一个开源项目做贡献，你应该非常重视代码注释。潜在合作者在考虑加入项目时遇到的最大障碍之一是学习代码库的困难——最常见的原因是它不包含任何注释（在许可证标头之外）。</p>
<p>优秀的开源项目负责人会努力提供易于理解的文档和注释良好的代码，以便潜在的贡献者可以轻松快速地摸索代码，而无需付出太多努力来修复一个小错误。那些以良好的文档和大量代码注释为荣的项目，如Redis，会得到良好的参与。</p>
<p>在我参与的一个项目 Jacobin 中，这是一个用 Go 编写的 JVM，贡献者广泛使用注释。还为潜在的贡献者提供了额外的资源：代码库的概述，使人们能够轻松理解项目的整体架构以及它如何映射到代码布局。</p>
<p>这些步骤需要时间，但它们对项目的贡献者和项目的目标受众一样有帮助，因为它们迫使雅各宾的开发人员明确我们的假设，清晰地思考我们的思维，并在工作中遵守纪律。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>维护不善的代码注释是技术债务的明显来源。若要避免此问题，请像重视代码一样重视注释。例如，在进行代码审查时，不仅要特别注意围绕新代码的注释，还要特别注意文件中的更高级别的注释是否仍然正确。</p>
<p>由于 JDK 捆绑了 Javadoc，因此您有独特的机会从对注释的严格赞赏中彻底受益，从而消除了技术债务。</p>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Mediator 中介者模式</title>
    <url>/2024/04/20/design-pattern/mediator/</url>
    <content><![CDATA[<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent  意图"></a>Intent  意图</h2><p>Mediator是一种行为设计模式，可以减少对象之间的混乱依赖关系。该模式限制了对象之间的直接通信，并强制它们只能通过中介对象进行协作。</p>
<div align="center"> <img src="/images/mediator-header.png"/></div>


<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem  问题"></a>Problem  问题</h2><p>假设您有一个用于创建和编辑客户配置文件的对话框。它由各种表单控件组成，如文本字段、复选框、按钮等。</p>
<div align="center"> <img src="/images/mediator-problem.png"/>随着应用程序的发展，用户界面元素之间的关系可能会变得混乱。</div>


<p>某些表单元素可能与其他表单元素交互。例如，选择“我有一只狗”复选框可以显示用于输入狗的名字的隐藏文本字段。另一个例子是提交按钮，它必须在保存数据之前验证所有字段的值。</p>
<div align="center"> <img src="/images/mediator-problem2.png"/>元素可以与其他元素有很多关系。因此，某些要素的变化可能会影响其他要素。

</div>


<p>通过直接在表单元素的代码中实现这种逻辑，你会使这些元素的类更难在应用的其他表单中重用。例如，你将无法在另一个表单中使用复选框类，因为它耦合到狗的文本字段。您可以使用呈现配置文件表单所涉及的所有类，也可以不使用任何类。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution  解决方案"></a>Solution  解决方案</h2><p>中介者模式建议您应该停止您想要使其彼此独立的组件之间的所有直接通信。相反，这些组件必须通过调用一个特殊的中介对象来间接协作，该对象将调用重定向到适当的组件。因此，组件只依赖于单个中介类，而不是耦合到几十个同事。</p>
<p>在我们的配置文件编辑表单示例中，对话框类本身可以充当中介。dialog类很可能已经知道它的所有子元素，因此您甚至不需要在该类中引入新的依赖项。</p>
<div align="center"> <img src="/images/mediator-problem2.png"/>UI元素应该通过中介对象进行间接通信。</div>


<p>最重要的变化发生在实际的表单元素上。让我们考虑一下提交按钮。以前，用户每次单击按钮时，都必须验证所有单个表单元素的值。现在，它的唯一任务是通知对话框有关单击的信息。在收到此通知后，对话框本身将执行验证或将任务传递给各个元素。因此，按钮并不依赖于十几个表单元素，而是仅依赖于dialog类。</p>
<p>您还可以更进一步，通过为所有类型的对话框提取公共接口，使依赖性更加松散。该接口将声明通知方法，所有表单元素都可以使用该方法通知对话框发生在这些元素上的事件。因此，我们的提交按钮现在应该能够与实现该接口的任何对话框一起工作。</p>
<p>通过这种方式，Mediator模式允许您将各种对象之间的复杂关系网封装在单个Mediator对象中。类的依赖项越少，就越容易修改、扩展或重用该类。</p>
<h2 id="Real-World-Analogy-现实世界的类比"><a href="#Real-World-Analogy-现实世界的类比" class="headerlink" title="Real-World Analogy  现实世界的类比"></a>Real-World Analogy  现实世界的类比</h2><div align="center"> <img src="/images/mediator-live-example.png"/>飞机飞行员在决定下一个降落的时候不会直接互相交谈。所有的通讯都通过控制塔。</div>


<p>接近或离开机场控制区的飞机飞行员不直接相互交流。相反，他们与一位空中交通管制员交谈，他坐在飞机跑道附近的一座高塔上。如果没有空中交通管制员，飞行员将需要了解机场附近的每一架飞机，并与数十名其他飞行员组成的委员会讨论着陆优先级。这可能会使飞机失事的统计数字飙升。</p>
<p>塔台不需要控制整个飞行。它的存在仅仅是为了在终端区域实施约束，因为那里涉及的参与者的数量可能对飞行员来说是压倒性的。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure  结构"></a>Structure  结构</h2><div align="center"> <img src="/images/mediator-structure.png"/></div>


<ol>
<li><p>组件是包含一些业务逻辑的各种类。每个组件都有一个对中介器的引用，用中介器接口的类型声明。该组件并不知道中介器的实际类，因此您可以通过将其链接到不同的中介器来在其他程序中重用该组件。</p>
</li>
<li><p>Mediator接口声明了与组件通信的方法，这些方法通常只包括一个通知方法。组件可以将任何上下文作为此方法的参数传递，包括它们自己的对象，但只能以这样一种方式传递，即接收组件和发送方的类之间不发生耦合。</p>
</li>
<li><p>具体中介封装了各种组件之间的关系。具体的中介者经常保持对它们管理的所有组件的引用，有时甚至管理它们的生命周期。</p>
</li>
<li><p>组件必须不知道其他组件。如果某个组件内部发生了重要的事情，它必须只通知中介。当中介器收到通知时，它可以轻松地识别发送者，这可能足以决定应该触发哪个组件作为回报。</p>
<p>从组件的角度来看，这一切看起来像一个完全的黑盒子。发送方不知道谁将最终处理它的请求，接收方也不知道谁首先发送了请求。</p>
</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode  伪代码"></a>Pseudocode  伪代码</h2><p>在本例中，中介模式帮助您消除各种UI类（按钮、复选框和文本标签）之间的相互依赖</p>
<div align="center"> <img src="/images/mediator-example2.png"/></div>


<p>由用户触发的元素不会直接与其他元素通信，即使它看起来像是应该这样。相反，元素只需要让它的中介者知道事件，并将任何上下文信息沿着一起传递。</p>
<p>在本例中，整个身份验证对话框充当中介。它知道具体元素应该如何协作，并促进它们的间接通信。在接收到关于事件的通知时，对话框决定哪个元素应该处理该事件，并相应地重定向调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The mediator interface declares a method used by components</span></span><br><span class="line"><span class="comment">// to notify the mediator about various events. The mediator may</span></span><br><span class="line"><span class="comment">// react to these events and pass the execution to other</span></span><br><span class="line"><span class="comment">// components.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Mediator</span> is</span><br><span class="line">    method <span class="title function_">notify</span><span class="params">(sender: Component, event: string)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The concrete mediator class. The intertwined web of</span></span><br><span class="line"><span class="comment">// connections between individual components has been untangled</span></span><br><span class="line"><span class="comment">// and moved into the mediator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthenticationDialog</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> is</span><br><span class="line">    <span class="keyword">private</span> field title: string</span><br><span class="line">    <span class="keyword">private</span> field loginOrRegisterChkBx: Checkbox</span><br><span class="line">    <span class="keyword">private</span> field loginUsername, loginPassword: Textbox</span><br><span class="line">    <span class="keyword">private</span> field registrationUsername, registrationPassword,</span><br><span class="line">                  registrationEmail: Textbox</span><br><span class="line">    <span class="keyword">private</span> field okBtn, cancelBtn: Button</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">AuthenticationDialog</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Create all component objects by passing the current</span></span><br><span class="line">        <span class="comment">// mediator into their constructors to establish links.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// When something happens with a component, it notifies the</span></span><br><span class="line">    <span class="comment">// mediator. Upon receiving a notification, the mediator may</span></span><br><span class="line">    <span class="comment">// do something on its own or pass the request to another</span></span><br><span class="line">    <span class="comment">// component.</span></span><br><span class="line">    method <span class="title function_">notify</span><span class="params">(sender, event)</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(sender == loginOrRegisterChkBx and event == <span class="string">&quot;check&quot;</span>)</span></span><br><span class="line">            <span class="keyword">if</span> (loginOrRegisterChkBx.checked)</span><br><span class="line">                title = <span class="string">&quot;Log in&quot;</span></span><br><span class="line">                <span class="comment">// 1. Show login form components.</span></span><br><span class="line">                <span class="comment">// 2. Hide registration form components.</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                title = <span class="string">&quot;Register&quot;</span></span><br><span class="line">                <span class="comment">// 1. Show registration form components.</span></span><br><span class="line">                <span class="comment">// 2. Hide login form components</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sender == okBtn &amp;&amp; event == <span class="string">&quot;click&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (loginOrRegister.checked)</span><br><span class="line">                <span class="comment">// Try to find a user using login credentials.</span></span><br><span class="line">                <span class="keyword">if</span> (!found)</span><br><span class="line">                    <span class="comment">// Show an error message above the login</span></span><br><span class="line">                    <span class="comment">// field.</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 1. Create a user account using data from the</span></span><br><span class="line">                <span class="comment">// registration fields.</span></span><br><span class="line">                <span class="comment">// 2. Log that user in.</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Components communicate with a mediator using the mediator</span></span><br><span class="line"><span class="comment">// interface. Thanks to that, you can use the same components in</span></span><br><span class="line"><span class="comment">// other contexts by linking them with different mediator</span></span><br><span class="line"><span class="comment">// objects.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> is</span><br><span class="line">    field dialog: Mediator</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Component</span><span class="params">(dialog)</span> is</span><br><span class="line">        <span class="built_in">this</span>.dialog = dialog</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">click</span><span class="params">()</span> is</span><br><span class="line">        dialog.notify(<span class="built_in">this</span>, <span class="string">&quot;click&quot;</span>)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">keypress</span><span class="params">()</span> is</span><br><span class="line">        dialog.notify(<span class="built_in">this</span>, <span class="string">&quot;keypress&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete components don&#x27;t talk to each other. They have only</span></span><br><span class="line"><span class="comment">// one communication channel, which is sending notifications to</span></span><br><span class="line"><span class="comment">// the mediator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">extends</span> <span class="title class_">Component</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Textbox</span> <span class="keyword">extends</span> <span class="title class_">Component</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Checkbox</span> <span class="keyword">extends</span> <span class="title class_">Component</span> is</span><br><span class="line">    method <span class="title function_">check</span><span class="params">()</span> is</span><br><span class="line">        dialog.notify(<span class="built_in">this</span>, <span class="string">&quot;check&quot;</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability  适用性"></a>Applicability  适用性</h2><ul>
<li>当由于类与其他类紧密耦合而难以更改某些类时，请使用中介模式。</li>
<li>该模式允许您将类之间的所有关系提取到一个单独的类中，从而将对特定组件的任何更改与其他组件隔离开来。</li>
<li>当您不能在不同的程序中重用某个组件时，请使用该模式，因为它太依赖于其他组件。</li>
<li>应用Mediator后，各个组件将不知道其他组件。它们仍然可以通过中介对象彼此通信，尽管是间接的。要在不同的应用中重用组件，您需要为其提供新的中介器类。</li>
<li>当您发现自己创建了大量的组件子类，只是为了在各种上下文中重用一些基本行为时，请使用Mediator。</li>
<li>由于组件之间的所有关系都包含在中介器中，因此通过引入新的中介器类，可以很容易地为这些组件定义全新的协作方式，而无需更改组件本身。</li>
</ul>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>识别一组紧密耦合的类，它们将从更加独立中受益（例如，以便更容易地维护或更简单地重用这些类）。</p>
</li>
<li><p>描述中介器接口，并描述中介器和各种组件之间所需的通信协议。在大多数情况下，从组件接收通知的单一方法就足够了。</p>
<p>当您希望在不同的上下文中重用组件类时，此接口至关重要。只要组件通过通用接口与其中介器一起工作，您就可以将组件与中介器的不同实现链接起来。</p>
</li>
<li><p>实现具体的中介类。考虑在中介器中存储对所有组件的引用。这样，您就可以从中介器的方法中调用任何组件。</p>
</li>
<li><p>您可以更进一步，让中介器负责组件对象的创建和销毁。在此之后，中介可能类似于工厂模式（factory）或门面模式（facade）。</p>
</li>
<li><p>组件应该存储对中介对象的引用。连接通常是在组件的构造函数中建立的，其中中介器对象作为参数传递。</p>
</li>
<li><p>更改组件的代码，以便它们调用中介的通知方法，而不是其他组件上的方法。将涉及调用其他组件的代码提取到mediator类中。只要中介器收到来自该组件的通知，就执行此代码。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-利弊"><a href="#Pros-and-Cons-利弊" class="headerlink" title="Pros and Cons 利弊"></a>Pros and Cons 利弊</h2><table>
<thead>
<tr>
<th>利√</th>
<th>弊×</th>
</tr>
</thead>
<tbody><tr>
<td>单一责任原则。您可以将各种组件之间的通信提取到一个地方，使其更容易理解和维护。</td>
<td>随着时间的推移，一个中介可以进化成一个上帝对象。</td>
</tr>
<tr>
<td>开放&#x2F;封闭原则。您可以引入新的中介，而不必更改实际的组件。</td>
<td></td>
</tr>
<tr>
<td>您可以减少程序的各个组件之间的耦合。</td>
<td></td>
</tr>
<tr>
<td>您可以更轻松地重用单个组件。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>责任链、命令、调解器和观察者解决了连接请求的接收者和接收者的各种方式：</p>
<ul>
<li>责任链（Chain of Responsibility）将请求顺序地沿着一个动态的潜在接收者链传递，直到其中一个接收者处理它。</li>
<li>命令在中继器和接收器之间建立单向连接。</li>
<li>Mediator消除了发送者和接收者之间的直接连接，迫使它们通过Mediator对象间接通信。</li>
<li>观察者允许接收者动态订阅和取消订阅接收请求。</li>
</ul>
</li>
<li><p>Facade和Mediator有着类似的工作：它们试图组织许多紧密耦合的类之间的协作。</p>
<ul>
<li>Facade为对象子系统定义了一个简化的接口，但它没有引入任何新功能。子系统本身不知道facade。子系统内的对象可以直接通信。</li>
<li>Mediator集中系统组件之间的通信。组件只知道中介对象，不直接通信</li>
</ul>
</li>
<li><p>调解人和观察员之间的区别往往是难以捉摸的。在大多数情况下，您可以实现这两种模式中的任何一种;但有时您可以同时应用这两种模式。让我们看看如何做到这一点。</p>
<p>Mediator的主要目标是消除一组系统组件之间的相互依赖性。相反，这些组件依赖于单个中介对象。Observer的目标是在对象之间建立动态的单向连接，其中一些对象充当其他对象的从属对象。</p>
<p>中介者模式有一个流行的实现依赖于观察者。中介者对象扮演发布者的角色，而组件则充当订阅者，订阅和取消订阅中介者的事件。当Mediator以这种方式实现时，它可能看起来非常类似于Observer。</p>
<p>当您感到困惑时，请记住您可以用其他方式实现中介者模式。例如，您可以将所有组件永久链接到同一个中介器对象。这个实现与Observer不同，但仍然是Mediator模式的一个实例。</p>
<p>现在想象一个程序，其中所有组件都成为发布者，允许彼此之间的动态连接。不会有一个集中的中介对象，只有一组分布式的观察者。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples  代码示例"></a>Code Examples  代码示例</h2><h1 id="Mediator-in-Python-Python中的Mediator"><a href="#Mediator-in-Python-Python中的Mediator" class="headerlink" title="Mediator in Python Python中的Mediator"></a><strong>Mediator</strong> in Python Python中的Mediator</h1><p>中介者模式是一种行为设计模式，它通过使程序组件之间通过一个特殊的中介器对象进行间接通信来减少组件之间的耦合。</p>
<p>Mediator使修改、扩展和重用单个组件变得容易，因为它们不再依赖于其他几十个类。</p>
<h2 id="Conceptual-Example-概念示例"><a href="#Conceptual-Example-概念示例" class="headerlink" title="Conceptual Example 概念示例"></a>Conceptual Example 概念示例</h2><p>此示例说明了中介器设计模式的结构。它侧重于回答这些问题：</p>
<ul>
<li>它由哪些类组成？</li>
<li>这些班级扮演什么角色？</li>
<li>模式中的元素是以什么方式联系在一起的？</li>
</ul>
<h4 id="main-py：概念性示例"><a href="#main-py：概念性示例" class="headerlink" title="main.py：概念性示例"></a>main.py：概念性示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Mediator interface declares a method used by components to notify the</span></span><br><span class="line"><span class="string">    mediator about various events. The Mediator may react to these events and</span></span><br><span class="line"><span class="string">    pass the execution to other components.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">self, sender: <span class="built_in">object</span>, event: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span>(<span class="title class_ inherited__">Mediator</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, component1: Component1, component2: Component2</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._component1 = component1</span><br><span class="line">        self._component1.mediator = self</span><br><span class="line">        self._component2 = component2</span><br><span class="line">        self._component2.mediator = self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">self, sender: <span class="built_in">object</span>, event: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Mediator reacts on A and triggers following operations:&quot;</span>)</span><br><span class="line">            self._component2.do_c()</span><br><span class="line">        <span class="keyword">elif</span> event == <span class="string">&quot;D&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Mediator reacts on D and triggers following operations:&quot;</span>)</span><br><span class="line">            self._component1.do_b()</span><br><span class="line">            self._component2.do_c()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseComponent</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Base Component provides the basic functionality of storing a mediator&#x27;s</span></span><br><span class="line"><span class="string">    instance inside component objects.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mediator: Mediator = <span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._mediator = mediator</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mediator</span>(<span class="params">self</span>) -&gt; Mediator:</span><br><span class="line">        <span class="keyword">return</span> self._mediator</span><br><span class="line"></span><br><span class="line"><span class="meta">    @mediator.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mediator</span>(<span class="params">self, mediator: Mediator</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._mediator = mediator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Components implement various functionality. They don&#x27;t depend on other</span></span><br><span class="line"><span class="string">components. They also don&#x27;t depend on any concrete mediator classes.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component1</span>(<span class="title class_ inherited__">BaseComponent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_a</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Component 1 does A.&quot;</span>)</span><br><span class="line">        self.mediator.notify(self, <span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_b</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Component 1 does B.&quot;</span>)</span><br><span class="line">        self.mediator.notify(self, <span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component2</span>(<span class="title class_ inherited__">BaseComponent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_c</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Component 2 does C.&quot;</span>)</span><br><span class="line">        self.mediator.notify(self, <span class="string">&quot;C&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_d</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Component 2 does D.&quot;</span>)</span><br><span class="line">        self.mediator.notify(self, <span class="string">&quot;D&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code.</span></span><br><span class="line">    c1 = Component1()</span><br><span class="line">    c2 = Component2()</span><br><span class="line">    mediator = ConcreteMediator(c1, c2)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client triggers operation A.&quot;</span>)</span><br><span class="line">    c1.do_a()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client triggers operation D.&quot;</span>)</span><br><span class="line">    c2.do_d()</span><br></pre></td></tr></table></figure>

<h4 id="Output-txt：执行结果"><a href="#Output-txt：执行结果" class="headerlink" title="Output.txt：执行结果"></a>Output.txt：执行结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client triggers operation A.</span><br><span class="line">Component 1 does A.</span><br><span class="line">Mediator reacts on A and triggers following operations:</span><br><span class="line">Component 2 does C.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Client triggers operation D.</span><br><span class="line">Component 2 does D.</span><br><span class="line">Mediator reacts on D and triggers following operations:</span><br><span class="line">Component 1 does B.</span><br><span class="line">Component 2 does C.</span><br></pre></td></tr></table></figure>

<h1 id="Mediator-in-Rust-Rust中的Mediator"><a href="#Mediator-in-Rust-Rust中的Mediator" class="headerlink" title="Mediator in Rust Rust中的Mediator"></a><strong>Mediator</strong> in Rust Rust中的Mediator</h1><p>中介者模式是一种行为设计模式，它通过使程序组件之间通过一个特殊的中介器对象进行间接通信来减少组件之间的耦合</p>
<h2 id="Top-Down-Ownership-自上而下的所有权"><a href="#Top-Down-Ownership-自上而下的所有权" class="headerlink" title="Top-Down Ownership 自上而下的所有权"></a>Top-Down Ownership 自上而下的所有权</h2><p>自上而下的所有权方法允许在Rust中应用Mediator，因为它适合Rust的所有权模型，具有严格的借用检查规则。这不是实现Mediator的唯一方法，但却是一种基本方法。</p>
<p>关键是从所有权的角度思考。</p>
<ol>
<li>调解人拥有所有组件的所有权。</li>
<li>组件不保留对中介的引用。相反，它通过方法调用获取引用。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A train gets a mediator object by reference.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Train</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">arrive</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, mediator: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Mediator);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">depart</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, mediator: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Mediator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mediator has notification methods.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">notify_about_arrival</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, train_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">notify_about_departure</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, train_name: &amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>控制流从 控制流从 <code>fn main()</code> 开始，其中中介器接收外部事件&#x2F;命令。 开始，其中中介器接收外部事件&#x2F;命令。</li>
<li>用于组件之间交互的 用于组件之间交互的 <code>Mediator</code> trait（  trait（  trait（ <code>notify_about_arrival</code> 、  、  、 <code>notify_about_departure</code> ）与其用于接收外部事件的外部API（来自主循环的  ）与其用于接收外部事件的外部API（来自主循环的  ）与其用于接收外部事件的外部API（来自主循环的 <code>accept</code> 、  、  、 <code>depart</code> 命令）不同。 命令）不同。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">train1</span> = PassengerTrain::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Train 1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">train2</span> = FreightTrain::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Train 2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Station has `accept` and `depart` methods,</span></span><br><span class="line"><span class="comment">// but it also implements `Mediator`.</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">station</span> = TrainStation::<span class="title function_ invoke__">default</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Station is taking ownership of the trains.</span></span><br><span class="line">station.<span class="title function_ invoke__">accept</span>(train1);</span><br><span class="line">station.<span class="title function_ invoke__">accept</span>(train2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `train1` and `train2` have been moved inside,</span></span><br><span class="line"><span class="comment">// but we can use train names to depart them.</span></span><br><span class="line">station.<span class="title function_ invoke__">depart</span>(<span class="string">&quot;Train 1&quot;</span>);</span><br><span class="line">station.<span class="title function_ invoke__">depart</span>(<span class="string">&quot;Train 2&quot;</span>);</span><br><span class="line">station.<span class="title function_ invoke__">depart</span>(<span class="string">&quot;Train 3&quot;</span>);</span><br></pre></td></tr></table></figure>




<div align="center"> <img src="/images/mediator-rust-approach.png"/></div>


<h4 id="train-station-rs"><a href="#train-station-rs" class="headerlink" title="train_station.rs"></a>train_station.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::&#123;HashMap, VecDeque&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::trains::Train;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mediator has notification methods.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">notify_about_arrival</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, train_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">notify_about_departure</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, train_name: &amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TrainStation</span> &#123;</span><br><span class="line">    trains: HashMap&lt;<span class="type">String</span>, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Train&gt;&gt;,</span><br><span class="line">    train_queue: VecDeque&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    train_on_platform: <span class="type">Option</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Mediator</span> <span class="keyword">for</span> <span class="title class_">TrainStation</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">notify_about_arrival</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, train_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.train_on_platform.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.train_queue.<span class="title function_ invoke__">push_back</span>(train_name.<span class="title function_ invoke__">into</span>());</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.train_on_platform.<span class="title function_ invoke__">replace</span>(train_name.<span class="title function_ invoke__">into</span>());</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">notify_about_departure</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, train_name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">Some</span>(train_name.<span class="title function_ invoke__">into</span>()) == <span class="keyword">self</span>.train_on_platform &#123;</span><br><span class="line">            <span class="keyword">self</span>.train_on_platform = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next_train_name) = <span class="keyword">self</span>.train_queue.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">next_train</span> = <span class="keyword">self</span>.trains.<span class="title function_ invoke__">remove</span>(&amp;next_train_name).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                next_train.<span class="title function_ invoke__">arrive</span>(<span class="keyword">self</span>);</span><br><span class="line">                <span class="keyword">self</span>.trains.<span class="title function_ invoke__">insert</span>(next_train_name.<span class="title function_ invoke__">clone</span>(), next_train);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">self</span>.train_on_platform = <span class="title function_ invoke__">Some</span>(next_train_name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TrainStation</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">accept</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> train: <span class="keyword">impl</span> <span class="title class_">Train</span> + <span class="symbol">&#x27;static</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.trains.<span class="title function_ invoke__">contains_key</span>(train.<span class="title function_ invoke__">name</span>()) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; has already arrived&quot;</span>, train.<span class="title function_ invoke__">name</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        train.<span class="title function_ invoke__">arrive</span>(<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">self</span>.trains.<span class="title function_ invoke__">insert</span>(train.<span class="title function_ invoke__">name</span>().<span class="title function_ invoke__">clone</span>(), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(train));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">depart</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">train</span> = <span class="keyword">self</span>.trains.<span class="title function_ invoke__">remove</span>(name);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">mut</span> train) = train &#123;</span><br><span class="line">            train.<span class="title function_ invoke__">depart</span>(<span class="keyword">self</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#x27;&#123;&#125;&#x27; is not on the station!&quot;</span>, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="trains-mod-rs"><a href="#trains-mod-rs" class="headerlink" title="trains&#x2F;mod.rs"></a><strong>trains&#x2F;mod.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> freight_train;</span><br><span class="line"><span class="keyword">mod</span> passenger_train;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> freight_train::FreightTrain;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> passenger_train::PassengerTrain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::train_station::Mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A train gets a mediator object by reference.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Train</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">arrive</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, mediator: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Mediator);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">depart</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, mediator: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Mediator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="trains-freight-train-rs"><a href="#trains-freight-train-rs" class="headerlink" title="trains&#x2F;freight_train.rs"></a><strong>trains&#x2F;freight_train.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Train;</span><br><span class="line"><span class="keyword">use</span> crate::train_station::Mediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">FreightTrain</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FreightTrain</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; name: name.<span class="title function_ invoke__">into</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Train</span> <span class="keyword">for</span> <span class="title class_">FreightTrain</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">arrive</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, mediator: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Mediator) &#123;</span><br><span class="line">        <span class="keyword">if</span> !mediator.<span class="title function_ invoke__">notify_about_arrival</span>(&amp;<span class="keyword">self</span>.name) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Freight train &#123;&#125;: Arrival blocked, waiting&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Freight train &#123;&#125;: Arrived&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">depart</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, mediator: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Mediator) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Freight train &#123;&#125;: Leaving&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">        mediator.<span class="title function_ invoke__">notify_about_departure</span>(&amp;<span class="keyword">self</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="trains-passenger-train-rs"><a href="#trains-passenger-train-rs" class="headerlink" title="trains&#x2F;passenger_train.rs"></a><strong>trains&#x2F;passenger_train.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Train;</span><br><span class="line"><span class="keyword">use</span> crate::train_station::Mediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PassengerTrain</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PassengerTrain</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; name: name.<span class="title function_ invoke__">into</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Train</span> <span class="keyword">for</span> <span class="title class_">PassengerTrain</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">arrive</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, mediator: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Mediator) &#123;</span><br><span class="line">        <span class="keyword">if</span> !mediator.<span class="title function_ invoke__">notify_about_arrival</span>(&amp;<span class="keyword">self</span>.name) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Passenger train &#123;&#125;: Arrival blocked, waiting&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Passenger train &#123;&#125;: Arrived&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">depart</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, mediator: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Mediator) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Passenger train &#123;&#125;: Leaving&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">        mediator.<span class="title function_ invoke__">notify_about_departure</span>(&amp;<span class="keyword">self</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-rs：客户端代码"><a href="#main-rs：客户端代码" class="headerlink" title="main.rs：客户端代码"></a>main.rs：客户端代码</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> train_station;</span><br><span class="line"><span class="keyword">mod</span> trains;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> train_station::TrainStation;</span><br><span class="line"><span class="keyword">use</span> trains::&#123;FreightTrain, PassengerTrain&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">train1</span> = PassengerTrain::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Train 1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">train2</span> = FreightTrain::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Train 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Station has `accept` and `depart` methods,</span></span><br><span class="line">    <span class="comment">// but it also implements `Mediator`.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">station</span> = TrainStation::<span class="title function_ invoke__">default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Station is taking ownership of the trains.</span></span><br><span class="line">    station.<span class="title function_ invoke__">accept</span>(train1);</span><br><span class="line">    station.<span class="title function_ invoke__">accept</span>(train2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `train1` and `train2` have been moved inside,</span></span><br><span class="line">    <span class="comment">// but we can use train names to depart them.</span></span><br><span class="line">    station.<span class="title function_ invoke__">depart</span>(<span class="string">&quot;Train 1&quot;</span>);</span><br><span class="line">    station.<span class="title function_ invoke__">depart</span>(<span class="string">&quot;Train 2&quot;</span>);</span><br><span class="line">    station.<span class="title function_ invoke__">depart</span>(<span class="string">&quot;Train 3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Passenger train Train 1: Arrived</span><br><span class="line">Freight train Train 2: Arrival blocked, waiting</span><br><span class="line">Passenger train Train 1: Leaving</span><br><span class="line">Freight train Train 2: Arrived</span><br><span class="line">Freight train Train 2: Leaving</span><br><span class="line">&#x27;Train 3&#x27; is not on the station!</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Memento 备忘录模式</title>
    <url>/2024/04/21/design-pattern/memento/</url>
    <content><![CDATA[<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p>Memento 是一种行为设计模式，可让您保存和恢复对象的先前状态，而无需透露其实现的细节。</p>
<div align="center"> <img src="/images/memento-header.png"/></div>


<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>假设您正在创建一个文本编辑器应用程序。除了简单的文本编辑外，您的编辑器还可以设置文本格式、插入内嵌图像等。</p>
<p>在某个时候，您决定让用户撤消对文本执行的任何操作。多年来，此功能已变得如此普遍，以至于如今人们希望每个应用程序都拥有它。对于实现，您选择采用直接方法。在执行任何操作之前，应用程序会记录所有对象的状态并将其保存在某个存储中。稍后，当用户决定还原操作时，应用会从历史记录中获取最新快照，并使用它来还原所有对象的状态。</p>
<div align="center"> <img src="/images/memento-problem1.png"/>在执行操作之前，应用会保存对象状态的快照，稍后可用于将对象还原到以前的状态。</div>


<p>让我们考虑一下这些状态快照。你究竟要如何生产一个？您可能需要遍历对象中的所有字段，并将其值复制到存储中。但是，这只有在对象对其内容的访问限制相当宽松时才有效。不幸的是，大多数真实对象不会让其他人轻易窥视它们，将所有重要数据隐藏在私人字段中。</p>
<p>暂时忽略这个问题，让我们假设我们的对象表现得像嬉皮士：更喜欢开放关系并保持其状态公开。虽然这种方法可以解决眼前的问题，并允许您随意生成对象状态的快照，但它仍然存在一些严重的问题。将来，您可能会决定重构某些编辑器类，或者添加或删除某些字段。听起来很简单，但这还需要更改负责复制受影响对象状态的类。</p>
<div align="center"> <img src="/images/memento-problem1.png"/>如何复制对象的私有状态？</div>


<p>但还有更多。让我们考虑一下编辑器状态的实际“快照”。它包含哪些数据？它至少必须包含实际文本、光标坐标、当前滚动位置等。要制作快照，您需要收集这些值并将它们放入某种容器中。</p>
<p>最有可能的是，您将在表示历史记录的某个列表中存储大量这些容器对象。因此，容器最终可能会成为同一类的对象。该类几乎没有方法，但有很多反映编辑器状态的字段。若要允许其他对象在快照中写入和读取数据，可能需要将其字段设为公共字段。这将暴露编辑器的所有状态，无论是否私密。其他类将依赖于对快照类的每一个微小更改，否则这将发生在私有字段和方法中，而不会影响外部类。</p>
<p>看起来我们已经走到了死胡同：你要么暴露类的所有内部细节，使它们过于脆弱，要么限制对它们的状态的访问，使其无法生成快照。有没有其他方法可以实现“撤消”？</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>我们刚刚遇到的所有问题都是由封装损坏引起的。有些对象试图做比它们应该做的更多的事情。为了收集执行某些操作所需的数据，它们会侵入其他对象的私有空间，而不是让这些对象执行实际操作。</p>
<p>Memento 模式将创建状态快照的任务委托给该状态的实际所有者，即发起方对象。因此，编辑器类本身可以制作快照，而不是其他对象试图从“外部”复制编辑器的状态，因为它对自己的状态具有完全访问权限。</p>
<p>该模式建议将对象状态的副本存储在称为 memento 的特殊对象中。纪念品的内容除了制作纪念品的对象外，任何其他对象都无法访问。其他对象必须使用有限的接口与纪念品进行通信，该接口可能允许获取快照的元数据（创建时间、所执行操作的名称等），但不允许获取快照中包含的原始对象的状态。</p>
<div align="center"> <img src="/images/memento-solution.png"/>创建者可以完全访问纪念品，而管理员只能访问元数据。</div>


<p>这种限制性政策允许您将纪念品存放在其他物体中，通常称为看守人。由于管理员只能通过有限的界面处理纪念品，因此它无法篡改存储在纪念品中的状态。同时，发起者可以访问纪念品内的所有字段，允许它随意恢复之前的状态。</p>
<p>在我们的文本编辑器示例中，我们可以创建一个单独的历史类来充当看守人。每次编辑器将要执行操作时，存储在管理员内部的一堆纪念品都会增加。您甚至可以在应用程序的 UI 中呈现此堆栈，向用户显示以前执行的操作的历史记录。</p>
<p>当用户触发撤消时，历史记录会从堆栈中获取最新的纪念品，并将其传递回编辑器，请求回滚。由于编辑器可以完全访问纪念品，因此它会使用从纪念品中获取的值来更改自己的状态。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><h4 id="Implementation-based-on-nested-classes"><a href="#Implementation-based-on-nested-classes" class="headerlink" title="Implementation based on nested classes"></a>Implementation based on nested classes</h4><p>基于嵌套类的实现</p>
<p>该模式的经典实现依赖于对嵌套类的支持，嵌套类在许多流行的编程语言（如 C++、C# 和 Java）中都可用。</p>
<div align="center"> <img src="/images/memento-structure.png"/></div>


<ol>
<li><p>Originator 类可以生成其自身状态的快照，并在需要时从快照还原其状态。</p>
</li>
<li><p>Memento 是一个值对象，充当发起方状态的快照。通常的做法是使 memento 不可变，并且仅通过构造函数向其传递一次数据。</p>
</li>
<li><p>看守人不仅知道“何时”和“为什么”捕获发起人的状态，而且知道何时应该恢复状态。</p>
<p>看守人可以通过存储一堆纪念品来跟踪发起人的历史。当始作俑者必须回到历史中时，看守人会从堆栈中取出最上面的纪念品，并将其传递给始作俑者的修复方法。</p>
</li>
<li><p>在此实现中，memento 类嵌套在发起方中。这允许发起方访问 memento 的字段和方法，即使它们被声明为私有。另一方面，看守人对纪念品的领域和方法的访问非常有限，这使得它可以将纪念品存储在堆栈中，但不能篡改它们的状态。</p>
</li>
</ol>
<h4 id="Implementation-based-on-an-intermediate-interface"><a href="#Implementation-based-on-an-intermediate-interface" class="headerlink" title="Implementation based on an intermediate interface"></a>Implementation based on an intermediate interface</h4><p>基于中间接口的实现</p>
<p>还有一种替代实现，适用于不支持嵌套类的编程语言(是的，PHP，我说的就是你)。</p>
<div align="center"> <img src="/images/memento-structure2.png"/></div>


<ol>
<li>在没有嵌套类的情况下，您可以通过建立一种约定来限制对 memento 字段的访问，该约定使管理员只能通过显式声明的中间接口来处理 memento，该接口将仅声明与 memento 的元数据相关的方法。</li>
<li>另一方面，发起人可以直接使用 memento 对象，访问 memento 类中声明的字段和方法。这种方法的缺点是您需要公开声明纪念品的所有成员。</li>
</ol>
<h4 id="Implementation-with-even-stricter-encapsulation-实现更严格的封装"><a href="#Implementation-with-even-stricter-encapsulation-实现更严格的封装" class="headerlink" title="Implementation with even stricter encapsulation 实现更严格的封装"></a>Implementation with even stricter encapsulation 实现更严格的封装</h4><p>当您不想让其他类通过纪念品访问发起者的状态时，还有另一种实现非常有用。</p>
<div align="center"> <img src="/images/memento-structure3.png"/></div>


<ol>
<li>此实现允许具有多种类型的发起人和纪念品。每个发起人都使用相应的纪念品类。无论是发起人还是纪念品都不会向任何人暴露他们的状态。</li>
<li>现在，看护人被明确限制更改存储在纪念品中的状态。此外，看守人类独立于发起人，因为恢复方法现在在纪念品类中定义。</li>
<li>每个纪念品都与制作它的发起人联系在一起。发起者将自己连同其状态的值一起传递给纪念品的构造者。由于这些类之间的密切关系，纪念品可以恢复其创建者的状态，因为后者已经定义了适当的设置者。</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>此示例将 Memento 模式与 Command 模式一起使用，用于存储复杂文本编辑器状态的快照，并在需要时从这些快照恢复早期状态。memento-example1</p>
<div align="center"> <img src="/images/memento-example1.png"/>保存文本编辑器状态的快照。</div>


<p>命令对象充当看守人。它们在执行与命令相关的操作之前获取编辑器的纪念品。当用户尝试撤消最近的命令时，编辑器可以使用该命令中存储的 memento 将自身恢复到以前的状态。</p>
<p>memento 类不声明任何公共字段、getter 或 setter。因此，任何对象都不能更改其内容。纪念品链接到创建它们的编辑器对象。这允许 memento 通过编辑器对象上的 setter 传递数据来恢复链接编辑器的状态。由于纪念品链接到特定的编辑器对象，因此您可以使用集中式撤消堆栈使应用支持多个独立的编辑器窗口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The originator holds some important data that may change over</span></span><br><span class="line"><span class="comment">// time. It also defines a method for saving its state inside a</span></span><br><span class="line"><span class="comment">// memento and another method for restoring the state from it.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Editor</span> is</span><br><span class="line">    <span class="keyword">private</span> field text, curX, curY, selectionWidth</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setText</span><span class="params">(text)</span> is</span><br><span class="line">        <span class="built_in">this</span>.text = text</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setCursor</span><span class="params">(x, y)</span> is</span><br><span class="line">        <span class="built_in">this</span>.curX = x</span><br><span class="line">        <span class="built_in">this</span>.curY = y</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setSelectionWidth</span><span class="params">(width)</span> is</span><br><span class="line">        <span class="built_in">this</span>.selectionWidth = width</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Saves the current state inside a memento.</span></span><br><span class="line">    method <span class="title function_">createSnapshot</span><span class="params">()</span>:Snapshot is</span><br><span class="line">        <span class="comment">// Memento is an immutable object; that&#x27;s why the</span></span><br><span class="line">        <span class="comment">// originator passes its state to the memento&#x27;s</span></span><br><span class="line">        <span class="comment">// constructor parameters.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(<span class="built_in">this</span>, text, curX, curY, selectionWidth)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The memento class stores the past state of the editor.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snapshot</span> is</span><br><span class="line">    <span class="keyword">private</span> field editor: Editor</span><br><span class="line">    <span class="keyword">private</span> field text, curX, curY, selectionWidth</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Snapshot</span><span class="params">(editor, text, curX, curY, selectionWidth)</span> is</span><br><span class="line">        <span class="built_in">this</span>.editor = editor</span><br><span class="line">        <span class="built_in">this</span>.text = text</span><br><span class="line">        <span class="built_in">this</span>.curX = x</span><br><span class="line">        <span class="built_in">this</span>.curY = y</span><br><span class="line">        <span class="built_in">this</span>.selectionWidth = selectionWidth</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At some point, a previous state of the editor can be</span></span><br><span class="line">    <span class="comment">// restored using a memento object.</span></span><br><span class="line">    method <span class="title function_">restore</span><span class="params">()</span> is</span><br><span class="line">        editor.setText(text)</span><br><span class="line">        editor.setCursor(curX, curY)</span><br><span class="line">        editor.setSelectionWidth(selectionWidth)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A command object can act as a caretaker. In that case, the</span></span><br><span class="line"><span class="comment">// command gets a memento just before it changes the</span></span><br><span class="line"><span class="comment">// originator&#x27;s state. When undo is requested, it restores the</span></span><br><span class="line"><span class="comment">// originator&#x27;s state from a memento.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> is</span><br><span class="line">    <span class="keyword">private</span> field backup: Snapshot</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">makeBackup</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">backup</span> <span class="operator">=</span> editor.createSnapshot()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">undo</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(backup != <span class="literal">null</span>)</span></span><br><span class="line">            backup.restore()</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li>当您希望生成对象状态的快照以便能够恢复对象的先前状态时，请使用Memento模式。</li>
<li>Memento 模式允许您创建对象状态的完整副本（包括私有字段），并将它们与对象分开存储。虽然由于“撤消”用例，大多数人都记得这种模式，但在处理事务时（即，如果您需要在错误时回滚操作）时，它也是必不可少的。</li>
<li>当直接访问对象的字段&#x2F;getter&#x2F;setter 违反其封装时，请使用该模式。</li>
<li>Memento 使对象本身负责创建其状态的快照。没有其他对象可以读取快照，从而确保原始对象的状态数据安全可靠。</li>
</ul>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>确定哪个类将扮演发起人的角色。重要的是要知道程序是使用此类型的一个中心对象还是多个较小的对象。</p>
</li>
<li><p>创建 memento 类。逐个声明一组字段，这些字段镜像在发起方类中声明的字段。</p>
</li>
<li><p>使 memento 类不可变。纪念品应该只通过构造函数接受一次数据。该类不应有二传手。</p>
</li>
<li><p>如果您的编程语言支持嵌套类，请将 memento 嵌套在发起方中。如果没有，请从 memento 类中提取一个空白接口，并使所有其他对象使用它来引用 memento。您可以向接口添加一些元数据操作，但不会公开发起方的状态。</p>
</li>
<li><p>将用于生成纪念品的方法添加到 originator 类。发起人应通过纪念品构造函数的一个或多个参数将其状态传递给纪念品。</p>
<p>该方法的返回类型应该是您在前一步中提取的接口(假设您提取了它)。在底层，纪念品生成方法应该直接与纪念品类一起工作。</p>
</li>
<li><p>添加一个将发起人状态恢复到其类的方法。它应该接受纪念品对象作为参数。如果在前面的步骤中提取了一个接口，请将其作为参数的类型。在这种情况下，您需要将传入对象类型转换为memorento类，因为发起者需要对该对象进行完全访问。</p>
</li>
<li><p>看守人，无论它代表的是命令对象、历史记录还是完全不同的东西，都应该知道何时向发起人请求新的纪念品，如何存储它们，以及何时使用特定的纪念品恢复发起人。</p>
</li>
<li><p>看护人和发起人之间的联系可以移到纪念品类中。在这种情况下，每个纪念品都必须连接到创建它的发起人。恢复方法也将转移到纪念品类。但是，只有当 memento 类嵌套在 originator 中，或者 originator 类提供足够的 setter 来覆盖其状态时，这才有意义。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>优点√</th>
<th>缺点×</th>
</tr>
</thead>
<tbody><tr>
<td>您可以在不违反其封装的情况下生成对象状态的快照。</td>
<td>如果客户端过于频繁地创建纪念品，则该应用程序可能会消耗大量 RAM。</td>
</tr>
<tr>
<td>您可以通过让管理员维护发起方状态的历史记录来简化发起方的代码。</td>
<td>看护人应跟踪发起人的生命周期，以便能够销毁过时的纪念品。</td>
</tr>
<tr>
<td></td>
<td>大多数动态编程语言，如 PHP、Python 和 JavaScript，都不能保证 memento 中的状态保持不变。</td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li>在实现“撤消”时，您可以同时使用 Command 和 Memento。在这种情况下，命令负责对目标对象执行各种操作，而纪念品则在执行命令之前保存该对象的状态。</li>
<li>您可以将 Memento 与 Iterator 一起使用来捕获当前迭代状态，并在必要时回滚。</li>
<li>有时，Prototype 可以成为 Memento 的更简单替代品。如果要存储在历史记录中的对象的状态相当简单，并且没有指向外部资源的链接，或者链接易于重新建立，则此方法有效。</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h1 id="Memento-in-Python"><a href="#Memento-in-Python" class="headerlink" title="Memento in Python"></a><strong>Memento</strong> in Python</h1><p>Memento 是一种行为设计模式，允许制作对象状态的快照并在将来恢复它。</p>
<p>Memento 不会损害它所处理的对象的内部结构，以及保存在快照中的数据。</p>
<p>使用示例：Memento的原理可以通过序列化来实现，这在Python中很常见。虽然它不是制作对象状态快照的唯一和最有效的方法，但它仍然允许存储状态备份，同时保护发起方的结构免受其他对象的影响。</p>
<h2 id="Conceptual-Example-概念示例"><a href="#Conceptual-Example-概念示例" class="headerlink" title="Conceptual Example 概念示例"></a>Conceptual Example 概念示例</h2><p>此示例说明了 Memento 设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>它由哪些类组成？</li>
<li>这些课程扮演什么角色？</li>
<li>模式的元素以何种方式相关？</li>
</ul>
<h4 id="main-py：概念示例"><a href="#main-py：概念示例" class="headerlink" title="main.py：概念示例"></a>main.py：概念示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> sample</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> ascii_letters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Originator holds some important state that may change over time. It also</span></span><br><span class="line"><span class="string">    defines a method for saving the state inside a memento and another method</span></span><br><span class="line"><span class="string">    for restoring the state from it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _state = <span class="literal">None</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    For the sake of simplicity, the originator&#x27;s state is stored inside a single</span></span><br><span class="line"><span class="string">    variable.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._state = state</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Originator: My initial state is: <span class="subst">&#123;self._state&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Originator&#x27;s business logic may affect its internal state.</span></span><br><span class="line"><span class="string">        Therefore, the client should backup the state before launching methods</span></span><br><span class="line"><span class="string">        of the business logic via the save() method.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Originator: I&#x27;m doing something important.&quot;</span>)</span><br><span class="line">        self._state = self._generate_random_string(<span class="number">30</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Originator: and my state has changed to: <span class="subst">&#123;self._state&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_generate_random_string</span>(<span class="params">length: <span class="built_in">int</span> = <span class="number">10</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(sample(ascii_letters, length))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>) -&gt; Memento:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Saves the current state inside a memento.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConcreteMemento(self._state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restore</span>(<span class="params">self, memento: Memento</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Restores the Originator&#x27;s state from a memento object.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self._state = memento.get_state()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Originator: My state has changed to: <span class="subst">&#123;self._state&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Memento interface provides a way to retrieve the memento&#x27;s metadata,</span></span><br><span class="line"><span class="string">    such as creation date or name. However, it doesn&#x27;t expose the Originator&#x27;s</span></span><br><span class="line"><span class="string">    state.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_date</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMemento</span>(<span class="title class_ inherited__">Memento</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._state = state</span><br><span class="line">        self._date = <span class="built_in">str</span>(datetime.now())[:<span class="number">19</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_state</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Originator uses this method when restoring its state.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The rest of the methods are used by the Caretaker to display metadata.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self._date&#125;</span> / (<span class="subst">&#123;self._state[<span class="number">0</span>:<span class="number">9</span>]&#125;</span>...)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_date</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> self._date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Caretaker doesn&#x27;t depend on the Concrete Memento class. Therefore, it</span></span><br><span class="line"><span class="string">    doesn&#x27;t have access to the originator&#x27;s state, stored inside the memento. It</span></span><br><span class="line"><span class="string">    works with all mementos via the base Memento interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, originator: Originator</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._mementos = []</span><br><span class="line">        self._originator = originator</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backup</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nCaretaker: Saving Originator&#x27;s state...&quot;</span>)</span><br><span class="line">        self._mementos.append(self._originator.save())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">undo</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(self._mementos):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        memento = self._mementos.pop()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Caretaker: Restoring state to: <span class="subst">&#123;memento.get_name()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._originator.restore(memento)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            self.undo()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_history</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Caretaker: Here&#x27;s the list of mementos:&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> memento <span class="keyword">in</span> self._mementos:</span><br><span class="line">            <span class="built_in">print</span>(memento.get_name())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    originator = Originator(<span class="string">&quot;Super-duper-super-puper-super.&quot;</span>)</span><br><span class="line">    caretaker = Caretaker(originator)</span><br><span class="line"></span><br><span class="line">    caretaker.backup()</span><br><span class="line">    originator.do_something()</span><br><span class="line"></span><br><span class="line">    caretaker.backup()</span><br><span class="line">    originator.do_something()</span><br><span class="line"></span><br><span class="line">    caretaker.backup()</span><br><span class="line">    originator.do_something()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    caretaker.show_history()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nClient: Now, let&#x27;s rollback!\n&quot;</span>)</span><br><span class="line">    caretaker.undo()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nClient: Once more!\n&quot;</span>)</span><br><span class="line">    caretaker.undo()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a><strong>Output.txt:</strong> Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Originator: My initial state is: Super-duper-super-puper-super.</span><br><span class="line"></span><br><span class="line">Caretaker: Saving Originator&#x27;s state...</span><br><span class="line">Originator: I&#x27;m doing something important.</span><br><span class="line">Originator: and my state has changed to: wQAehHYOqVSlpEXjyIcgobrxsZUnat</span><br><span class="line"></span><br><span class="line">Caretaker: Saving Originator&#x27;s state...</span><br><span class="line">Originator: I&#x27;m doing something important.</span><br><span class="line">Originator: and my state has changed to: lHxNORKcsgMWYnJqoXjVCbQLEIeiSp</span><br><span class="line"></span><br><span class="line">Caretaker: Saving Originator&#x27;s state...</span><br><span class="line">Originator: I&#x27;m doing something important.</span><br><span class="line">Originator: and my state has changed to: cvIYsRilNOtwynaKdEZpDCQkFAXVMf</span><br><span class="line"></span><br><span class="line">Caretaker: Here&#x27;s the list of mementos:</span><br><span class="line">2019-01-26 21:11:24 / (Super-dup...)</span><br><span class="line">2019-01-26 21:11:24 / (wQAehHYOq...)</span><br><span class="line">2019-01-26 21:11:24 / (lHxNORKcs...)</span><br><span class="line"></span><br><span class="line">Client: Now, let&#x27;s rollback!</span><br><span class="line"></span><br><span class="line">Caretaker: Restoring state to: 2019-01-26 21:11:24 / (lHxNORKcs...)</span><br><span class="line">Originator: My state has changed to: lHxNORKcsgMWYnJqoXjVCbQLEIeiSp</span><br><span class="line"></span><br><span class="line">Client: Once more!</span><br><span class="line"></span><br><span class="line">Caretaker: Restoring state to: 2019-01-26 21:11:24 / (wQAehHYOq...)</span><br><span class="line">Originator: My state has changed to: wQAehHYOqVSlpEXjyIcgobrxsZUnat</span><br></pre></td></tr></table></figure>

<h1 id="Memento-in-Rust"><a href="#Memento-in-Rust" class="headerlink" title="Memento in Rust"></a><strong>Memento</strong> in Rust</h1><p>Memento 是一种行为设计模式，允许制作对象状态的快照并在将来恢复它。</p>
<h2 id="Conceptual-example-概念示例"><a href="#Conceptual-example-概念示例" class="headerlink" title="Conceptual example 概念示例"></a>Conceptual example 概念示例</h2><p>这是 Memento 模式的概念示例。</p>
<h4 id="conceptual-rs"><a href="#conceptual-rs" class="headerlink" title="conceptual.rs"></a><strong>conceptual.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Memento</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">restore</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    state: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">save</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> OriginatorBackup &#123;</span><br><span class="line">        OriginatorBackup &#123;</span><br><span class="line">            state: <span class="keyword">self</span>.state.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OriginatorBackup</span> &#123;</span><br><span class="line">    state: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Memento</span>&lt;Originator&gt; <span class="keyword">for</span> <span class="title class_">OriginatorBackup</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">restore</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Originator &#123;</span><br><span class="line">        Originator &#123;</span><br><span class="line">            state: <span class="keyword">self</span>.state.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Originator backup: &#x27;&#123;&#125;&#x27;&quot;</span>, <span class="keyword">self</span>.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">history</span> = <span class="type">Vec</span>::&lt;OriginatorBackup&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">originator</span> = Originator &#123; state: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    originator.state = <span class="number">1</span>;</span><br><span class="line">    history.<span class="title function_ invoke__">push</span>(originator.<span class="title function_ invoke__">save</span>());</span><br><span class="line"></span><br><span class="line">    originator.state = <span class="number">2</span>;</span><br><span class="line">    history.<span class="title function_ invoke__">push</span>(originator.<span class="title function_ invoke__">save</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">moment</span> <span class="keyword">in</span> history.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        moment.<span class="title function_ invoke__">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">originator</span> = history.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">restore</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Restored to state: &#123;&#125;&quot;</span>, originator.state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">originator</span> = history.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">restore</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Restored to state: &#123;&#125;&quot;</span>, originator.state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Originator backup: &#x27;1&#x27;</span><br><span class="line">Originator backup: &#x27;2&#x27;</span><br><span class="line">Restored to state: 2</span><br><span class="line">Restored to state: 1</span><br></pre></td></tr></table></figure>

<h2 id="Serde-序列化框架"><a href="#Serde-序列化框架" class="headerlink" title="Serde 序列化框架"></a>Serde 序列化框架</h2><p>使结构可序列化的一种常见方法是从 serde 序列化框架派生 使结构可序列化的一种常见方法是从 serde 序列化框架派生 <code>Serialize</code> 和  和  和 <code>Deserialize</code> 特征。然后，可序列化类型的对象可以转换为许多不同的格式，e.g. JSON使用serde_json crate。 特征。然后，可序列化类型的对象可以转换为许多不同的格式，e.g. JSON使用serde_json crate。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    state: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="serde-rs"><a href="#serde-rs" class="headerlink" title="serde.rs"></a><strong>serde.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An object to be stored. It derives a default</span></span><br><span class="line"><span class="comment">/// `Serialize` and `Deserialize` trait implementation, which</span></span><br><span class="line"><span class="comment">/// allows to convert it into many different formats (e.g. JSON).</span></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    state: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    <span class="comment">/// Serializes an originator into a string of JSON format.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">save</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        serde_json::<span class="title function_ invoke__">to_string</span>(<span class="keyword">self</span>).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Deserializes an originator into a string of JSON format.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">restore</span>(json: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        serde_json::<span class="title function_ invoke__">from_str</span>(json).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// A stack of mementos.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">history</span> = <span class="type">Vec</span>::&lt;<span class="type">String</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">originator</span> = Originator &#123; state: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    originator.state = <span class="number">1</span>;</span><br><span class="line">    history.<span class="title function_ invoke__">push</span>(originator.<span class="title function_ invoke__">save</span>());</span><br><span class="line"></span><br><span class="line">    originator.state = <span class="number">2</span>;</span><br><span class="line">    history.<span class="title function_ invoke__">push</span>(originator.<span class="title function_ invoke__">save</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">moment</span> <span class="keyword">in</span> history.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, moment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">originator</span> = Originator::<span class="title function_ invoke__">restore</span>(&amp;history.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Restored to state: &#123;&#125;&quot;</span>, originator.state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">originator</span> = Originator::<span class="title function_ invoke__">restore</span>(&amp;history.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Restored to state: &#123;&#125;&quot;</span>, originator.state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Output-输出-1"><a href="#Output-输出-1" class="headerlink" title="Output 输出"></a>Output 输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;state&quot;:1&#125;</span><br><span class="line">&#123;&quot;state&quot;:2&#125;</span><br><span class="line">Restored to state: 2</span><br><span class="line">Restored to state: 1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>探索大型语言模型的世界</title>
    <url>/2024/04/27/design-pattern/navigating-the-world-of-large-language-models/</url>
    <content><![CDATA[<h4 id="探索大型语言模型的世界"><a href="#探索大型语言模型的世界" class="headerlink" title="探索大型语言模型的世界"></a>探索大型语言模型的世界</h4><p><em>2024年3月21日，由Sherlock Xu撰写</em></p>
<p>过去一年，AI界因大型语言模型（LLMs）的快速发布而热闹非凡，每个新模型都带来了推动生成性AI可能性边界的进步。新模型层出不穷，令人叹为观止。就在上周末，xAI公司发布了其Grok语言模型，这是一个拥有3140亿参数的巨兽，并在Apache 2.0许可下发布。</p>
<p>这些模型，由不断增加的参数数量和庞大的数据集训练，提高了我们生成文本和编写（以及理解）复杂代码的效率。然而，可用选项的数量既令人兴奋又令人生畏。做出明智的决策，考虑输出质量、速度和成本，成为了一个问题。</p>
<p>答案不仅在于规格表或基准测试分数，而且在于全面理解每个模型带来的贡献。在这篇博客文章中，我们精选了过去一年引起轰动的LLMs列表。同时，我们试图回答一些常见问题。</p>
<h4 id="Llama-2"><a href="#Llama-2" class="headerlink" title="Llama 2"></a>Llama 2</h4><p>Meta AI在LLMs领域取得了重大进展，发布了Llama 2，这是一个预训练的文本生成模型，有7亿、13亿和70亿参数的版本。它可以用于广泛的任务，包括聊天机器人和各种自然语言生成应用。Meta还针对特定用例定制了Llama 2，例如Llama Chat和Code Llama。</p>
<p><strong>为什么选择Llama 2</strong>：</p>
<ul>
<li><p><strong>性能</strong>：基于Meta AI的基准测试，Llama 2在理解、推理和一般智能能力方面优于其他开源模型。</p>
</li>
<li><p><strong>微调</strong>：三种不同大小的Llama 2是广泛专门化应用的理想基础。用户可以微调它们以满足特定任务或行业的独特需求（在Hugging Face模型中心有超过12,000个搜索结果为“Llama2”）。这些微调模型不仅为开发人员节省了大量时间和资源，而且还有力地证明了Llama 2的定制和改进能力。</p>
</li>
<li><p><strong>安全性</strong>：Llama 2在设计上注重生成安全响应，拒绝不当请求的表现更佳，非常适合企业和面向公众的应用。在Meta的评估中，7B、13B和70B参数的Llama 2模型展示了显著较低的安全违规百分比（3%和4%），超过了Falcon和ChatGPT（7%）。</p>
</li>
</ul>
<p><strong>Llama 2的挑战</strong>：</p>
<ul>
<li><p><strong>编码能力</strong>：Llama 2在编码任务上的能力不如一些专门化的模型，如Code Llama，特别是在复杂的编程任务上。</p>
</li>
<li><p><strong>预防机制</strong>：如上所述，Llama 2可能因安全考虑而比其他模型更为保守，这种内容生成的立场有时可能过于限制性，限制了动态交互。</p>
</li>
<li><p><strong>多语言限制</strong>：主要在英语数据上训练，Llama 2在处理非英语语言的任务上显示出有限的能力，这可能影响其在多语言环境中的使用。</p>
</li>
</ul>
<h4 id="Mixtral-8x7B"><a href="#Mixtral-8x7B" class="headerlink" title="Mixtral 8x7B"></a>Mixtral 8x7B</h4><p>由Mistral AI在2023年12月发布的Mixtral 8x7B，使用了一个稀疏的专家混合架构。简单来说，它使用许多小型网络，每个网络都专门处理不同的事情。每次任务只有少数这些“专家”工作，使过程高效，而不是每次都使用整个模型的全部能力，从而控制成本和延迟。</p>
<p>Mixtral 8x7B在商业使用下获得Apache 2.0许可，展示了在各种文本生成任务中的卓越多功能性，包括代码生成，并具有针对聊天应用优化的微调变体Mixtral 8x7B Instruct。</p>
<p><strong>为什么选择Mixtral 8x7B</strong>：</p>
<ul>
<li><p><strong>最先进的性能</strong>：Mixtral 8x7B在许多基准测试中超越了像Llama 2 70B和GPT-3.5这样的领先模型。</p>
</li>
<li><p><strong>长上下文窗口</strong>：Mixtral 8x7B的32k令牌上下文窗口显著增强了其处理长对话和复杂文档的能力。这使模型能够处理从详细内容创建到复杂的检索增强生成的各种任务，使其非常适合研究和商业应用。</p>
</li>
<li><p><strong>优化效率</strong>：尽管参数数量大，但它提供了成本效益的推理，与更小的模型相当。</p>
</li>
<li><p><strong>多功能语言支持</strong>：Mixtral 8x7B处理多种语言（法语、德语、西班牙语、意大利语和英语），使其成为全球应用的理想选择。</p>
</li>
</ul>
<p><strong>Mixtral 8x7B的挑战</strong>：</p>
<ul>
<li><p><strong>缺乏内置的监管机制</strong>：没有本地监管，可能存在生成不当或有害内容的风险，特别是当模型被提示敏感或有争议的输入时。打算在内容控制和安全性重要的环境部署此模型的企业应该小心这一点。</p>
</li>
<li><p><strong>硬件要求</strong>：整个参数集需要大量的RAM才能运行，这可能限制了它在低端系统上的应用。</p>
</li>
</ul>
<h4 id="Zephyr-7B"><a href="#Zephyr-7B" class="headerlink" title="Zephyr 7B"></a>Zephyr 7B</h4><p>基于Mistral 7B构建并经过微调的Zephyr 7B，实现了与人类意图更好的对齐，在特定任务和基准测试中超越了其同类。在其发布时，Zephyr-7B-β是MT-Bench和AlpacaEval基准测试中排名最高的7B聊天模型。</p>
<p>Zephyr 7B的训练涉及通过接触大量语言模式和上下文来改进其能力。这个过程使它能够理解复杂查询并生成连贯、与上下文相关的文本，使其成为内容创建、客户支持等多功能工具。</p>
<p><strong>为什么选择Zephyr 7B</strong>：</p>
<ul>
<li><p><strong>效率和性能</strong>：尽管相对于像GPT-3.5或Llama-2-70B这样的巨头来说体积较小，但Zephyr 7B在需要深入理解人类意图的任务中提供可比或更好的性能。</p>
</li>
<li><p><strong>多语言能力</strong>：在多样化的数据集上训练，Zephyr 7B支持多种语言的文本生成和理解，包括但不限于英语、西班牙语、法语、德语、意大利语、葡萄牙语、荷兰语、俄语、中文、日语和韩语。</p>
</li>
<li><p><strong>任务灵活性</strong>：Zephyr 7B擅长执行广泛的语言相关任务，从文本生成和摘要到翻译和情感分析。这使其成为众多应用中高度适应性的工具。</p>
</li>
</ul>
<p><strong>Zephyr 7B的挑战</strong>：</p>
<ul>
<li><p><strong>意图对齐</strong>：虽然Zephyr 7B在与人类意图对齐方面取得了一些进展，但可能需要持续评估和调整以确保其输出满足特定用户需求或道德准则。</p>
</li>
<li><p><strong>适应专业任务</strong>：根据应用情况，可能需要额外的微调来优化Zephyr 7B在专业任务中的性能，如推理、数学和编码。</p>
</li>
</ul>
<h4 id="SOLAR-10-7B"><a href="#SOLAR-10-7B" class="headerlink" title="SOLAR 10.7B"></a>SOLAR 10.7B</h4><p>SOLAR 10.7B是一个拥有107亿参数的大型语言模型，使用称为深度上扩展（DUS）的扩展技术。这简化了扩展过程，无需复杂的训练或推理调整。</p>
<p>SOLAR 10.7B经历了两个微调阶段：指令调整和对齐调整。指令调整增强了其遵循QA格式指令的能力。对齐调整进一步细化了模型，使其更紧密地与人类偏好或强AI输出对齐，利用开源数据集和合成的数学重点对齐数据集。</p>
<p><strong>为什么选择SOLAR 10.7B</strong>：</p>
<ul>
<li><p><strong>多功能性</strong>：像SOLAR 10.7B-Instruct这样的微调变体提供了增强的指令遵循能力，使模型能够用于广泛的应用。</p>
</li>
<li><p><strong>卓越的NLP性能</strong>：SOLAR 10.7B在NLP任务中表现出色，超越了其他预训练模型，如Llama 2和Mistral 7B。</p>
</li>
<li><p><strong>微调</strong>：SOLAR 10.7B是一个理想的微调模型，具有坚实的基线能力。</p>
</li>
</ul>
<p><strong>SOLAR 10.7B的挑战</strong>：</p>
<ul>
<li><p><strong>资源需求</strong>：该模型可能需要大量的计算资源来进行训练和微调。</p>
</li>
<li><p><strong>偏见问题</strong>：模型的输出可能不总是与道德或公平使用原则一致。</p>
</li>
</ul>
<h4 id="Code-Llama"><a href="#Code-Llama" class="headerlink" title="Code Llama"></a>Code Llama</h4><p>在Llama 2上微调的Code Llama是专门为编程任务微调的高级大型语言模型。它被设计为理解并生成多种流行编程语言的代码，包括Python、C++、Java、PHP、Typescript（Javascript）、C#和Bash，使其成为开发人员的理想工具。</p>
<p>该模型有四种大小（7B、13B、34B和70B参数）以适应各种用例，从像实时代码完成这样的低延迟应用使用7B和13B模型，到由34B和70B模型提供的更全面的代码协助。</p>
<p><strong>为什么选择Code Llama</strong>：</p>
<ul>
<li><p><strong>大输入上下文</strong>：Code Llama可以处理高达100,000个令牌的输入，允许更好地理解和操作大型代码库。</p>
</li>
<li><p><strong>多样化的应用</strong>：它被设计用于一系列应用，如代码生成、代码完成、调试，甚至讨论代码，满足软件开发生命周期内的不同需求。</p>
</li>
<li><p><strong>性能</strong>：在大量数据集（70B模型高达1万亿个令牌）上训练的模型，可以提供更准确和与上下文相关的代码建议。Code Llama - Instruct 70B模型甚至在HumanEval测试中得分67.8，高于GPT 4（67.0）。</p>
</li>
</ul>
<p><strong>Code Llama的挑战</strong></p>
<ul>
<li><strong>硬件要求</strong>：较大的模型（34B 和 70B）可能需要大量计算资源才能获得最佳性能，这可能会限制硬件有限的个人或组织的访问。</li>
<li><strong>潜在的错位</strong>：虽然它已经过微调以提高安全性并符合人类意图，但如果监督不当，总是存在生成不适当或恶意代码的风险。</li>
<li><strong>不适用于一般的自然语言任务</strong>：Code Llama 针对编码任务进行了优化，不建议用于更广泛的自然语言处理应用程序。请注意，只有 Code Llama Instruct 经过专门微调，以更好地响应自然语言提示。</li>
</ul>
<h4 id="为什么我应该选择开源模型而不是商业模型？"><a href="#为什么我应该选择开源模型而不是商业模型？" class="headerlink" title="为什么我应该选择开源模型而不是商业模型？"></a>为什么我应该选择开源模型而不是商业模型？</h4><p>这篇博文中列出的所有语言模型都是开源的，所以我相信这是第一个要回答的问题。事实上，开源模式和商业模式之间的选择往往取决于特定的需求和考虑，但前者在以下几个方面可能是更好的选择：</p>
<ul>
<li><strong>高可控性</strong> ：开源模型提供高度的控制，因为用户可以根据需要访问和微调模型。这允许定制和适应特定任务或要求，而这在商业模式中可能无法实现。</li>
<li><strong>数据安全</strong>：开源模型可以在本地运行，也可以在私有云基础设施中运行，使用户能够更好地控制数据安全。对于商业模式，可能会担心数据隐私，因为数据通常需要发送到提供商的服务器进行处理。</li>
<li><strong>成本效益</strong>：利用开源模型可能更具成本效益，尤其是在考虑商业产品所需的 API 调用或令牌的成本时。开源模型可以在没有这些经常性成本的情况下部署，尽管可能需要在基础设施和维护方面进行投资。</li>
<li><strong>社区和协作</strong>：开源模型受益于社区的集体专业知识，从而在协作开发推动下实现快速改进、错误修复和新功能。</li>
<li><strong>无供应商锁定</strong>：依靠开源模型消除了对特定供应商路线图、定价变化或服务可用性的依赖。</li>
</ul>
<h4 id="专用LLMs模型与通用模型相比如何？"><a href="#专用LLMs模型与通用模型相比如何？" class="headerlink" title="专用LLMs模型与通用模型相比如何？"></a>专用LLMs模型与通用模型相比如何？</h4><p>像 Code Llama 这样的专业LLMs公司在其专业领域提供集中的绩效提升。它们旨在在特定任务中表现出色，为这些特定应用程序提供更准确、更相关和更有用的输出。</p>
<p>相比之下，像 Llama 2 这样的通用模型是为了处理各种任务而构建的。虽然它们可能与专用模型的任务特定精度不匹配，但它们广泛的知识库和适应性使它们成为各种应用的有用工具。</p>
<p>专业和通用之间的选择LLMs取决于任务的具体要求。对于精度更重要的高风险或利基任务，专用模型更可取，而通用模型则提供更好的灵活性和广泛的实用性。</p>
<h4 id="LLMs大规模部署时有哪些道德考虑因素？"><a href="#LLMs大规模部署时有哪些道德考虑因素？" class="headerlink" title="LLMs大规模部署时有哪些道德考虑因素？"></a>LLMs大规模部署时有哪些道德考虑因素？</h4><p>道德部署LLMs需要仔细检查偏见、透明度、问责制和滥用的可能性等问题。确保LLMs其训练数据中不存在的现有偏见是一项重大挑战，需要持续保持警惕并改进训练方法。关于如何LLMs做出决策以及他们接受培训的数据的透明度对于建立信任和问责制至关重要，尤其是在高风险应用程序中。</p>
<h4 id="LLMs在生产环境中部署时应考虑什么？"><a href="#LLMs在生产环境中部署时应考虑什么？" class="headerlink" title="LLMs在生产环境中部署时应考虑什么？"></a>LLMs在生产环境中部署时应考虑什么？</h4><p>在生产环境中部署LLMs可能是一个微妙的过程。以下是一些需要考虑的策略：</p>
<ol>
<li>选择正确的模型大小：平衡模型大小与应用程序的延迟和吞吐量要求至关重要。较小的模型可以提供更快的响应并降低计算成本，而较大的模型可以提供更准确和细致的输出。</li>
<li>基础结构注意事项：确保基础结构可以处理计算负载。使用支持 GPU 的云服务或使用量化和修剪技术优化模型有助于管理资源需求。对于没有基础架构专业知识的团队来说，具有自动缩放功能的无服务器平台可能是一个不错的选择。</li>
<li>规划可伸缩性：部署策略应允许根据需要纵向扩展或缩减。使用 Docker 等技术进行容器化和 Kubernetes 编排可以支持可扩展的部署。</li>
<li>构建强大的日志记录和可观测性：实施全面的日志记录和可观测性工具将有助于监控系统的运行状况，并在出现问题时快速诊断问题。</li>
<li>使用 API 实现模块化：API 可以抽象化模型托管、扩展和管理的复杂性。它们还可以促进与现有系统的集成，并允许更轻松的更新和维护。</li>
<li>考虑模型服务框架：BentoML、TensorFlow Serving、TorchServe 或 ONNX Runtime 等框架可以简化部署、提供版本控制并处理请求批处理以提高效率。</li>
</ol>
<h4 id="最后的思考"><a href="#最后的思考" class="headerlink" title="最后的思考"></a>最后的思考</h4><p>当我们在不断扩大的大型语言模型领域中航行时，很明显，它们的潜力才刚刚开始被挖掘。这一领域的快速创新预示着人工智能可以为我们的工作和创造性努力做出更深远的贡献。</p>
<p>展望未来，我认为继续在开源社区中推广 AI 模型、推动造福所有人的进步并确保负责任地使用这些强大工具至关重要。当我们这样做时，希望我们能找到适当的平衡点，在降低风险的同时最大限度地LLMs为社会带来利益。</p>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Observer 观察者模式</title>
    <url>/2024/04/21/design-pattern/observer/</url>
    <content><![CDATA[<p>也称为：Event-Subscriber、Listener</p>
<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p>观察者是一种行为设计模式，可用于定义订阅机制，以通知多个对象它们正在观察的对象发生的任何事件。</p>
<div align="center"> <img src="/images/observer-header.png"/></div>


<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>假设您有两种类型的对象：a 假设您有两种类型的对象：a <code>Customer</code> 和 a  和 a  和 a <code>Store</code> 。客户对特定品牌的产品（例如，它是iPhone的新型号）非常感兴趣，该产品应该很快就会在商店中上市。 。客户对特定品牌的产品（例如，它是iPhone的新型号）非常感兴趣，该产品应该很快就会在商店中上市。</p>
<p>客户可以每天访问商店并检查产品可用性。但是，虽然产品仍在途中，但这些旅行中的大多数都是毫无意义的。</p>
<div align="center"> <img src="/images/observer-comic1.png"/>访问商店与发送垃圾邮件</div>


<p>另一方面，每次有新产品上市时，商店都会向所有客户发送大量电子邮件（可能被视为垃圾邮件）。这将使一些客户免于无休止地前往商店。同时，它会让其他对新产品不感兴趣的客户感到不安。</p>
<p>看起来我们发生了冲突。客户要么浪费时间检查产品可用性，要么商店浪费资源通知错误的客户。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>具有某种有趣状态的对象通常称为 subject，但由于它也会通知其他对象有关其状态的更改，因此我们将其称为 publisher。要跟踪发布者状态更改的所有其他对象称为订阅者。</p>
<p>Observer 模式建议向发布者类添加订阅机制，以便各个对象可以订阅或取消订阅来自该发布者的事件流。不要害怕！一切都不像听起来那么复杂。实际上，这种机制包括 1） 一个数组字段，用于存储对订阅服务器对象的引用列表，以及 2） 几个公共方法，这些方法允许在该列表中添加订阅者和从该列表中删除订阅者。observer-solution1</p>
<div align="center"> <img src="/images/observer-solution1.png"/>订阅机制允许单个对象订阅事件通知。</div>


<p>现在，每当发布者发生重要事件时，它都会遍历其订阅者，并对其对象调用特定的通知方法。</p>
<p>实际应用可能有数十个不同的订阅者类别，这些订阅者类别对跟踪同一发布商类别的事件感兴趣。您不希望将发布者与所有这些类耦合。此外，如果您的发布者类应该被其他人使用，您甚至可能事先不知道其中的一些。</p>
<p>这就是为什么所有订阅者都实现相同的接口，并且发布者仅通过该接口与他们通信至关重要的原因。此接口应声明通知方法以及一组参数，发布者可以使用这些参数将一些上下文数据与通知一起传递。</p>
<div align="center"> <img src="/images/observer-solution2.png"/>Publisher 通过对订阅者的对象调用特定的通知方法来通知订阅者。</div>


<p>如果你的应用有几种不同类型的发布者，并且你想让你的订阅者与所有这些发布者兼容，你可以更进一步，让所有发布者都遵循相同的界面。此接口只需要描述几种订阅方法。该接口将允许订阅者观察发布者的状态，而无需与他们的具体类耦合。</p>
<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><div align="center"> <img src="/images/observer-comic2.png"/>杂志和报纸订阅。</div>


<p>如果您订阅了报纸或杂志，则不再需要去商店查看下一期是否有货。相反，发布者会在发布后立即甚至提前将新问题直接发送到您的邮箱。</p>
<p>出版商维护一个订阅者列表，并知道他们对哪些杂志感兴趣。当订阅者希望阻止出版商向他们发送新杂志时，他们可以随时离开列表。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/observer-structure1.png"/></div>


<ol>
<li>发布服务器向其他对象发出感兴趣的事件。当发布者更改其状态或执行某些行为时，会发生这些事件。发布者包含一个订阅基础结构，允许新订阅者加入，而当前订阅者退出列表。</li>
<li>当新事件发生时，发布者将遍历订阅列表，并调用在每个订阅者对象的订阅者界面中声明的通知方法。</li>
<li>订阅者接口声明通知接口。在大多数情况下，它由单一 订阅者接口声明通知接口。在大多数情况下，它由单一 <code>update</code> 方法组成。该方法可能具有多个参数，这些参数允许发布者在更新时传递一些事件详细信息。 方法组成。该方法可能具有多个参数，这些参数允许发布者在更新时传递一些事件详细信息。</li>
<li>具体订阅者执行一些操作以响应发布者发出的通知。所有这些类都必须实现相同的接口，这样发布者就不会耦合到具体的类。</li>
<li>通常，订阅者需要一些上下文信息才能正确处理更新。因此，发布者通常会将一些上下文数据作为通知方法的参数传递。发布者可以将自身作为参数传递，让订阅者直接获取任何所需的数据。</li>
<li>客户端分别创建发布者和订阅者对象，然后为发布者更新注册订阅者。</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>在此示例中，Observer 模式允许文本编辑器对象通知其他服务对象有关其状态的更改。</p>
<div align="center"> <img src="/images/observer-example1.png"/>将其他对象发生的事件通知对象。</div>


<p>订阅者列表是动态编译的：对象可以在运行时启动或停止侦听通知，具体取决于应用的所需行为。</p>
<p>在此实现中，编辑器类本身不维护订阅列表。它将此工作委托给专门用于此工作的特殊帮助程序对象。您可以将该对象升级为集中式事件调度器，让任何对象充当发布者。</p>
<p>向计划添加新订阅者不需要更改现有发布者类，只要它们通过同一界面与所有订阅者协作即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The base publisher class includes subscription management</span></span><br><span class="line"><span class="comment">// code and notification methods.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventManager</span> is</span><br><span class="line">    <span class="keyword">private</span> field listeners: hash map of event types and listeners</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">subscribe</span><span class="params">(eventType, listener)</span> is</span><br><span class="line">        listeners.add(eventType, listener)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">unsubscribe</span><span class="params">(eventType, listener)</span> is</span><br><span class="line">        listeners.remove(eventType, listener)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">notify</span><span class="params">(eventType, data)</span> is</span><br><span class="line">        <span class="title function_">foreach</span> <span class="params">(listener in listeners.of(eventType)</span>) <span class="keyword">do</span></span><br><span class="line">            listener.update(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The concrete publisher contains real business logic that&#x27;s</span></span><br><span class="line"><span class="comment">// interesting for some subscribers. We could derive this class</span></span><br><span class="line"><span class="comment">// from the base publisher, but that isn&#x27;t always possible in</span></span><br><span class="line"><span class="comment">// real life because the concrete publisher might already be a</span></span><br><span class="line"><span class="comment">// subclass. In this case, you can patch the subscription logic</span></span><br><span class="line"><span class="comment">// in with composition, as we did here.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Editor</span> is</span><br><span class="line">    <span class="keyword">public</span> field events: EventManager</span><br><span class="line">    <span class="keyword">private</span> field file: File</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Editor</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">events</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventManager</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods of business logic can notify subscribers about</span></span><br><span class="line">    <span class="comment">// changes.</span></span><br><span class="line">    method <span class="title function_">openFile</span><span class="params">(path)</span> is</span><br><span class="line">        <span class="built_in">this</span>.file = <span class="keyword">new</span> <span class="title class_">File</span>(path)</span><br><span class="line">        events.notify(<span class="string">&quot;open&quot;</span>, file.name)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">saveFile</span><span class="params">()</span> is</span><br><span class="line">        file.write()</span><br><span class="line">        events.notify(<span class="string">&quot;save&quot;</span>, file.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Here&#x27;s the subscriber interface. If your programming language</span></span><br><span class="line"><span class="comment">// supports functional types, you can replace the whole</span></span><br><span class="line"><span class="comment">// subscriber hierarchy with a set of functions.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">EventListener</span> is</span><br><span class="line">    method <span class="title function_">update</span><span class="params">(filename)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete subscribers react to updates issued by the publisher</span></span><br><span class="line"><span class="comment">// they are attached to.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingListener</span> <span class="keyword">implements</span> <span class="title class_">EventListener</span> is</span><br><span class="line">    <span class="keyword">private</span> field log: File</span><br><span class="line">    <span class="keyword">private</span> field message: string</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">LoggingListener</span><span class="params">(log_filename, message)</span> is</span><br><span class="line">        <span class="built_in">this</span>.log = <span class="keyword">new</span> <span class="title class_">File</span>(log_filename)</span><br><span class="line">        <span class="built_in">this</span>.message = message</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">update</span><span class="params">(filename)</span> is</span><br><span class="line">        log.write(replace(<span class="string">&#x27;%s&#x27;</span>,filename,message))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailAlertsListener</span> <span class="keyword">implements</span> <span class="title class_">EventListener</span> is</span><br><span class="line">    <span class="keyword">private</span> field email: string</span><br><span class="line">    <span class="keyword">private</span> field message: string</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">EmailAlertsListener</span><span class="params">(email, message)</span> is</span><br><span class="line">        <span class="built_in">this</span>.email = email</span><br><span class="line">        <span class="built_in">this</span>.message = message</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">update</span><span class="params">(filename)</span> is</span><br><span class="line">        system.email(email, replace(<span class="string">&#x27;%s&#x27;</span>,filename,message))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// An application can configure publishers and subscribers at</span></span><br><span class="line"><span class="comment">// runtime.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    method <span class="title function_">config</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">editor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Editor</span>()</span><br><span class="line"></span><br><span class="line">        logger = <span class="keyword">new</span> <span class="title class_">LoggingListener</span>(</span><br><span class="line">            <span class="string">&quot;/path/to/log.txt&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Someone has opened the file: %s&quot;</span>)</span><br><span class="line">        editor.events.subscribe(<span class="string">&quot;open&quot;</span>, logger)</span><br><span class="line"></span><br><span class="line">        emailAlerts = <span class="keyword">new</span> <span class="title class_">EmailAlertsListener</span>(</span><br><span class="line">            <span class="string">&quot;admin@example.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Someone has changed the file: %s&quot;</span>)</span><br><span class="line">        editor.events.subscribe(<span class="string">&quot;save&quot;</span>, emailAlerts)</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p>当对一个对象的状态的更改可能需要更改其他对象，并且实际的对象集事先未知或动态更改时，请使用 Observer 模式。</p>
</li>
<li><p>在使用图形用户界面的类时，经常会遇到此问题。例如，您创建了自定义按钮类，并且希望让客户端将一些自定义代码挂接到您的按钮上，以便在用户按下按钮时触发该代码。</p>
<p>Observer 模式允许任何实现订阅者接口的对象订阅发布者对象中的事件通知。您可以将订阅机制添加到按钮中，让客户端通过自定义订阅者类挂接其自定义代码。</p>
</li>
<li><p>当应用中的某些对象必须观察其他对象时，请使用该模式，但仅限于有限时间或特定情况。</p>
</li>
<li><p>订阅列表是动态的，因此订阅者可以随时加入或退出列表。</p>
</li>
</ul>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>查看您的业务逻辑并尝试将其分解为两部分：独立于其他代码的核心功能将充当发布者;其余的将变成一组订阅者类。</p>
</li>
<li><p>声明订阅者接口。至少，它应该声明一个 声明订阅者接口。至少，它应该声明一个 <code>update</code> 方法。 方法。</p>
</li>
<li><p>声明发布者接口，并描述一对用于向列表中添加订阅服务器对象并将其从列表中删除的方法。请记住，发布者只能通过订阅者界面与订阅者合作。</p>
</li>
<li><p>确定将实际订阅列表和订阅方法的实现放在何处。通常，对于所有类型的发布者，此代码看起来都相同，因此将其放在直接从发布者接口派生的抽象类中。具体发布者扩展该类，继承订阅行为。</p>
<p>但是，如果要将该模式应用于现有类层次结构，请考虑一种基于组合的方法：将订阅逻辑放入一个单独的对象中，并让所有真正的发布者都使用它。</p>
</li>
<li><p>创建具体的发布者类。每当发布者内部发生重要事件时，它都必须通知其所有订阅者。</p>
</li>
<li><p>在具体的订阅服务器类中实现更新通知方法。大多数订阅者需要有关事件的一些上下文数据。它可以作为通知方法的参数传递。</p>
<p>但还有另一种选择。收到通知后，订阅者可以直接从通知中获取任何数据。在这种情况下，发布者必须通过 update 方法传递自身。不太灵活的选项是通过构造函数将发布者永久链接到订阅者。</p>
</li>
<li><p>客户端必须创建所有必要的订阅者，并将其注册到适当的发布者。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>优点√</th>
<th>缺点×</th>
</tr>
</thead>
<tbody><tr>
<td>开&#x2F;闭原则。可以引入新的订阅者类，而无需更改发布者的代码（如果有发布者接口，则反之亦然）。</td>
<td>订阅者将按随机顺序收到通知。</td>
</tr>
<tr>
<td>您可以在运行时建立对象之间的关系。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns"><a href="#Relations-with-Other-Patterns" class="headerlink" title="Relations with Other Patterns"></a>Relations with Other Patterns</h2><p>与其他模式的关系</p>
<ul>
<li><p>责任链、指挥、调解和观察者解决了连接请求发送者和接收者的各种方式：</p>
<ul>
<li>责任链沿着潜在接收方的动态链按顺序传递请求，直到其中一个接收方处理该请求。</li>
<li>命令在发送方和接收方之间建立单向连接。</li>
<li>Mediator 消除了发送方和接收方之间的直接连接，迫使它们通过 Mediator 对象进行间接通信。</li>
<li>Observer 允许接收方动态订阅和取消订阅接收请求。</li>
</ul>
</li>
<li><p>调解员和观察者之间的区别往往是难以捉摸的。在大多数情况下，您可以实现其中任一模式;但有时您可以同时应用两者。让我们看看如何做到这一点。</p>
<p>Mediator 的主要目标是消除一组系统组件之间的相互依赖关系。相反，这些组件依赖于单个中介对象。Observer 的目标是在对象之间建立动态的单向连接，其中某些对象充当其他对象的从属。</p>
<p>有一种依赖于 Observer 的 Mediator 模式的流行实现。中介对象扮演发布者的角色，组件充当订阅者，订阅和取消订阅中介的事件。当 Mediator 以这种方式实现时，它可能看起来与 Observer 非常相似。</p>
<p>当您感到困惑时，请记住，您可以通过其他方式实现 Mediator 模式。例如，您可以将所有组件永久链接到同一个中介对象。此实现与 Observer 不同，但仍是 Mediator 模式的实例。</p>
<p>现在想象一个程序，其中所有组件都已成为发布者，允许彼此之间的动态连接。不会有一个集中的中介对象，只有一组分布式的观察者。</p>
</li>
</ul>
<h1 id="Observer-in-Python"><a href="#Observer-in-Python" class="headerlink" title="Observer in Python"></a><strong>Observer</strong> in Python</h1><p>观察者是一种行为设计模式，它允许某些对象通知其他对象有关其状态的更改。</p>
<p>Observer 模式提供了一种为实现订阅者接口的任何对象订阅和取消订阅这些事件的方法。</p>
<p>使用示例：Observer 模式在 Python 代码中很常见，尤其是在 GUI 组件中。它提供了一种对其他对象中发生的事件做出反应的方法，而无需耦合到它们的类。</p>
<p>标识：可以通过订阅方法（将对象存储在列表中）以及调用向该列表中的对象发出的更新方法来识别该模式。</p>
<h2 id="Conceptual-Example-概念示例"><a href="#Conceptual-Example-概念示例" class="headerlink" title="Conceptual Example 概念示例"></a>Conceptual Example 概念示例</h2><p>此示例说明了 Observer 设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>它由哪些类组成？</li>
<li>这些课程扮演什么角色？</li>
<li>模式的元素以何种方式相关？</li>
</ul>
<h4 id="main-py：概念示例"><a href="#main-py：概念示例" class="headerlink" title="main.py：概念示例"></a>main.py：概念示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Subject interface declares a set of methods for managing subscribers.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attach</span>(<span class="params">self, observer: Observer</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Attach an observer to the subject.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detach</span>(<span class="params">self, observer: Observer</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Detach an observer from the subject.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Notify all observers about an event.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span>(<span class="title class_ inherited__">Subject</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Subject owns some important state and notifies observers when the state</span></span><br><span class="line"><span class="string">    changes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _state: <span class="built_in">int</span> = <span class="literal">None</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    For the sake of simplicity, the Subject&#x27;s state, essential to all</span></span><br><span class="line"><span class="string">    subscribers, is stored in this variable.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _observers: <span class="type">List</span>[Observer] = []</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    List of subscribers. In real life, the list of subscribers can be stored</span></span><br><span class="line"><span class="string">    more comprehensively (categorized by event type, etc.).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attach</span>(<span class="params">self, observer: Observer</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Subject: Attached an observer.&quot;</span>)</span><br><span class="line">        self._observers.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detach</span>(<span class="params">self, observer: Observer</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._observers.remove(observer)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The subscription management methods.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Trigger an update in each subscriber.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Subject: Notifying observers...&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self._observers:</span><br><span class="line">            observer.update(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_business_logic</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Usually, the subscription logic is only a fraction of what a Subject can</span></span><br><span class="line"><span class="string">        really do. Subjects commonly hold some important business logic, that</span></span><br><span class="line"><span class="string">        triggers a notification method whenever something important is about to</span></span><br><span class="line"><span class="string">        happen (or after it).</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nSubject: I&#x27;m doing something important.&quot;</span>)</span><br><span class="line">        self._state = randrange(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Subject: My state has just changed to: <span class="subst">&#123;self._state&#125;</span>&quot;</span>)</span><br><span class="line">        self.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Observer interface declares the update method, used by subjects.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, subject: Subject</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Receive update from subject.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Observers react to the updates issued by the Subject they had been</span></span><br><span class="line"><span class="string">attached to.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserverA</span>(<span class="title class_ inherited__">Observer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, subject: Subject</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> subject._state &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ConcreteObserverA: Reacted to the event&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserverB</span>(<span class="title class_ inherited__">Observer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, subject: Subject</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> subject._state == <span class="number">0</span> <span class="keyword">or</span> subject._state &gt;= <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ConcreteObserverB: Reacted to the event&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code.</span></span><br><span class="line"></span><br><span class="line">    subject = ConcreteSubject()</span><br><span class="line"></span><br><span class="line">    observer_a = ConcreteObserverA()</span><br><span class="line">    subject.attach(observer_a)</span><br><span class="line"></span><br><span class="line">    observer_b = ConcreteObserverB()</span><br><span class="line">    subject.attach(observer_b)</span><br><span class="line"></span><br><span class="line">    subject.some_business_logic()</span><br><span class="line">    subject.some_business_logic()</span><br><span class="line"></span><br><span class="line">    subject.detach(observer_a)</span><br><span class="line"></span><br><span class="line">    subject.some_business_logic()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a><strong>Output.txt:</strong> Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Subject: Attached an observer.</span><br><span class="line">Subject: Attached an observer.</span><br><span class="line"></span><br><span class="line">Subject: I&#x27;m doing something important.</span><br><span class="line">Subject: My state has just changed to: 0</span><br><span class="line">Subject: Notifying observers...</span><br><span class="line">ConcreteObserverA: Reacted to the event</span><br><span class="line">ConcreteObserverB: Reacted to the event</span><br><span class="line"></span><br><span class="line">Subject: I&#x27;m doing something important.</span><br><span class="line">Subject: My state has just changed to: 5</span><br><span class="line">Subject: Notifying observers...</span><br><span class="line">ConcreteObserverB: Reacted to the event</span><br><span class="line"></span><br><span class="line">Subject: I&#x27;m doing something important.</span><br><span class="line">Subject: My state has just changed to: 0</span><br><span class="line">Subject: Notifying observers...</span><br><span class="line">ConcreteObserverB: Reacted to the event</span><br></pre></td></tr></table></figure>

<h1 id="Observer-in-Rust"><a href="#Observer-in-Rust" class="headerlink" title="Observer in Rust"></a><strong>Observer</strong> in Rust</h1><p>观察者是一种行为设计模式，它允许某些对象通知其他对象有关其状态的更改。</p>
<p>Observer 模式提供了一种为实现订阅者接口的任何对象订阅和取消订阅这些事件的方法。</p>
<h2 id="Conceptual-example-概念示例"><a href="#Conceptual-example-概念示例" class="headerlink" title="Conceptual example 概念示例"></a>Conceptual example 概念示例</h2><p>在 Rust 中，定义订阅者的一种便捷方法是将函数作为具有复杂逻辑的可调用对象传递给事件发布者。</p>
<p>在此 Observer 示例中，订阅者是订阅事件的 lambda 函数或显式函数。显式函数对象也可以取消订阅（尽管某些函数类型可能存在限制）。</p>
<h4 id="editor-rs"><a href="#editor-rs" class="headerlink" title="editor.rs"></a><strong>editor.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::observer::&#123;Event, Publisher&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Editor has its own logic and it utilizes a publisher</span></span><br><span class="line"><span class="comment">/// to operate with subscribers and events.</span></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Editor</span> &#123;</span><br><span class="line">    publisher: Publisher,</span><br><span class="line">    file_path: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Editor</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">events</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> Publisher &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.publisher</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, path: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.file_path = path.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">self</span>.publisher.<span class="title function_ invoke__">notify</span>(Event::Load, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">save</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.publisher.<span class="title function_ invoke__">notify</span>(Event::Save, <span class="keyword">self</span>.file_path.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="observer-rs"><a href="#observer-rs" class="headerlink" title="observer.rs"></a><strong>observer.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An event type.</span></span><br><span class="line"><span class="meta">#[derive(PartialEq, Eq, Hash, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    Load,</span><br><span class="line">    Save,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A subscriber (listener) has type of a callable function.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">Subscriber</span> = <span class="title function_ invoke__">fn</span>(file_path: <span class="type">String</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Publisher sends events to subscribers (listeners).</span></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Publisher</span> &#123;</span><br><span class="line">    events: HashMap&lt;Event, <span class="type">Vec</span>&lt;Subscriber&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Publisher</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">subscribe</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_type: Event, listener: Subscriber) &#123;</span><br><span class="line">        <span class="keyword">self</span>.events.<span class="title function_ invoke__">entry</span>(event_type.<span class="title function_ invoke__">clone</span>()).<span class="title function_ invoke__">or_default</span>();</span><br><span class="line">        <span class="keyword">self</span>.events.<span class="title function_ invoke__">get_mut</span>(&amp;event_type).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">push</span>(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unsubscribe</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_type: Event, listener: Subscriber) &#123;</span><br><span class="line">        <span class="keyword">self</span>.events</span><br><span class="line">            .<span class="title function_ invoke__">get_mut</span>(&amp;event_type)</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">            .<span class="title function_ invoke__">retain</span>(|&amp;x| x != listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(&amp;<span class="keyword">self</span>, event_type: Event, file_path: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">listeners</span> = <span class="keyword">self</span>.events.<span class="title function_ invoke__">get</span>(&amp;event_type).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">listener</span> <span class="keyword">in</span> listeners &#123;</span><br><span class="line">            <span class="title function_ invoke__">listener</span>(file_path.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a><strong>main.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> editor::Editor;</span><br><span class="line"><span class="keyword">use</span> observer::Event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> editor;</span><br><span class="line"><span class="keyword">mod</span> observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">editor</span> = Editor::<span class="title function_ invoke__">default</span>();</span><br><span class="line"></span><br><span class="line">    editor.<span class="title function_ invoke__">events</span>().<span class="title function_ invoke__">subscribe</span>(Event::Load, |file_path| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">log</span> = <span class="string">&quot;/path/to/log/file.txt&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Save log to &#123;&#125;: Load file &#123;&#125;&quot;</span>, log, file_path);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    editor.<span class="title function_ invoke__">events</span>().<span class="title function_ invoke__">subscribe</span>(Event::Save, save_listener);</span><br><span class="line"></span><br><span class="line">    editor.<span class="title function_ invoke__">load</span>(<span class="string">&quot;test1.txt&quot;</span>.<span class="title function_ invoke__">into</span>());</span><br><span class="line">    editor.<span class="title function_ invoke__">load</span>(<span class="string">&quot;test2.txt&quot;</span>.<span class="title function_ invoke__">into</span>());</span><br><span class="line">    editor.<span class="title function_ invoke__">save</span>();</span><br><span class="line"></span><br><span class="line">    editor.<span class="title function_ invoke__">events</span>().<span class="title function_ invoke__">unsubscribe</span>(Event::Save, save_listener);</span><br><span class="line">    editor.<span class="title function_ invoke__">save</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">save_listener</span>(file_path: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">email</span> = <span class="string">&quot;admin@example.com&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Email to &#123;&#125;: Save file &#123;&#125;&quot;</span>, email, file_path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Save log to /path/to/log/file.txt: Load file test1.txt</span><br><span class="line">Save log to /path/to/log/file.txt: Load file test2.txt</span><br><span class="line">Email to admin@example.com: Save file test2.txt</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Prototype</title>
    <url>/2023/11/22/design-pattern/prototype/</url>
    <content><![CDATA[<h1 id="Prototype-原型"><a href="#Prototype-原型" class="headerlink" title="Prototype 原型"></a>Prototype 原型</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Prototype</strong> is a creational design pattern that lets you copy existing objects without making your code dependent on their classes.<br>原型是一种创建性设计模式，它允许您复制现有对象，而不会使代码依赖于它们的类。</p>
<div align="center"> <img src="/images/prototype-head.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Say you have an object, and you want to create an exact copy of it. How would you do it? First, you have to create a new object of the same class. Then you have to go through all the fields of the original object and copy their values over to the new object.<br>假设你有一个对象，并且你想创建一个精确的副本。你会怎么做？首先，您必须创建同一类的新对象。然后，您必须遍历原始对象的所有字段，并将其值复制到新对象。</p>
<p>Nice! But there’s a catch. Not all objects can be copied that way because some of the object’s fields may be private and not visible from outside of the object itself.<br>好！但有一个问题。并非所有对象都可以以这种方式复制，因为对象的某些字段可能是私有的，并且从对象本身外部不可见。</p>
<div align="center"> <img src="/images/prototype-comic-1-en.png"/>Copying an object “from the outside” isn’t always possible.</br>“从外部”复制对象并不总是可行的。</div>
There’s one more problem with the direct approach. Since you have to know the object’s class to create a duplicate, your code becomes dependent on that class. If the extra dependency doesn’t scare you, there’s another catch. Sometimes you only know the interface that the object follows, but not its concrete class, when, for example, a parameter in a method accepts any objects that follow some interface.
直接方法还有一个问题。由于您必须知道对象的类才能创建副本，因此您的代码将依赖于该类。如果额外的依赖关系没有吓到你，还有另一个问题。有时，您只知道对象所遵循的接口，而不知道其具体类，例如，当方法中的参数接受某个接口所遵循的任何对象时。

<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The Prototype pattern delegates the cloning process to the actual objects that are being cloned. The pattern declares a common interface for all objects that support cloning. This interface lets you clone an object without coupling your code to the class of that object. Usually, such an interface contains just a single <code>clone</code> method.<br>Prototype 模式将克隆过程委托给正在克隆的实际对象。该模式为支持克隆的所有对象声明一个通用接口。此接口允许您克隆对象，而无需将代码耦合到该对象的类。通常，这样的接口只包含一个 <code>clone</code> 方法。</p>
<p>The implementation of the clone method is very similar in all classes. The method creates an object of the current class and carries over all of the field values of the old object into the new one. You can even copy private fields because most programming languages let objects access private fields of other objects that belong to the same class.<br>该 <code>clone</code> 方法的实现在所有类中都非常相似。该方法创建当前类的对象，并将旧对象的所有字段值转移到新对象中。您甚至可以复制私有字段，因为大多数编程语言允许对象访问属于同一类的其他对象的私有字段。</p>
<p>An object that supports cloning is called a prototype. When your objects have dozens of fields and hundreds of possible configurations, cloning them might serve as an alternative to subclassing.<br>支持克隆的对象称为原型。当您的对象具有数十个字段和数百种可能的配置时，克隆它们可以作为子类化的替代方法。</p>
<div align="center"> <img src="/images/prototype-comic-2-en.png"/>Pre-built prototypes can be an alternative to subclassing.</br>预构建的原型可以替代子类化。</div>
Here’s how it works: you create a set of objects, configured in various ways. When you need an object like the one you’ve configured, you just clone a prototype instead of constructing a new object from scratch.
它是这样工作的：创建一组对象，以各种方式进行配置。当您需要像您配置的对象一样的对象时，您只需克隆一个原型，而不是从头开始构建一个新对象。

<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><p>In real life, prototypes are used for performing various tests before starting mass production of a product. However, in this case, prototypes don’t participate in any actual production, playing a passive role instead.<br>在现实生活中，原型用于在开始批量生产产品之前进行各种测试。然而，在这种情况下，原型不参与任何实际生产，而是扮演被动角色。</p>
<div align="center"> <img src="/images/prototype-comic-3-en.png"/>The division of a cell.</br>细胞的分裂。</div>
Since industrial prototypes don’t really copy themselves, a much closer analogy to the pattern is the process of mitotic cell division (biology, remember?). After mitotic division, a pair of identical cells is formed. The original cell acts as a prototype and takes an active role in creating the copy.
由于工业原型并不能真正复制自己，因此与该模式更接近的类比是有丝分裂细胞分裂的过程（生物学，还记得吗？有丝分裂后，形成一对相同的细胞。原始单元充当原型，并在创建副本中发挥积极作用。

<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><h3 id="Basic-implementation-基本实现"><a href="#Basic-implementation-基本实现" class="headerlink" title="Basic implementation 基本实现"></a>Basic implementation 基本实现</h3><div align="center"> <img src="/images/prototyp-structure.png"/></div>

<ol>
<li><p>The <strong>Prototype</strong> interface declares the cloning methods. In most cases, it’s a single clone method.<br>Prototype 接口声明克隆方法。在大多数情况下，它是一种单一 clone 方法。</p>
</li>
<li><p>The <code>Concrete Prototype</code> class implements the cloning method. In addition to copying the original object’s data to the clone, this method may also handle some edge cases of the cloning process related to cloning linked objects, untangling recursive dependencies, etc.<br>Concrete Prototype 类实现克隆方法。除了将原始对象的数据复制到克隆中外，该方法还可以处理克隆过程中与克隆链接对象、解开递归依赖关系等相关的一些边缘情况。</p>
</li>
<li><p>The <code>Client</code> can produce a copy of any object that follows the prototype interface.<br>客户端可以生成遵循原型接口的任何对象的副本。</p>
</li>
</ol>
<h3 id="Prototype-registry-implementation-原型注册表实现"><a href="#Prototype-registry-implementation-原型注册表实现" class="headerlink" title="Prototype registry implementation 原型注册表实现"></a>Prototype registry implementation 原型注册表实现</h3><div align="center"> <img src="/images/structure-prototype-cache.png"/></div>
1. The `Prototype Registry` provides an easy way to access frequently-used prototypes. It stores a set of pre-built objects that are ready to be copied. The simplest prototype registry is a name → prototype hash map. However, if you need better search criteria than a simple name, you can build a much more robust version of the registry.
Prototype Registry 提供了一种访问常用原型的简单方法。它存储一组准备复制的预构建对象。最简单的原型注册表是 name → prototype 哈希映射。但是，如果您需要比简单名称更好的搜索条件，则可以构建更可靠的注册表版本。

<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>In this example, the Prototype pattern lets you produce exact copies of geometric objects, without coupling the code to their classes.<br>在此示例中，Prototype 模式允许您生成几何对象的精确副本，而无需将代码耦合到其类。</p>
<div align="center"> <img src="/images/prototype-example1.png"/>Cloning a set of objects that belong to a class hierarchy.</br>克隆属于类层次结构的一组对象。</div>

<p>All shape classes follow the same interface, which provides a cloning method. A subclass may call the parent’s cloning method before copying its own field values to the resulting object.<br>所有形状类都遵循相同的接口，该接口提供克隆方法。子类可以在将其自己的字段值复制到生成的对象之前调用父类的克隆方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base prototype.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> is</span><br><span class="line">    field X: <span class="type">int</span></span><br><span class="line">    field Y: <span class="type">int</span></span><br><span class="line">    field color: string</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A regular constructor.</span></span><br><span class="line">    constructor <span class="title function_">Shape</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The prototype constructor. A fresh object is initialized</span></span><br><span class="line">    <span class="comment">// with values from the existing object.</span></span><br><span class="line">    constructor <span class="title function_">Shape</span><span class="params">(source: Shape)</span> is</span><br><span class="line">        <span class="title function_">this</span><span class="params">()</span></span><br><span class="line">        <span class="built_in">this</span>.X = source.X</span><br><span class="line">        <span class="built_in">this</span>.Y = source.Y</span><br><span class="line">        <span class="built_in">this</span>.color = source.color</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The clone operation returns one of the Shape subclasses.</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">clone</span><span class="params">()</span>:Shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete prototype. The cloning method creates a new object</span></span><br><span class="line"><span class="comment">// in one go by calling the constructor of the current class and</span></span><br><span class="line"><span class="comment">// passing the current object as the constructor&#x27;s argument.</span></span><br><span class="line"><span class="comment">// Performing all the actual copying in the constructor helps to</span></span><br><span class="line"><span class="comment">// keep the result consistent: the constructor will not return a</span></span><br><span class="line"><span class="comment">// result until the new object is fully built; thus, no object</span></span><br><span class="line"><span class="comment">// can have a reference to a partially-built clone.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> is</span><br><span class="line">    field width: <span class="type">int</span></span><br><span class="line">    field height: <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Rectangle</span><span class="params">(source: Rectangle)</span> is</span><br><span class="line">        <span class="comment">// A parent constructor call is needed to copy private</span></span><br><span class="line">        <span class="comment">// fields defined in the parent class.</span></span><br><span class="line">        <span class="built_in">super</span>(source)</span><br><span class="line">        <span class="built_in">this</span>.width = source.width</span><br><span class="line">        <span class="built_in">this</span>.height = source.height</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clone</span><span class="params">()</span>:Shape is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> is</span><br><span class="line">    field radius: <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Circle</span><span class="params">(source: Circle)</span> is</span><br><span class="line">        <span class="title function_">super</span><span class="params">(source)</span></span><br><span class="line">        <span class="built_in">this</span>.radius = source.radius</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clone</span><span class="params">()</span>:Shape is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Somewhere in the client code.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    field shapes: array of Shape</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Application</span><span class="params">()</span> is</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>()</span><br><span class="line">        circle.X = <span class="number">10</span></span><br><span class="line">        circle.Y = <span class="number">10</span></span><br><span class="line">        circle.radius = <span class="number">20</span></span><br><span class="line">        shapes.add(circle)</span><br><span class="line"></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">anotherCircle</span> <span class="operator">=</span> circle.clone()</span><br><span class="line">        shapes.add(anotherCircle)</span><br><span class="line">        <span class="comment">// The `anotherCircle` variable contains an exact copy</span></span><br><span class="line">        <span class="comment">// of the `circle` object.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>()</span><br><span class="line">        rectangle.width = <span class="number">10</span></span><br><span class="line">        rectangle.height = <span class="number">20</span></span><br><span class="line">        shapes.add(rectangle)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">businessLogic</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Prototype rocks because it lets you produce a copy of</span></span><br><span class="line">        <span class="comment">// an object without knowing anything about its type.</span></span><br><span class="line">        <span class="type">Array</span> <span class="variable">shapesCopy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span> of Shapes.</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For instance, we don&#x27;t know the exact elements in the</span></span><br><span class="line">        <span class="comment">// shapes array. All we know is that they are all</span></span><br><span class="line">        <span class="comment">// shapes. But thanks to polymorphism, when we call the</span></span><br><span class="line">        <span class="comment">// `clone` method on a shape the program checks its real</span></span><br><span class="line">        <span class="comment">// class and runs the appropriate clone method defined</span></span><br><span class="line">        <span class="comment">// in that class. That&#x27;s why we get proper clones</span></span><br><span class="line">        <span class="comment">// instead of a set of simple Shape objects.</span></span><br><span class="line">        foreach (s in shapes) <span class="keyword">do</span></span><br><span class="line">            shapesCopy.add(s.clone())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The `shapesCopy` array contains exact copies of the</span></span><br><span class="line">        <span class="comment">// `shape` array&#x27;s children.</span></span><br></pre></td></tr></table></figure>
<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Prototype pattern when your code shouldn’t depend on the concrete classes of objects that you need to copy.当代码不应依赖于需要复制的具体对象类时，请使用 Prototype 模式。</strong></p>
</li>
<li><p>This happens a lot when your code works with objects passed to you from 3rd-party code via some interface. The concrete classes of these objects are unknown, and you couldn’t depend on them even if you wanted to.<br>当您的代码使用通过某些接口从第三方代码传递给您的对象时，这种情况经常发生。这些对象的具体类别是未知的，即使你愿意，你也不能依赖它们。</p>
</li>
</ul>
<p>The Prototype pattern provides the client code with a general interface for working with all objects that support cloning. This interface makes the client code independent from the concrete classes of objects that it clones.<br>Prototype 模式为客户端代码提供了一个通用接口，用于处理支持克隆的所有对象。此接口使客户端代码独立于它克隆的对象的具体类。</p>
<ul>
<li><p><strong>Use the pattern when you want to reduce the number of subclasses that only differ in the way they initialize their respective objects.<br>如果要减少子类的数量，这些子类仅在初始化各自对象的方式上有所不同，请使用该模式。</strong></p>
</li>
<li><p>Suppose you have a complex class that requires a laborious configuration before it can be used. There are several common ways to configure this class, and this code is scattered through your app. To reduce the duplication, you create several subclasses and put every common configuration code into their constructors. You solved the duplication problem, but now you have lots of dummy subclasses.<br>假设您有一个复杂的类，需要费力的配置才能使用它。有几种常用方法可以配置此类，并且此代码分散在应用中。为了减少重复，您可以创建多个子类，并将每个通用配置代码放入其构造函数中。您解决了重复问题，但现在您有很多虚拟子类。</p>
</li>
</ul>
<p>The Prototype pattern lets you use a set of pre-built objects configured in various ways as prototypes. Instead of instantiating a subclass that matches some configuration, the client can simply look for an appropriate prototype and clone it.<br>Prototype模式允许您使用一组以各种方式配置的预构建对象作为原型。客户端可以简单地寻找一个合适的原型并克隆它，而不是实例化一个匹配某些配置的子类。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Create the prototype interface and declare the <code>clone</code> method in it. Or just add the method to all classes of an existing class hierarchy, if you have one.<br>创建原型接口并在其中声明 <code>clone</code> 方法。或者，只需将该方法添加到现有类层次结构的所有类（如果有）。</p>
</li>
<li><p>A prototype class must define the alternative constructor that accepts an object of that class as an argument. The constructor must copy the values of all fields defined in the class from the passed object into the newly created instance. If you’re changing a subclass, you must call the parent constructor to let the superclass handle the cloning of its private fields.<br>原型类必须定义接受该类的对象作为参数的替代构造函数。构造函数必须将类中定义的所有字段的值从传递的对象复制到新创建的实例中。如果要更改子类，则必须调用父构造函数，让超类处理其私有字段的克隆。</p>
</li>
</ol>
<p>If your programming language doesn’t support method overloading, you won’t be able to create a separate “prototype” constructor. Thus, copying the object’s data into the newly created clone will have to be performed within the <code>clone</code> method. Still, having this code in a regular constructor is safer because the resulting object is returned fully configured right after you call the <code>new</code> operator.<br>如果你的编程语言不支持方法重载，你将无法创建单独的“原型”构造函数。因此，必须在 <code>clone</code> 该方法中将对象的数据复制到新创建的克隆中。不过，在常规构造函数中使用此代码更安全，因为在调用 <code>new</code> 运算符后立即返回完全配置的结果对象。</p>
<ol start="3">
<li><p>The cloning method usually consists of just one line: running a <code>new</code> operator with the prototypical version of the constructor. Note, that every class must explicitly override the cloning method and use its own class name along with the <code>new</code> operator. Otherwise, the cloning method may produce an object of a parent class.<br>克隆方法通常只包含一行：使用构造函数的原型版本运行运 <code>new</code> 算符。请注意，每个类都必须显式覆盖克隆方法，并使用自己的类名和 <code>new</code> 运算符。否则，克隆方法可能会生成父类的对象。</p>
</li>
<li><p>Optionally, create a centralized prototype registry to store a catalog of frequently used prototypes.<br>（可选）创建一个集中式原型注册表来存储常用原型的目录。</p>
</li>
</ol>
<p>You can implement the registry as a new factory class or put it in the base prototype class with a static method for fetching the prototype. This method should search for a prototype based on search criteria that the client code passes to the method. The criteria might either be a simple string tag or a complex set of search parameters. After the appropriate prototype is found, the registry should clone it and return the copy to the client.<br>您可以将注册表实现为新的工厂类，也可以使用用于获取原型的静态方法将其放在基原型类中。此方法应根据客户端代码传递给该方法的搜索条件搜索原型。条件可以是简单的字符串标记，也可以是一组复杂的搜索参数。找到适当的原型后，注册表应克隆它并将副本返回给客户端。</p>
<p>Finally, replace the direct calls to the subclasses’ constructors with calls to the factory method of the prototype registry.<br>最后，将对子类构造函数的直接调用替换为对原型注册表的工厂方法的调用。</p>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><ul>
<li>You can clone objects without coupling to their concrete classes.<br>您可以克隆对象，而无需耦合到其具体类。</li>
</ul>
<table>
<thead>
<tr>
<th>Pros 优点</th>
<th>Cons 缺点</th>
</tr>
</thead>
<tbody><tr>
<td>You can clone objects without coupling to their concrete classes.您可以克隆对象，而无需耦合到其具体类。</td>
<td>Cloning complex objects that have circular references might be very tricky.克隆具有循环引用的复杂对象可能非常棘手。</td>
</tr>
<tr>
<td>You can get rid of repeated initialization code in favor of cloning pre-built prototypes.您可以摆脱重复的初始化代码，转而克隆预构建的原型。</td>
<td></td>
</tr>
<tr>
<td>You can produce complex objects more conveniently.您可以更方便地生成复杂的对象。</td>
<td></td>
</tr>
<tr>
<td>You get an alternative to inheritance when dealing with configuration presets for complex objects.在处理复杂对象的配置预设时，您可以获得继承的替代方法。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Many designs start by using <code>Factory Method</code> (less complicated and more customizable via subclasses) and evolve toward <code>Abstract Factory</code>, Prototype, or Builder (more flexible, but more complicated).<br>许多设计从使用工厂方法（不那么复杂，通过子类更可定制）开始，然后发展到抽象工厂、原型或构建器（更灵活，但更复杂）。</p>
</li>
<li><p><code>Abstract Factory</code> classes are often based on a set of <code>Factory Methods</code>, but you can also use <code>Prototype</code> to compose the methods on these classes.<br>抽象工厂类通常基于一组工厂方法，但您也可以使用 Prototype 来组合这些类的方法。</p>
</li>
<li><p><code>Prototype</code> can help when you need to save copies of <code>Commands</code> into history.<br>当您需要将命令的副本保存到历史记录中时，Prototype 可以提供帮助。</p>
</li>
<li><p>Designs that make heavy use of <code>Composite</code> and <code>Decorator</code> can often benefit from using <code>Prototype</code>. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.<br>大量使用 Composite 和 Decorator 的设计通常可以从使用 Prototype 中受益。通过应用该模式，您可以克隆复杂的结构，而不是从头开始重新构建它们。</p>
</li>
<li><p><code>Prototype</code> isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. <code>Factory Method</code> is based on inheritance but doesn’t require an initialization step.<br>原型不是基于继承的，所以它没有缺点。另一方面，Prototype 需要对克隆对象进行复杂的初始化。工厂方法基于继承，但不需要初始化步骤。</p>
</li>
<li><p>Sometimes <code>Prototype</code> can be a simpler alternative to <code>Memento</code>. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.<br>有时，Prototype 可以成为 Memento 的更简单替代品。如果要存储在历史记录中的对象的状态相当简单，并且没有指向外部资源的链接，或者链接易于重新建立，则此方法有效。</p>
</li>
<li><p><code>Abstract Factories</code>, <code>Builders</code> and <code>Prototypes</code> can all be implemented as <code>Singletons</code>.<br>抽象工厂、构建器和原型都可以作为单例实现。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="Python-Conceptual-example"><a href="#Python-Conceptual-example" class="headerlink" title="Python Conceptual example"></a>Python Conceptual example</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelfReferencingEntity</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_parent</span>(<span class="params">self, parent</span>):</span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeComponent</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Python provides its own interface of Prototype via `copy.copy` and</span></span><br><span class="line"><span class="string">    `copy.deepcopy` functions. And any class that wants to implement custom</span></span><br><span class="line"><span class="string">    implementations have to override `__copy__` and `__deepcopy__` member</span></span><br><span class="line"><span class="string">    functions.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, some_int, some_list_of_objects, some_circular_ref</span>):</span><br><span class="line">        self.some_int = some_int</span><br><span class="line">        self.some_list_of_objects = some_list_of_objects</span><br><span class="line">        self.some_circular_ref = some_circular_ref</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__copy__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Create a shallow copy. This method will be called whenever someone calls</span></span><br><span class="line"><span class="string">        `copy.copy` with this object and the returned value is returned as the</span></span><br><span class="line"><span class="string">        new shallow copy.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># First, let&#x27;s create copies of the nested objects.</span></span><br><span class="line">        some_list_of_objects = copy.copy(self.some_list_of_objects)</span><br><span class="line">        some_circular_ref = copy.copy(self.some_circular_ref)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Then, let&#x27;s clone the object itself, using the prepared clones of the</span></span><br><span class="line">        <span class="comment"># nested objects.</span></span><br><span class="line">        new = self.__class__(</span><br><span class="line">            self.some_int, some_list_of_objects, some_circular_ref</span><br><span class="line">        )</span><br><span class="line">        new.__dict__.update(self.__dict__)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__deepcopy__</span>(<span class="params">self, memo=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Create a deep copy. This method will be called whenever someone calls</span></span><br><span class="line"><span class="string">        `copy.deepcopy` with this object and the returned value is returned as</span></span><br><span class="line"><span class="string">        the new deep copy.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        What is the use of the argument `memo`? Memo is the dictionary that is</span></span><br><span class="line"><span class="string">        used by the `deepcopy` library to prevent infinite recursive copies in</span></span><br><span class="line"><span class="string">        instances of circular references. Pass it to all the `deepcopy` calls</span></span><br><span class="line"><span class="string">        you make in the `__deepcopy__` implementation to prevent infinite</span></span><br><span class="line"><span class="string">        recursions.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> memo <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># First, let&#x27;s create copies of the nested objects.</span></span><br><span class="line">        some_list_of_objects = copy.deepcopy(self.some_list_of_objects, memo)</span><br><span class="line">        some_circular_ref = copy.deepcopy(self.some_circular_ref, memo)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Then, let&#x27;s clone the object itself, using the prepared clones of the</span></span><br><span class="line">        <span class="comment"># nested objects.</span></span><br><span class="line">        new = self.__class__(</span><br><span class="line">            self.some_int, some_list_of_objects, some_circular_ref</span><br><span class="line">        )</span><br><span class="line">        new.__dict__ = copy.deepcopy(self.__dict__, memo)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    list_of_objects = [<span class="number">1</span>, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">    circular_ref = SelfReferencingEntity()</span><br><span class="line">    component = SomeComponent(<span class="number">23</span>, list_of_objects, circular_ref)</span><br><span class="line">    circular_ref.set_parent(component)</span><br><span class="line"></span><br><span class="line">    shallow_copied_component = copy.copy(component)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let&#x27;s change the list in shallow_copied_component and see if it changes in</span></span><br><span class="line">    <span class="comment"># component.</span></span><br><span class="line">    shallow_copied_component.some_list_of_objects.append(<span class="string">&quot;another object&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> component.some_list_of_objects[-<span class="number">1</span>] == <span class="string">&quot;another object&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Adding elements to `shallow_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects adds it to `component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Adding elements to `shallow_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects doesn&#x27;t add it to `component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let&#x27;s change the set in the list of objects.</span></span><br><span class="line">    component.some_list_of_objects[<span class="number">1</span>].add(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">4</span> <span class="keyword">in</span> shallow_copied_component.some_list_of_objects[<span class="number">1</span>]:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Changing objects in the `component`&#x27;s some_list_of_objects &quot;</span></span><br><span class="line">            <span class="string">&quot;changes that object in `shallow_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Changing objects in the `component`&#x27;s some_list_of_objects &quot;</span></span><br><span class="line">            <span class="string">&quot;doesn&#x27;t change that object in `shallow_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    deep_copied_component = copy.deepcopy(component)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let&#x27;s change the list in deep_copied_component and see if it changes in</span></span><br><span class="line">    <span class="comment"># component.</span></span><br><span class="line">    deep_copied_component.some_list_of_objects.append(<span class="string">&quot;one more object&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> component.some_list_of_objects[-<span class="number">1</span>] == <span class="string">&quot;one more object&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Adding elements to `deep_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects adds it to `component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Adding elements to `deep_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects doesn&#x27;t add it to `component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let&#x27;s change the set in the list of objects.</span></span><br><span class="line">    component.some_list_of_objects[<span class="number">1</span>].add(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">10</span> <span class="keyword">in</span> deep_copied_component.some_list_of_objects[<span class="number">1</span>]:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Changing objects in the `component`&#x27;s some_list_of_objects &quot;</span></span><br><span class="line">            <span class="string">&quot;changes that object in `deep_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Changing objects in the `component`&#x27;s some_list_of_objects &quot;</span></span><br><span class="line">            <span class="string">&quot;doesn&#x27;t change that object in `deep_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">f&quot;id(deep_copied_component.some_circular_ref.parent): &quot;</span></span><br><span class="line">        <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">id</span>(deep_copied_component.some_circular_ref.parent)&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">f&quot;id(deep_copied_component.some_circular_ref.parent.some_circular_ref.parent): &quot;</span></span><br><span class="line">        <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">id</span>(deep_copied_component.some_circular_ref.parent.some_circular_ref.parent)&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;^^ This shows that deepcopied objects contain same reference, they &quot;</span></span><br><span class="line">        <span class="string">&quot;are not cloned repeatedly.&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Adding elements to `shallow_copied_component`&#x27;s some_list_of_objects adds it to `component`&#x27;s some_list_of_objects.</span><br><span class="line">Changing objects in the `component`&#x27;s some_list_of_objects changes that object in `shallow_copied_component`&#x27;s some_list_of_objects.</span><br><span class="line">Adding elements to `deep_copied_component`&#x27;s some_list_of_objects doesn&#x27;t add it to `component`&#x27;s some_list_of_objects.</span><br><span class="line">Changing objects in the `component`&#x27;s some_list_of_objects doesn&#x27;t change that object in `deep_copied_component`&#x27;s some_list_of_objects.</span><br><span class="line">id(deep_copied_component.some_circular_ref.parent): 4429472784</span><br><span class="line">id(deep_copied_component.some_circular_ref.parent.some_circular_ref.parent): 4429472784</span><br><span class="line">^^ This shows that deepcopied objects contain same reference, they are not cloned repeatedly.</span><br></pre></td></tr></table></figure>

<h3 id="Rust-Built-in-Clone-trait-内置克隆特征"><a href="#Rust-Built-in-Clone-trait-内置克隆特征" class="headerlink" title="Rust Built-in Clone trait 内置克隆特征"></a>Rust Built-in Clone trait 内置克隆特征</h3><p>Rust has a built-in <code>std::clone::Clone</code> trait with many implementations for various types (via <code>#[derive(Clone)]</code>). Thus, the Prototype pattern is ready to use out of the box.<br>Rust 有一个内置 <code>std::clone::Clone</code> 的特性，具有许多针对各种类型的实现（通过 <code>#[derive(Clone)]</code> ）。因此，原型模式可以开箱即用。</p>
<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a>main.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> x: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> y: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> radius: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">circle1</span> = Circle &#123;</span><br><span class="line">        x: <span class="number">10</span>,</span><br><span class="line">        y: <span class="number">15</span>,</span><br><span class="line">        radius: <span class="number">10</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prototype in action.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">circle2</span> = circle1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    circle2.radius = <span class="number">77</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Circle 1: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, circle1.x, circle1.y, circle1.radius);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Circle 2: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, circle2.x, circle2.y, circle2.radius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Circle 1: 10, 15, 10</span><br><span class="line">Circle 2: 10, 15, 77</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Proxy 代理模式</title>
    <url>/2024/02/01/design-pattern/proxy/</url>
    <content><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p><strong>代理</strong>是一种结构化设计模式，它允许您为另一个对象提供替代或占位符。代理控制对原始对象的访问，允许您在请求到达原始对象之前或之后执行某些操作。</p>
<div align="center"> <img src="/images/proxy.png"/></div>


<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为什么要控制对对象的访问？这里有一个例子：你有一个巨大的对象，它消耗了大量的系统资源。你有时需要它，但不总是。</p>
<div align="center"> <img src="/images/proxy-problem-en.png"/>数据库查询可能真的很慢。</div>


<p>你可以实现惰性初始化：只在实际需要的时候创建这个对象。对象的所有客户端都需要执行一些延迟初始化代码。不幸的是，这可能会导致大量的代码重复。</p>
<p>在理想情况下，我们希望将这些代码直接放入对象的类中，但这并不总是可行的。例如，类可以是封闭的第三方库的一部分。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>代理模式建议您创建一个具有与原始服务对象相同接口的新代理类。然后更新您的应用，使其将代理对象传递给原始对象的所有客户端。在接收到来自客户机的请求时，代理创建一个真实的服务对象，并将所有工作委托给它。</p>
<div align="center"> <img src="/images/proxy-solution-en.png"/>代理将自己伪装成一个数据库对象。它可以在客户端或真实的数据库对象不知道的情况下处理延迟初始化和结果缓存。</div>


<p>但有什么好处呢？如果您需要在类的主要逻辑之前或之后执行某些操作，代理允许您在不更改该类的情况下执行这些操作。由于代理实现了与原始类相同的接口，因此可以将其传递给任何需要真实的服务对象的客户端。</p>
<h2 id="现实世界的类比"><a href="#现实世界的类比" class="headerlink" title="现实世界的类比"></a>现实世界的类比</h2><div align="center"> <img src="/images/proxy-live-example.png"/>信用卡和现金一样可以用来付款。</div>


<p>信用卡是银行账户的代理，银行账户是一捆现金的代理。两者都实现了相同的接口：它们可以用于进行支付。消费者感觉很好，因为没有必要随身携带大量现金。店主也很高兴，因为交易收入通过电子方式添加到商店的银行账户中，而没有丢失存款或在去银行的路上被抢劫的风险。</p>
<div align="center"> <img src="/images/proxy-structure.png"/></div>


<ol>
<li>服务接口声明服务的接口。代理必须遵循此接口，以便能够将自己伪装成服务对象。</li>
<li>Service是一个提供一些有用的业务逻辑的类。</li>
<li>Proxy类有一个指向服务对象的引用字段。在代理完成其处理之后（例如，惰性初始化、日志记录、访问控制、缓存等），它将请求传递给服务对象。通常，代理管理其服务对象的整个生命周期。</li>
<li>客户端应该通过相同的接口与服务和代理一起工作。通过这种方式，您可以将代理传递到任何需要服务对象的代码中。</li>
</ol>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>此示例说明了代理模式如何帮助将延迟初始化和缓存引入第三方YouTube集成库。</p>
<div align="center"> <img src="/images/proxy-example.png"/>使用代理缓存服务的结果。</div>


<p>图书馆为我们提供了视频下载课。然而，这是非常低效的。如果客户端应用程序多次请求相同的视频，库只是一遍又一遍地下载它，而不是缓存和重用第一个下载的文件。</p>
<p>代理类实现与原始下载器相同的接口，并将所有工作委托给它。但是，它会跟踪下载的文件，并在应用多次请求同一视频时返回缓存结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The interface of a remote service.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ThirdPartyYouTubeLib</span> is</span><br><span class="line">    method <span class="title function_">listVideos</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">getVideoInfo</span><span class="params">(id)</span></span><br><span class="line">    method <span class="title function_">downloadVideo</span><span class="params">(id)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The concrete implementation of a service connector. Methods</span></span><br><span class="line"><span class="comment">// of this class can request information from YouTube. The speed</span></span><br><span class="line"><span class="comment">// of the request depends on a user&#x27;s internet connection as</span></span><br><span class="line"><span class="comment">// well as YouTube&#x27;s. The application will slow down if a lot of</span></span><br><span class="line"><span class="comment">// requests are fired at the same time, even if they all request</span></span><br><span class="line"><span class="comment">// the same information.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdPartyYouTubeClass</span> <span class="keyword">implements</span> <span class="title class_">ThirdPartyYouTubeLib</span> is</span><br><span class="line">    method <span class="title function_">listVideos</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Send an API request to YouTube.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getVideoInfo</span><span class="params">(id)</span> is</span><br><span class="line">        <span class="comment">// Get metadata about some video.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">downloadVideo</span><span class="params">(id)</span> is</span><br><span class="line">        <span class="comment">// Download a video file from YouTube.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To save some bandwidth, we can cache request results and keep</span></span><br><span class="line"><span class="comment">// them for some time. But it may be impossible to put such code</span></span><br><span class="line"><span class="comment">// directly into the service class. For example, it could have</span></span><br><span class="line"><span class="comment">// been provided as part of a third party library and/or defined</span></span><br><span class="line"><span class="comment">// as `final`. That&#x27;s why we put the caching code into a new</span></span><br><span class="line"><span class="comment">// proxy class which implements the same interface as the</span></span><br><span class="line"><span class="comment">// service class. It delegates to the service object only when</span></span><br><span class="line"><span class="comment">// the real requests have to be sent.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CachedYouTubeClass</span> <span class="keyword">implements</span> <span class="title class_">ThirdPartyYouTubeLib</span> is</span><br><span class="line">    <span class="keyword">private</span> field service: ThirdPartyYouTubeLib</span><br><span class="line">    <span class="keyword">private</span> field listCache, videoCache</span><br><span class="line">    field needReset</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">CachedYouTubeClass</span><span class="params">(service: ThirdPartyYouTubeLib)</span> is</span><br><span class="line">        <span class="built_in">this</span>.service = service</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">listVideos</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(listCache == <span class="literal">null</span> || needReset)</span></span><br><span class="line">            listCache = service.listVideos()</span><br><span class="line">        <span class="keyword">return</span> listCache</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getVideoInfo</span><span class="params">(id)</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(videoCache == <span class="literal">null</span> || needReset)</span></span><br><span class="line">            videoCache = service.getVideoInfo(id)</span><br><span class="line">        <span class="keyword">return</span> videoCache</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">downloadVideo</span><span class="params">(id)</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(!downloadExists(id)</span> || needReset)</span><br><span class="line">            service.downloadVideo(id)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The GUI class, which used to work directly with a service</span></span><br><span class="line"><span class="comment">// object, stays unchanged as long as it works with the service</span></span><br><span class="line"><span class="comment">// object through an interface. We can safely pass a proxy</span></span><br><span class="line"><span class="comment">// object instead of a real service object since they both</span></span><br><span class="line"><span class="comment">// implement the same interface.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YouTubeManager</span> is</span><br><span class="line">    <span class="keyword">protected</span> field service: ThirdPartyYouTubeLib</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">YouTubeManager</span><span class="params">(service: ThirdPartyYouTubeLib)</span> is</span><br><span class="line">        <span class="built_in">this</span>.service = service</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">renderVideoPage</span><span class="params">(id)</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">info</span> <span class="operator">=</span> service.getVideoInfo(id)</span><br><span class="line">        <span class="comment">// Render the video page.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">renderListPanel</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">list</span> <span class="operator">=</span> service.listVideos()</span><br><span class="line">        <span class="comment">// Render the list of video thumbnails.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">reactOnUserInput</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">renderVideoPage</span><span class="params">()</span></span><br><span class="line">        renderListPanel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// The application can configure proxies on the fly.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    method <span class="title function_">init</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">aYouTubeService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThirdPartyYouTubeClass</span>()</span><br><span class="line">        aYouTubeProxy = <span class="keyword">new</span> <span class="title class_">CachedYouTubeClass</span>(aYouTubeService)</span><br><span class="line">        manager = <span class="keyword">new</span> <span class="title class_">YouTubeManager</span>(aYouTubeProxy)</span><br><span class="line">        manager.reactOnUserInput()</span><br></pre></td></tr></table></figure>

<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>使用代理模式的方法有很多种。让我们来看看最流行的用法。</p>
<ul>
<li><strong>惰性初始化（虚拟代理）。这是当您有一个重量级的服务对象时，它总是处于运行状态，浪费系统资源，即使您只是偶尔需要它。</strong></li>
<li>您可以将对象的初始化延迟到真正需要的时候，而不是在应用启动时创建对象。</li>
<li><strong>访问控制（保护代理）。这是当您希望只有特定的客户端能够使用服务对象时;例如，当您的对象是操作系统的关键部分，而客户端是各种启动的应用程序（包括恶意应用程序）时。</strong></li>
<li>只有当客户端的凭据符合某些条件时，代理才能将请求传递给服务对象。</li>
<li><strong>远程服务的本地执行（远程代理）。这是当服务对象位于远程服务器上时。</strong></li>
<li>在这种情况下，代理通过网络传递客户端请求，处理与网络一起工作的所有讨厌的细节。</li>
<li><strong>日志请求（日志代理）。这是您想要保留对服务对象的请求历史记录的时候。</strong></li>
<li>代理可以在将请求传递给服务之前记录每个请求。</li>
<li><strong>缓存请求结果（缓存代理）。这是当您需要缓存客户端请求的结果并管理此缓存的生命周期时，特别是当结果非常大时。</strong></li>
<li>代理可以为总是产生相同结果的重复请求实现缓存。代理可以使用请求的参数作为该高速缓存键。</li>
<li><strong>聪明的参考。这是您需要在没有客户端使用重量级对象时能够解除该对象的时候。</strong></li>
<li>代理可以跟踪获得对服务对象或其结果的引用的客户端。有时，代理可能会检查客户端并检查它们是否仍然处于活动状态。如果客户端列表为空，则代理可能会解除服务对象并释放底层系统资源。代理还可以跟踪客户机是否修改了服务对象。然后，未更改的对象可以被其他客户端重用。</li>
</ul>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><ol>
<li>如果没有预先存在的服务接口，则创建一个以使代理和服务对象可互换。从服务类中提取接口并不总是可行的，因为您需要更改服务的所有客户端以使用该接口。计划B是使代理成为服务类的子类，这样它将继承服务的接口。</li>
<li>创建代理类。它应该有一个用于存储服务引用的字段。通常，代理创建和管理其服务的整个生命周期。在极少数情况下，服务由客户端通过构造函数传递给代理。</li>
<li>根据代理方法的用途实现它们。在大多数情况下，在完成一些工作之后，代理应该将工作委托给服务对象。</li>
<li>考虑引入一种创建方法，该方法决定客户机获取的是代理服务还是真实的服务。这可以是代理类中的简单静态方法，也可以是成熟的工厂方法。</li>
<li>考虑为服务对象实现惰性初始化。</li>
</ol>
<h2 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h2><table>
<thead>
<tr>
<th>√ 利</th>
<th>× 弊</th>
</tr>
</thead>
<tbody><tr>
<td>您可以在客户端不知道的情况下控制服务对象。</td>
<td>代码可能会变得更复杂，因为你需要引入很多新的类。</td>
</tr>
<tr>
<td>当客户机不关心服务对象时，您可以管理它的生命周期。</td>
<td>服务的响应可能会延迟。</td>
</tr>
<tr>
<td>即使服务对象未准备好或不可用，代理也可以工作。</td>
<td></td>
</tr>
<tr>
<td>开放&#x2F;封闭原则。您可以引入新的代理，而无需更改服务或客户端。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li>使用Adapter，您可以通过不同的接口访问现有对象。使用Proxy，接口保持不变。使用Decorator，您可以通过增强的接口访问对象。</li>
<li>Facade与Proxy类似，都缓冲一个复杂的实体并自己初始化它。与Facade不同，Proxy与其服务对象具有相同的接口，这使得它们可以互换。</li>
<li>Decorator和Proxy具有类似的结构，但意图非常不同。这两种模式都建立在组合原则上，其中一个对象应该将一些工作委托给另一个对象。不同之处在于，Proxy通常自己管理其服务对象的生命周期，而Decorators的组成始终由客户端控制。</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h1 id="Python中的代理"><a href="#Python中的代理" class="headerlink" title="Python中的代理"></a>Python中的代理</h1><p>代理是一种结构化设计模式，它提供一个对象，作为客户端使用的真实的服务对象的替代品。代理接收客户端请求，做一些工作（访问控制，缓存等）。然后将请求传递给服务对象。</p>
<p>代理对象具有与服务相同的接口，这使得它在传递给客户端时可以与真实的对象互换。</p>
<h2 id="概念示例"><a href="#概念示例" class="headerlink" title="概念示例"></a>概念示例</h2><p>这个例子说明了代理设计模式的结构。它侧重于回答这些问题：</p>
<ul>
<li>它由哪些类组成？</li>
<li>这些班级扮演什么角色？</li>
<li>模式中的元素是以什么方式联系在一起的？</li>
</ul>
<h4 id="main-py：概念性示例"><a href="#main-py：概念性示例" class="headerlink" title="main.py：概念性示例"></a>main.py：概念性示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Subject interface declares common operations for both RealSubject and</span></span><br><span class="line"><span class="string">    the Proxy. As long as the client works with RealSubject using this</span></span><br><span class="line"><span class="string">    interface, you&#x27;ll be able to pass it a proxy instead of a real subject.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span>(<span class="title class_ inherited__">Subject</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The RealSubject contains some core business logic. Usually, RealSubjects are</span></span><br><span class="line"><span class="string">    capable of doing some useful work which may also be very slow or sensitive -</span></span><br><span class="line"><span class="string">    e.g. correcting input data. A Proxy can solve these issues without any</span></span><br><span class="line"><span class="string">    changes to the RealSubject&#x27;s code.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;RealSubject: Handling request.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span>(<span class="title class_ inherited__">Subject</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Proxy has an interface identical to the RealSubject.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, real_subject: RealSubject</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._real_subject = real_subject</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The most common applications of the Proxy pattern are lazy loading,</span></span><br><span class="line"><span class="string">        caching, controlling the access, logging, etc. A Proxy can perform one</span></span><br><span class="line"><span class="string">        of these things and then, depending on the result, pass the execution to</span></span><br><span class="line"><span class="string">        the same method in a linked RealSubject object.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.check_access():</span><br><span class="line">            self._real_subject.request()</span><br><span class="line">            self.log_access()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_access</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Proxy: Checking access prior to firing a real request.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log_access</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Proxy: Logging the time of request.&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">subject: Subject</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code is supposed to work with all objects (both subjects and</span></span><br><span class="line"><span class="string">    proxies) via the Subject interface in order to support both real subjects</span></span><br><span class="line"><span class="string">    and proxies. In real life, however, clients mostly work with their real</span></span><br><span class="line"><span class="string">    subjects directly. In this case, to implement the pattern more easily, you</span></span><br><span class="line"><span class="string">    can extend your proxy from the real subject&#x27;s class.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    subject.request()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Executing the client code with a real subject:&quot;</span>)</span><br><span class="line">    real_subject = RealSubject()</span><br><span class="line">    client_code(real_subject)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Executing the same client code with a proxy:&quot;</span>)</span><br><span class="line">    proxy = Proxy(real_subject)</span><br><span class="line">    client_code(proxy)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>Output.txt：执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: Executing the client code with a real subject:</span><br><span class="line">RealSubject: Handling request.</span><br><span class="line"></span><br><span class="line">Client: Executing the same client code with a proxy:</span><br><span class="line">Proxy: Checking access prior to firing a real request.</span><br><span class="line">RealSubject: Handling request.</span><br><span class="line">Proxy: Logging the time of request.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Rust中的代理"><a href="#Rust中的代理" class="headerlink" title="Rust中的代理"></a>Rust中的代理</h1><p>代理是一种结构化设计模式，它提供一个对象，作为客户端使用的真实的服务对象的替代品。代理接收客户端请求，做一些工作（访问控制，缓存等）。然后将请求传递给服务对象。</p>
<h2 id="概念示例：Nginx代理"><a href="#概念示例：Nginx代理" class="headerlink" title="概念示例：Nginx代理"></a>概念示例：Nginx代理</h2><p>Web服务器（如Nginx）可以充当应用服务器的代理：</p>
<ul>
<li>它提供对应用服务器的受控访问。</li>
<li>它可以进行速率限制。</li>
<li>它可以做请求缓存。</li>
</ul>
<h4 id="server-rs"><a href="#server-rs" class="headerlink" title="server.rs"></a><strong>server.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> application;</span><br><span class="line"><span class="keyword">mod</span> nginx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> nginx::NginxServer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">handle_request</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, url: &amp;<span class="type">str</span>, method: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> (<span class="type">u16</span>, <span class="type">String</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="server-application-rs"><a href="#server-application-rs" class="headerlink" title="server&#x2F;application.rs"></a>server&#x2F;application.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Application</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Server</span> <span class="keyword">for</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">handle_request</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, url: &amp;<span class="type">str</span>, method: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> (<span class="type">u16</span>, <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> url == <span class="string">&quot;/app/status&quot;</span> &amp;&amp; method == <span class="string">&quot;GET&quot;</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">return</span> (<span class="number">200</span>, <span class="string">&quot;Ok&quot;</span>.<span class="title function_ invoke__">into</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> url == <span class="string">&quot;/create/user&quot;</span> &amp;&amp; method == <span class="string">&quot;POST&quot;</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">return</span> (<span class="number">201</span>, <span class="string">&quot;User Created&quot;</span>.<span class="title function_ invoke__">into</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (<span class="number">404</span>, <span class="string">&quot;Not Ok&quot;</span>.<span class="title function_ invoke__">into</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="server-nginx-rs"><a href="#server-nginx-rs" class="headerlink" title="server&#x2F;nginx.rs"></a><strong>server&#x2F;nginx.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::&#123;application::Application, Server&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NGINX server is a proxy to an application server.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NginxServer</span> &#123;</span><br><span class="line">    application: Application,</span><br><span class="line">    max_allowed_requests: <span class="type">u32</span>,</span><br><span class="line">    rate_limiter: HashMap&lt;<span class="type">String</span>, <span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">NginxServer</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            application: Application,</span><br><span class="line">            max_allowed_requests: <span class="number">2</span>,</span><br><span class="line">            rate_limiter: HashMap::<span class="title function_ invoke__">default</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">check_rate_limiting</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, url: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rate</span> = <span class="keyword">self</span>.rate_limiter.<span class="title function_ invoke__">entry</span>(url.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">or_insert</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> *rate &gt; <span class="keyword">self</span>.max_allowed_requests &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *rate += <span class="number">1</span>;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Server</span> <span class="keyword">for</span> <span class="title class_">NginxServer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">handle_request</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, url: &amp;<span class="type">str</span>, method: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> (<span class="type">u16</span>, <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.<span class="title function_ invoke__">check_rate_limiting</span>(url) &#123;</span><br><span class="line">            <span class="title function_ invoke__">return</span> (<span class="number">403</span>, <span class="string">&quot;Not Allowed&quot;</span>.<span class="title function_ invoke__">into</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.application.<span class="title function_ invoke__">handle_request</span>(url, method)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a><strong>main.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::server::&#123;NginxServer, Server&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_status</span> = &amp;<span class="string">&quot;/app/status&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">create_user</span> = &amp;<span class="string">&quot;/create/user&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nginx</span> = NginxServer::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (code, body) = nginx.<span class="title function_ invoke__">handle_request</span>(app_status, <span class="string">&quot;GET&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Url: &#123;&#125;\nHttpCode: &#123;&#125;\nBody: &#123;&#125;\n&quot;</span>, app_status, code, body);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (code, body) = nginx.<span class="title function_ invoke__">handle_request</span>(app_status, <span class="string">&quot;GET&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Url: &#123;&#125;\nHttpCode: &#123;&#125;\nBody: &#123;&#125;\n&quot;</span>, app_status, code, body);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (code, body) = nginx.<span class="title function_ invoke__">handle_request</span>(app_status, <span class="string">&quot;GET&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Url: &#123;&#125;\nHttpCode: &#123;&#125;\nBody: &#123;&#125;\n&quot;</span>, app_status, code, body);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (code, body) = nginx.<span class="title function_ invoke__">handle_request</span>(create_user, <span class="string">&quot;POST&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Url: &#123;&#125;\nHttpCode: &#123;&#125;\nBody: &#123;&#125;\n&quot;</span>, create_user, code, body);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (code, body) = nginx.<span class="title function_ invoke__">handle_request</span>(create_user, <span class="string">&quot;GET&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Url: &#123;&#125;\nHttpCode: &#123;&#125;\nBody: &#123;&#125;\n&quot;</span>, create_user, code, body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Url: /app/status</span><br><span class="line">HttpCode: 200</span><br><span class="line">Body: Ok</span><br><span class="line"></span><br><span class="line">Url: /app/status</span><br><span class="line">HttpCode: 200</span><br><span class="line">Body: Ok</span><br><span class="line"></span><br><span class="line">Url: /app/status</span><br><span class="line">HttpCode: 403</span><br><span class="line">Body: Not Allowed</span><br><span class="line"></span><br><span class="line">Url: /create/user</span><br><span class="line">HttpCode: 201</span><br><span class="line">Body: User Created</span><br><span class="line"></span><br><span class="line">Url: /create/user</span><br><span class="line">HttpCode: 404</span><br><span class="line">Body: Not Ok</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Singleton</title>
    <url>/2023/11/23/design-pattern/singleton/</url>
    <content><![CDATA[<h1 id="Singleton-单例模式"><a href="#Singleton-单例模式" class="headerlink" title="Singleton 单例模式"></a>Singleton 单例模式</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Singleton</strong> is a creational design pattern that lets you ensure that a class has only one instance, while providing a global access point to this instance.<br>Singleton 是一种创建性设计模式，它允许您确保一个类只有一个实例，同时提供此实例的全局访问点。</p>
<div align="center"> <img src="/images/singleton-header.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>The Singleton pattern solves two problems at the same time, violating the Single Responsibility Principle:<br>Singleton 模式同时解决了两个问题，违反了单一责任原则：</p>
<ol>
<li><strong>Ensure that a class has just a single instance</strong>. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource—for example, a database or a file.<br>确保一个类只有一个实例。为什么有人想要控制一个类有多少个实例？最常见的原因是控制对某些共享资源（例如数据库或文件）的访问。</li>
</ol>
<p>Here’s how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you’ll get the one you already created.<br>它是这样工作的：假设你创建了一个对象，但过了一段时间决定创建一个新对象。您将获得已创建的对象，而不是接收新对象。</p>
<p>Note that this behavior is impossible to implement with a regular constructor since a constructor call must always return a new object by design.<br>请注意，此行为无法使用常规构造函数实现，因为构造函数调用必须始终返回新对象。</p>
<div align="center"> <img src="/images/singleton-comic-1-en.png"/>Clients may not even realize that they’re working with the same object all the time.</br>客户甚至可能没有意识到他们一直在使用同一个对象。</div>

<ol start="2">
<li><strong>Provide a global access point to that instance</strong>.Remember those global variables that you (all right, me) used to store some essential objects? While they’re very handy, they’re also very unsafe since any code can potentially overwrite the contents of those variables and crash the app.<br>为该实例提供全局访问点。还记得你（好吧，我）用来存储一些基本对象的那些全局变量吗？虽然它们非常方便，但它们也非常不安全，因为任何代码都可能覆盖这些变量的内容并使应用程序崩溃。<br>Just like a global variable, the Singleton pattern lets you access some object from anywhere in the program. However, it also protects that instance from being overwritten by other code.<br>就像全局变量一样，Singleton 模式允许您从程序中的任何位置访问某些对象。但是，它还可以保护该实例不被其他代码覆盖。<br>There’s another side to this problem: you don’t want the code that solves problem #1 to be scattered all over your program. It’s much better to have it within one class, especially if the rest of your code already depends on it.<br>这个问题还有另一面：你不希望解决问题 #1 的代码分散在你的程序中。最好将它放在一个类中，特别是如果您的其余代码已经依赖于它。</li>
</ol>
<p>Nowadays, the Singleton pattern has become so popular that people may call something a singleton even if it solves just one of the listed problems.<br>如今，单例模式已经变得如此流行，以至于人们可能会称某物为单例，即使它只解决了列出的问题之一。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>All implementations of the Singleton have these two steps in common:<br>Singleton 的所有实现都具有以下两个共同步骤：</p>
<ul>
<li>Make the default constructor private, to prevent other objects from using the new operator with the Singleton class.<br>将默认构造函数设为私有，以防止其他对象将运 new 算符与 Singleton 类一起使用。</li>
<li>Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the cached object.<br>创建一个充当构造函数的静态创建方法。在后台，此方法调用私有构造函数来创建对象并将其保存在静态字段中。对此方法的所有后续调用都将返回缓存的对象。</li>
</ul>
<p>If your code has access to the Singleton class, then it’s able to call the Singleton’s static method. So whenever that method is called, the same object is always returned.<br>如果您的代码有权访问 Singleton 类，则它能够调用 Singleton 的静态方法。因此，每当调用该方法时，始终返回相同的对象。</p>
<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><p>The government is an excellent example of the Singleton pattern. A country can have only one official government. Regardless of the personal identities of the individuals who form governments, the title, “The Government of X”, is a global point of access that identifies the group of people in charge.<br>政府是辛格尔顿模式的一个很好的例子。一个国家只能有一个官方政府。无论组成政府的个人的个人身份如何，“X政府”这个头衔都是一个全球访问点，用于识别负责人群体。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/singleton-structure-en.png"/></div>
The **Singleton** class declares the static method getInstance that returns the same instance of its own class.
**Singleton** 类声明返回其自身类的相同实例的静态方法 getInstance 。

<p>The Singleton’s constructor should be hidden from the client code. Calling the getInstance method should be the only way of getting the Singleton object.<br>Singleton 的构造函数应在客户端代码中隐藏。调用该 getInstance 方法应该是获取 Singleton 对象的唯一方法。</p>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>In this example, the database connection class acts as a <strong>Singleton</strong>. This class doesn’t have a public constructor, so the only way to get its object is to call the <code>getInstance</code> method. This method caches the first created object and returns it in all subsequent calls.<br>在此示例中，数据库连接类充当 Singleton。此类没有公共构造函数，因此获取其对象的唯一方法是调用该 <code>getInstance</code> 方法。此方法缓存第一个创建的对象，并在所有后续调用中返回该对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The Database class defines the `getInstance` method that lets</span></span><br><span class="line"><span class="comment">// clients access the same instance of a database connection</span></span><br><span class="line"><span class="comment">// throughout the program.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span> is</span><br><span class="line">    <span class="comment">// The field for storing the singleton instance should be</span></span><br><span class="line">    <span class="comment">// declared static.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> field instance: Database</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The singleton&#x27;s constructor should always be private to</span></span><br><span class="line">    <span class="comment">// prevent direct construction calls with the `new`</span></span><br><span class="line">    <span class="comment">// operator.</span></span><br><span class="line">    <span class="keyword">private</span> constructor <span class="title function_">Database</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Some initialization code, such as the actual</span></span><br><span class="line">        <span class="comment">// connection to a database server.</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The static method that controls access to the singleton</span></span><br><span class="line">    <span class="comment">// instance.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> method <span class="title function_">getInstance</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(Database.instance == <span class="literal">null</span>)</span> then</span><br><span class="line">            <span class="title function_">acquireThreadLock</span><span class="params">()</span> and then</span><br><span class="line">                <span class="comment">// Ensure that the instance hasn&#x27;t yet been</span></span><br><span class="line">                <span class="comment">// initialized by another thread while this one</span></span><br><span class="line">                <span class="comment">// has been waiting for the lock&#x27;s release.</span></span><br><span class="line">                <span class="keyword">if</span> (Database.instance == <span class="literal">null</span>) then</span><br><span class="line">                    Database.instance = <span class="keyword">new</span> <span class="title class_">Database</span>()</span><br><span class="line">        <span class="keyword">return</span> Database.instance</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, any singleton should define some business logic</span></span><br><span class="line">    <span class="comment">// which can be executed on its instance.</span></span><br><span class="line">    <span class="keyword">public</span> method <span class="title function_">query</span><span class="params">(sql)</span> is</span><br><span class="line">        <span class="comment">// For instance, all database queries of an app go</span></span><br><span class="line">        <span class="comment">// through this method. Therefore, you can place</span></span><br><span class="line">        <span class="comment">// throttling or caching logic here.</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">        <span class="type">Database</span> <span class="variable">foo</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">        foo.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">Database</span> <span class="variable">bar</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">        bar.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">        <span class="comment">// The variable `bar` will contain the same object as</span></span><br><span class="line">        <span class="comment">// the variable `foo`.</span></span><br></pre></td></tr></table></figure>
<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Singleton pattern when a class in your program should have just a single instance available to all clients; for example, a single database object shared by different parts of the program.当程序中的类应该只有一个实例可供所有客户端使用时，请使用单例模式;例如，由程序的不同部分共享的单个数据库对象。</strong></p>
</li>
<li><p>The Singleton pattern disables all other means of creating objects of a class except for the special creation method. This method either creates a new object or returns an existing one if it has already been created.<br>Singleton 模式禁用除特殊创建方法之外的所有其他创建类对象的方法。此方法要么创建一个新对象，要么返回一个现有对象（如果已创建）。</p>
</li>
<li><p><strong>Use the Singleton pattern when you need stricter control over global variables.当您需要对全局变量进行更严格的控制时，请使用单例模式。</strong></p>
</li>
<li><p>Unlike global variables, the Singleton pattern guarantees that there’s just one instance of a class. Nothing, except for the Singleton class itself, can replace the cached instance.<br>与全局变量不同，单例模式保证一个类只有一个实例。除了 Singleton 类本身之外，没有任何内容可以替换缓存的实例。</p>
</li>
</ul>
<p>Note that you can always adjust this limitation and allow creating any number of Singleton instances. The only piece of code that needs changing is the body of the <code>getInstance</code> method.<br>请注意，您始终可以调整此限制，并允许创建任意数量的单例实例。唯一需要更改的代码段是 <code>getInstance</code> 方法的主体。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Add a private static field to the class for storing the singleton instance.<br>在类中添加一个私有静态字段，用于存储单例实例。</p>
</li>
<li><p>Declare a public static creation method for getting the singleton instance.<br>声明用于获取单例实例的公共静态创建方法。</p>
</li>
<li><p>Implement “lazy initialization” inside the static method. It should create a new object on its first call and put it into the static field. The method should always return that instance on all subsequent calls.<br>在静态方法中实现“延迟初始化”。它应该在第一次调用时创建一个新对象，并将其放入静态字段中。该方法应始终在所有后续调用中返回该实例。</p>
</li>
<li><p>Make the constructor of the class private. The static method of the class will still be able to call the constructor, but not the other objects.<br>将类的构造函数设为私有。类的静态方法仍然能够调用构造函数，但不能调用其他对象。</p>
</li>
<li><p>Go over the client code and replace all direct calls to the singleton’s constructor with calls to its static creation method.<br>遍历客户端代码，并将对单例构造函数的所有直接调用替换为对其静态创建方法的调用。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>Pros 优点</th>
<th>Cons 缺点</th>
</tr>
</thead>
<tbody><tr>
<td>You can be sure that a class has only a single instance.可以确定一个类只有一个实例。</td>
<td>Violates the Single Responsibility Principle. The pattern solves two problems at the time.违反了单一责任原则。该模式解决了当时的两个问题。</td>
</tr>
<tr>
<td>You gain a global access point to that instance.您将获得该实例的全局访问点。</td>
<td>The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other.单例模式可以掩盖糟糕的设计，例如，当程序的组件彼此了解太多时。</td>
</tr>
<tr>
<td>The singleton object is initialized only when it’s requested for the first time.仅当首次请求单一实例对象时，才会对其进行初始化。</td>
<td>The pattern requires special treatment in a multithreaded environment so that multiple threads won’t create a singleton object several times.</td>
</tr>
<tr>
<td>该模式需要在多线程环境中进行特殊处理，以便多个线程不会多次创建单一实例对象。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>It may be difficult to unit test the client code of the Singleton because many test frameworks rely on inheritance when producing mock objects. Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don’t write the tests. Or don’t use the Singleton pattern.对 Singleton 的客户端代码进行单元测试可能很困难，因为许多测试框架在生成模拟对象时依赖于继承。由于单例类的构造函数是私有的，并且在大多数语言中不可能重写静态方法，因此您需要想出一种创造性的方法来模拟单例。或者干脆不写测试。或者不要使用单一实例模式。</td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>A <strong>Facade</strong> class can often be transformed into a <strong>Singleton</strong> since a single facade object is sufficient in most cases.<br>Facade 类通常可以转换为 Singleton，因为在大多数情况下，单个 Facade 对象就足够了。</p>
</li>
<li><p><strong>Flyweight</strong> would resemble <strong>Singleton</strong> if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:<br>如果你以某种方式设法将对象的所有共享状态减少到一个蝇量级对象，那么 Flyweight 将类似于 Singleton。但这些模式之间有两个根本区别：</p>
<ol>
<li>There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.<br>应该只有一个 Singleton 实例，而 Flyweight 类可以有多个具有不同内部状态的实例。</li>
<li>The Singleton object can be mutable. Flyweight objects are immutable.<br>Singleton 对象可以是可变的。轻量级对象是不可变的。</li>
</ol>
</li>
<li><p>Abstract Factories, Builders and Prototypes can all be implemented as Singletons.<br>抽象工厂、构建器和原型都可以作为单例实现。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="Python-Navie-Singleton-简单版"><a href="#Python-Navie-Singleton-简单版" class="headerlink" title="Python: Navie Singleton 简单版"></a>Python: Navie Singleton 简单版</h3><p>It’s pretty easy to implement a sloppy Singleton. You just need to hide the constructor and implement a static creation method.<br>实现一个草率的 Singleton 非常容易。你只需要隐藏构造函数并实现一个静态创建方法。</p>
<p>The same class behaves incorrectly in a multithreaded environment. Multiple threads can call the creation method simultaneously and get several instances of Singleton class.<br>同一类在多线程环境中的行为不正确。多个线程可以同时调用创建方法，并获取 Singleton 类的多个实例。</p>
<h4 id="main-py-Conceptual-example"><a href="#main-py-Conceptual-example" class="headerlink" title="main.py: Conceptual example"></a>main.py: Conceptual example</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Singleton class can be implemented in different ways in Python. Some</span></span><br><span class="line"><span class="string">    possible methods include: base class, decorator, metaclass. We will use the</span></span><br><span class="line"><span class="string">    metaclass because it is best suited for this purpose.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Possible changes to the value of the `__init__` argument do not affect</span></span><br><span class="line"><span class="string">        the returned instance.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">            cls._instances[cls] = instance</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(metaclass=SingletonMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_business_logic</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Finally, any singleton should define some business logic, which can be</span></span><br><span class="line"><span class="string">        executed on its instance.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code.</span></span><br><span class="line"></span><br><span class="line">    s1 = Singleton()</span><br><span class="line">    s2 = Singleton()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">id</span>(s1) == <span class="built_in">id</span>(s2):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Singleton works, both variables contain the same instance.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Singleton failed, variables contain different instances.&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Singleton works, both variables contain the same instance.</span><br></pre></td></tr></table></figure>

<h3 id="Python-Thread-safe-Singleton-线程安全单例"><a href="#Python-Thread-safe-Singleton-线程安全单例" class="headerlink" title="Python: Thread-safe Singleton 线程安全单例"></a>Python: Thread-safe Singleton 线程安全单例</h3><p>To fix the problem, you have to synchronize threads during the first creation of the Singleton object.<br>若要解决此问题，必须在首次创建 Singleton 对象期间同步线程。</p>
<h4 id="main-py-Conceptual-example-1"><a href="#main-py-Conceptual-example-1" class="headerlink" title="main.py: Conceptual example"></a>main.py: Conceptual example</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This is a thread-safe implementation of Singleton.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    _lock: Lock = Lock()</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    We now have a lock object that will be used to synchronize threads during</span></span><br><span class="line"><span class="string">    first access to the Singleton.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Possible changes to the value of the `__init__` argument do not affect</span></span><br><span class="line"><span class="string">        the returned instance.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Now, imagine that the program has just been launched. Since there&#x27;s no</span></span><br><span class="line">        <span class="comment"># Singleton instance yet, multiple threads can simultaneously pass the</span></span><br><span class="line">        <span class="comment"># previous conditional and reach this point almost at the same time. The</span></span><br><span class="line">        <span class="comment"># first of them will acquire lock and will proceed further, while the</span></span><br><span class="line">        <span class="comment"># rest will wait here.</span></span><br><span class="line">        <span class="keyword">with</span> cls._lock:</span><br><span class="line">            <span class="comment"># The first thread to acquire the lock, reaches this conditional,</span></span><br><span class="line">            <span class="comment"># goes inside and creates the Singleton instance. Once it leaves the</span></span><br><span class="line">            <span class="comment"># lock block, a thread that might have been waiting for the lock</span></span><br><span class="line">            <span class="comment"># release may then enter this section. But since the Singleton field</span></span><br><span class="line">            <span class="comment"># is already initialized, the thread won&#x27;t create a new object.</span></span><br><span class="line">            <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">                instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">                cls._instances[cls] = instance</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(metaclass=SingletonMeta):</span><br><span class="line">    value: <span class="built_in">str</span> = <span class="literal">None</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    We&#x27;ll use this property to prove that our Singleton really works.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_business_logic</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Finally, any singleton should define some business logic, which can be</span></span><br><span class="line"><span class="string">        executed on its instance.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_singleton</span>(<span class="params">value: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    singleton = Singleton(value)</span><br><span class="line">    <span class="built_in">print</span>(singleton.value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;If you see the same value, then singleton was reused (yay!)\n&quot;</span></span><br><span class="line">          <span class="string">&quot;If you see different values, &quot;</span></span><br><span class="line">          <span class="string">&quot;then 2 singletons were created (booo!!)\n\n&quot;</span></span><br><span class="line">          <span class="string">&quot;RESULT:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    process1 = Thread(target=test_singleton, args=(<span class="string">&quot;FOO&quot;</span>,))</span><br><span class="line">    process2 = Thread(target=test_singleton, args=(<span class="string">&quot;BAR&quot;</span>,))</span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br></pre></td></tr></table></figure>
<h4 id="Output-txt-Execution-result-1"><a href="#Output-txt-Execution-result-1" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If you see the same value, then singleton was reused (yay!)</span><br><span class="line">If you see different values, then 2 singletons were created (booo!!)</span><br><span class="line"></span><br><span class="line">RESULT:</span><br><span class="line"></span><br><span class="line">FOO</span><br><span class="line">FOO</span><br></pre></td></tr></table></figure>

<h3 id="Rust-specifics"><a href="#Rust-specifics" class="headerlink" title="Rust specifics"></a>Rust specifics</h3><p>By definition, Singleton is a global mutable object. In Rust this is a <code>static mut</code> item. Thus, to avoid all sorts of concurrency issues, the function or block that is either reading or writing to a mutable static variable should be marked as an <code>unsafe</code> block.<br>根据定义，Singleton 是一个全局可变对象。在 Rust 中， static mut 这是一个项目。因此，为了避免各种并发问题，应将读取或写入可变静态变量的函数或块标记为 <code>unsafe</code> 块。</p>
<p>For this reason, the Singleton pattern can be percieved as unsafe. However, the pattern is still widely used in practice. A good read-world example of Singleton is a <code>log</code> crate that introduces <code>log!</code>, <code>debug!</code> and other logging macros, which you can use throughout your code after setting up a concrete logger instance, such as <code>env_logger</code>. As we can see, <code>env_logger</code> uses log::set_boxed_logger under the hood, which has an <code>unsafe</code> block to set up a global logger object.<br>因此，Singleton 模式可能被认为是不安全的。然而，该模式在实践中仍然被广泛使用。Singleton 的一个很好的读取世界示例是一个 log crate，它引入了 log! 和其他 debug! 日志记录宏，在设置具体的记录器实例（如 <code>env_logger</code>）后，您可以在整个代码中使用这些宏。正如我们所看到的， <code>env_logger</code> 在后台使用 log：：set_boxed_logger，它有一个 unsafe 用于设置全局记录器对象的块。</p>
<ul>
<li><p>In order to provide safe and usable access to a singleton object, introduce an API hiding unsafe blocks under the hood.<br>为了提供对单例对象的安全且可用的访问，请在后台引入一个隐藏 <code>unsafe</code> 块的 API。</p>
</li>
<li><p>See the thread about a mutable Singleton on Stackoverflow for more information.<br>有关更多信息，请参阅 Stackoverflow 上有关可变 Singleton 的线程。</p>
</li>
</ul>
<p>Starting with Rust 1.63, <code>Mutex::new</code> is <code>const</code>, you can use global static Mutex locks without needing lazy initialization. See the Singleton using <code>Mutex</code> example below.<br>从 Rust 1.63 开始，您可以使用全局静态 Mutex 锁， <code>Mutex::new</code> <code>const</code> 而无需延迟初始化。请参阅下面的使用互斥锁的单例示例。</p>
<h4 id="Safe-Singleton-安全单例"><a href="#Safe-Singleton-安全单例" class="headerlink" title="Safe Singleton 安全单例"></a>Safe Singleton 安全单例</h4><p>A pure safe way to implement Singleton in Rust is using no global variables at all and passing everything around through function arguments. The oldest living variable is an object created at the start of the <code>main()</code>.<br>在 Rust 中实现 Singleton 的一个纯粹安全的方法是完全不使用全局变量，并通过函数参数传递所有内容。最早的活变量是在 的开头创建的对象 <code>main()</code> 。</p>
<h4 id="safe-rs"><a href="#safe-rs" class="headerlink" title="safe.rs"></a>safe.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! A pure safe way to implement Singleton in Rust is using no static variables</span></span><br><span class="line"><span class="comment">//! and passing everything around through function arguments.</span></span><br><span class="line"><span class="comment">//! The oldest living variable is an object created at the start of the `main()`.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(global_state: &amp;<span class="keyword">mut</span> <span class="type">u32</span>) &#123;</span><br><span class="line">    *global_state += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">global_state</span> = <span class="number">0u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> global_state);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Final state: &#123;&#125;&quot;</span>, global_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Final state: 1</span><br></pre></td></tr></table></figure>

<h4 id="Lazy-Singleton-惰性单例模式"><a href="#Lazy-Singleton-惰性单例模式" class="headerlink" title="Lazy Singleton 惰性单例模式"></a>Lazy Singleton 惰性单例模式</h4><p>This is a singleton implementation via <code>lazy_static!</code>, which allows declaring a static variable with lazy initialization at first access. It is actually implemented via <code>unsafe</code> with <code>static mut</code> manipulation, however, it keeps your code clear of <code>unsafe</code> blocks.<br>这是一个单例实现，它 lazy_static! 允许在首次访问时使用延迟初始化声明静态变量。它实际上 <code>unsafe</code> 是通过 <code>static mut</code> 操作实现的，但是，它使您的代码没有 <code>unsafe</code> 块。</p>
<h4 id="lazy-rs"><a href="#lazy-rs" class="headerlink" title="lazy.rs"></a>lazy.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! Taken from: https://stackoverflow.com/questions/27791532/how-do-i-create-a-global-mutable-singleton</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! Rust doesn&#x27;t really allow a singleton pattern without `unsafe` because it</span></span><br><span class="line"><span class="comment">//! doesn&#x27;t have a safe mutable global state.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! `lazy-static` allows declaring a static variable with lazy initialization</span></span><br><span class="line"><span class="comment">//! at first access. It is actually implemented via `unsafe` with `static mut`</span></span><br><span class="line"><span class="comment">//! manipulation, however, it keeps your code clear of `unsafe` blocks.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! `Mutex` provides safe access to a single object.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> ARRAY: Mutex&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_a_call</span>() &#123;</span><br><span class="line">    ARRAY.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Called &#123;&#125;&quot;</span>, ARRAY.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Called 3</span><br></pre></td></tr></table></figure>

<h4 id="Singleton-using-Mutex-使用互斥锁的单例"><a href="#Singleton-using-Mutex-使用互斥锁的单例" class="headerlink" title="Singleton using Mutex 使用互斥锁的单例"></a>Singleton using Mutex 使用互斥锁的单例</h4><p>Starting with <code>Rust 1.63</code>, it can be easier to work with global mutable singletons, although it’s still preferable to avoid global variables in mostcases.<br>从 开始 <code>Rust 1.63</code> ，使用全局可变单例会更容易，尽管在大多数情况下仍然最好避免全局变量。</p>
<p>Now that <code>Mutex::new</code> is <code>const</code>, you can use global static <code>Mutex</code> locks without needing lazy initialization.<br>现在 <code>Mutex::new</code> ，您可以使用全局静态 <code>Mutex </code>锁 <code>const</code> ，而无需延迟初始化。</p>
<h4 id="mutex-rs"><a href="#mutex-rs" class="headerlink" title="mutex.rs"></a>mutex.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! ructc 1.63</span></span><br><span class="line"><span class="comment">//! https://stackoverflow.com/questions/27791532/how-do-i-create-a-global-mutable-singleton</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! Starting with Rust 1.63, it can be easier to work with global mutable</span></span><br><span class="line"><span class="comment">//! singletons, although it&#x27;s still preferable to avoid global variables in most</span></span><br><span class="line"><span class="comment">//! cases.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! Now that `Mutex::new` is `const`, you can use global static `Mutex` locks</span></span><br><span class="line"><span class="comment">//! without needing lazy initialization.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ARRAY: Mutex&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="type">Vec</span>::<span class="title function_ invoke__">new</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_a_call</span>() &#123;</span><br><span class="line">    ARRAY.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Called &#123;&#125; times&quot;</span>, ARRAY.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Called 3 times</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>State 状态模式</title>
    <url>/2024/04/21/design-pattern/state/</url>
    <content><![CDATA[<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p>状态模式是一种行为设计模式，它允许对象在其内部状态更改时更改其行为。看起来好像对象更改了它的类。</p>
<div align="center"> <img src="/images/state-header.png"/><p style="text-align: center;"></p></div>


<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>状态模式与有限状态机的概念密切相关。</p>
<div align="center"> <img src="/images/state-problem1.png"/><p style="text-align: center;">Finite-State Machine. 有限状态机。</p> </div>


<p>主要思想是，在任何给定的时刻，程序可以处于的状态数量是有限的。在任何唯一状态下，程序的行为都不同，程序可以立即从一种状态切换到另一种状态。但是，根据当前状态，程序可能会也可能不会切换到某些其他状态。这些切换规则（称为转换）也是有限的和预先确定的。</p>
<p>您也可以将此方法应用于对象。想象一下，我们有一个 您也可以将此方法应用于对象。想象一下，我们有一个 <code>Document</code> 类。文档可以处于以下三种状态之一： <code>Draft</code>、<code>Moderation</code> 和 <code>Published</code> 。<code>publish</code> 方法在每种状态下的工作方式略有不同： </p>
<ul>
<li>在<code>Draft</code>中，它会将文档移动到审核状态。</li>
<li>在<code>Moderation</code>中，它使文档公开，但前提是当前用户是管理员。</li>
<li>在<code>Published</code>中，它根本不做任何事情。</li>
</ul>
<div align="center"> <img src="/images/state-problem2.png"/><p style="text-align: center;">文档对象的可能状态和转换。</p></div>

<p>状态机通常使用大量条件语句（ <code>if</code> 或<code>switch</code> ）实现，这些条件语句根据对象的当前状态选择适当的行为。通常，此“状态”只是对象字段的一组值。即使你以前从未听说过有限状态机，你也可能至少实现过一次状态。以下代码结构是否敲响了警钟？ ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> is</span><br><span class="line">    field state: string</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    method <span class="title function_">publish</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">switch</span> <span class="params">(state)</span></span><br><span class="line">            <span class="string">&quot;draft&quot;</span>:</span><br><span class="line">                state = <span class="string">&quot;moderation&quot;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="string">&quot;moderation&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> (currentUser.role == <span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                    state = <span class="string">&quot;published&quot;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="string">&quot;published&quot;</span>:</span><br><span class="line">                <span class="comment">// Do nothing.</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>一旦我们开始向 <code>Document</code> 类中添加越来越多的状态和状态依赖行为，基于条件的状态机的最大弱点就会显现出来。大多数方法都会包含可怕的条件，这些条件根据当前状态选择方法的正确行为。像这样的代码很难维护，因为对转换逻辑的任何更改都可能需要更改每个方法中的状态条件。 类中添加越来越多的状态和状态依赖行为，基于条件的状态机的最大弱点就会显现出来。大多数方法都会包含可怕的条件，这些条件根据当前状态选择方法的正确行为。像这样的代码很难维护，因为对转换逻辑的任何更改都可能需要更改每个方法中的状态条件。</p>
<p>随着项目的发展，问题往往会变得更大。在设计阶段预测所有可能的状态和转变是相当困难的。因此，随着时间的流逝，使用一组有限的条件构建的精益状态机可能会变得一团糟。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>状态模式建议您为对象的所有可能状态创建新类，并将所有特定于状态的行为提取到这些类中。</p>
<p>原始对象（称为 context）不是自行实现所有行为，而是存储对表示其当前状态的状态对象之一的引用，并将所有与状态相关的工作委托给该对象。</p>
<div align="center"> <img src="/images/state-solution.png"/><p style="text-align: center;">文档将工作委托给状态对象。</p></div>

<p>若要将上下文转换为另一种状态，请将活动状态对象替换为表示该新状态的另一个对象。只有当所有状态类都遵循相同的接口，并且上下文本身通过该接口处理这些对象时，这才有可能。</p>
<p>此结构可能看起来类似于策略模式，但有一个关键区别。在状态模式中，特定状态可能相互了解并启动从一种状态到另一种状态的过渡，而策略几乎从不相互了解。</p>
<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><p>智能手机中的按钮和开关的行为会根据设备的当前状态而有所不同：</p>
<ul>
<li>手机解锁后，按下按钮可以执行各种功能。</li>
<li>当手机锁定时，按任意按钮都会进入解锁屏幕。</li>
<li>当手机电量不足时，按任意按钮都会显示充电屏幕。</li>
</ul>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/state-structure.png"/><p style="text-align: center;"></p></div>

<ol>
<li><p>上下文存储对某个具体状态对象的引用，并将所有特定于状态的工作委托给它。上下文通过状态接口与状态对象进行通信。上下文公开一个 setter 用于向其传递新的状态对象。</p>
</li>
<li><p>State 接口声明特定于状态的方法。这些方法应该对所有具体状态都有意义，因为你不希望你的某些状态具有永远不会被调用的无用方法。</p>
</li>
<li><p>具体状态为特定于状态的方法提供自己的实现。为了避免在多个状态下重复相似的代码，您可以提供封装一些常见行为的中间抽象类。</p>
<p>状态对象可以存储对上下文对象的反向引用。通过此引用，状态可以从上下文对象中获取任何所需的信息，并启动状态转换。</p>
</li>
<li><p>上下文和具体状态都可以设置上下文的下一个状态，并通过替换链接到上下文的状态对象来执行实际的状态转换。</p>
</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>在此示例中，状态模式允许媒体播放器的相同控件以不同的方式运行，具体取决于当前播放状态。</p>
<div align="center"> <img src="/images/state-example.png"/><p style="text-align: center;"></p>使用状态对象更改对象行为的示例。</div>


<p>播放器的主要对象始终与一个状态对象相链接，该状态对象执行播放器的大部分工作。一些动作会将播放器当前的状态对象替换为另一个，这改变了播放器对用户交互的反应方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The AudioPlayer class acts as a context. It also maintains a</span></span><br><span class="line"><span class="comment">// reference to an instance of one of the state classes that</span></span><br><span class="line"><span class="comment">// represents the current state of the audio player.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioPlayer</span> is</span><br><span class="line">    field state: State</span><br><span class="line">    field UI, volume, playlist, currentSong</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">AudioPlayer</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="keyword">new</span> <span class="title class_">ReadyState</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Context delegates handling user input to a state</span></span><br><span class="line">        <span class="comment">// object. Naturally, the outcome depends on what state</span></span><br><span class="line">        <span class="comment">// is currently active, since each state can handle the</span></span><br><span class="line">        <span class="comment">// input differently.</span></span><br><span class="line">        UI = <span class="keyword">new</span> <span class="title class_">UserInterface</span>()</span><br><span class="line">        UI.lockButton.onClick(<span class="built_in">this</span>.clickLock)</span><br><span class="line">        UI.playButton.onClick(<span class="built_in">this</span>.clickPlay)</span><br><span class="line">        UI.nextButton.onClick(<span class="built_in">this</span>.clickNext)</span><br><span class="line">        UI.prevButton.onClick(<span class="built_in">this</span>.clickPrevious)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other objects must be able to switch the audio player&#x27;s</span></span><br><span class="line">    <span class="comment">// active state.</span></span><br><span class="line">    method <span class="title function_">changeState</span><span class="params">(state: State)</span> is</span><br><span class="line">        <span class="built_in">this</span>.state = state</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UI methods delegate execution to the active state.</span></span><br><span class="line">    method <span class="title function_">clickLock</span><span class="params">()</span> is</span><br><span class="line">        state.clickLock()</span><br><span class="line">    method <span class="title function_">clickPlay</span><span class="params">()</span> is</span><br><span class="line">        state.clickPlay()</span><br><span class="line">    method <span class="title function_">clickNext</span><span class="params">()</span> is</span><br><span class="line">        state.clickNext()</span><br><span class="line">    method <span class="title function_">clickPrevious</span><span class="params">()</span> is</span><br><span class="line">        state.clickPrevious()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A state may call some service methods on the context.</span></span><br><span class="line">    method <span class="title function_">startPlayback</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    method <span class="title function_">stopPlayback</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    method <span class="title function_">nextSong</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    method <span class="title function_">previousSong</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    method <span class="title function_">fastForward</span><span class="params">(time)</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    method <span class="title function_">rewind</span><span class="params">(time)</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The base state class declares methods that all concrete</span></span><br><span class="line"><span class="comment">// states should implement and also provides a backreference to</span></span><br><span class="line"><span class="comment">// the context object associated with the state. States can use</span></span><br><span class="line"><span class="comment">// the backreference to transition the context to another state.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">State</span> is</span><br><span class="line">    <span class="keyword">protected</span> field player: AudioPlayer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Context passes itself through the state constructor. This</span></span><br><span class="line">    <span class="comment">// may help a state fetch some useful context data if it&#x27;s</span></span><br><span class="line">    <span class="comment">// needed.</span></span><br><span class="line">    constructor <span class="title function_">State</span><span class="params">(player)</span> is</span><br><span class="line">        <span class="built_in">this</span>.player = player</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">clickLock</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">clickPlay</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">clickNext</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">clickPrevious</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete states implement various behaviors associated with a</span></span><br><span class="line"><span class="comment">// state of the context.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockedState</span> <span class="keyword">extends</span> <span class="title class_">State</span> is</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When you unlock a locked player, it may assume one of two</span></span><br><span class="line">    <span class="comment">// states.</span></span><br><span class="line">    method <span class="title function_">clickLock</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(player.playing)</span></span><br><span class="line">            player.changeState(<span class="keyword">new</span> <span class="title class_">PlayingState</span>(player))</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            player.changeState(<span class="keyword">new</span> <span class="title class_">ReadyState</span>(player))</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clickPlay</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Locked, so do nothing.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clickNext</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Locked, so do nothing.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clickPrevious</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Locked, so do nothing.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// They can also trigger state transitions in the context.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadyState</span> <span class="keyword">extends</span> <span class="title class_">State</span> is</span><br><span class="line">    method <span class="title function_">clickLock</span><span class="params">()</span> is</span><br><span class="line">        player.changeState(<span class="keyword">new</span> <span class="title class_">LockedState</span>(player))</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clickPlay</span><span class="params">()</span> is</span><br><span class="line">        player.startPlayback()</span><br><span class="line">        player.changeState(<span class="keyword">new</span> <span class="title class_">PlayingState</span>(player))</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clickNext</span><span class="params">()</span> is</span><br><span class="line">        player.nextSong()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clickPrevious</span><span class="params">()</span> is</span><br><span class="line">        player.previousSong()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayingState</span> <span class="keyword">extends</span> <span class="title class_">State</span> is</span><br><span class="line">    method <span class="title function_">clickLock</span><span class="params">()</span> is</span><br><span class="line">        player.changeState(<span class="keyword">new</span> <span class="title class_">LockedState</span>(player))</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clickPlay</span><span class="params">()</span> is</span><br><span class="line">        player.stopPlayback()</span><br><span class="line">        player.changeState(<span class="keyword">new</span> <span class="title class_">ReadyState</span>(player))</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clickNext</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(event.doubleclick)</span></span><br><span class="line">            player.nextSong()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            player.fastForward(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clickPrevious</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(event.doubleclick)</span></span><br><span class="line">            player.previous()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            player.rewind(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ol>
<li>如果对象的行为根据其当前状态而有所不同，状态数量巨大，并且特定于状态的代码经常更改，请使用 State 模式。</li>
<li>该模式建议将所有特定于状态的代码提取到一组不同的类中。因此，您可以相互独立地添加新状态或更改现有状态，从而降低维护成本。</li>
<li>当类被大量条件污染时，请使用该模式，这些条件会根据类字段的当前值改变类的行为方式。</li>
<li>State 模式允许您将这些条件的分支提取到相应状态类的方法中。执行此操作时，还可以从主类中清除特定于状态的代码中涉及的临时字段和帮助程序方法。</li>
<li>当在基于条件的状态机的类似状态和转换中有许多重复代码时，请使用状态。</li>
<li>State 模式允许您编写状态类的层次结构，并通过将公共代码提取到抽象基类中来减少重复。</li>
</ol>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>确定哪个类将充当上下文。它可以是已经具有状态相关代码的现有类;或新类（如果特定于状态的代码分布在多个类中）。</p>
</li>
<li><p>声明状态接口。尽管它可以镜像上下文中声明的所有方法，但仅针对那些可能包含特定于状态的行为的方法。</p>
</li>
<li><p>对于每个实际状态，创建一个派生自状态接口的类。然后检查上下文的方法，并将与该状态相关的所有代码提取到新创建的类中。</p>
<p>将代码移动到 state 类时，您可能会发现它依赖于上下文的私有成员。有几种解决方法：</p>
<ul>
<li>将这些字段或方法设为公共。</li>
<li>将要提取的行为转换为上下文中的公共方法，并从 state 类中调用它。这种方式很丑陋，但速度很快，您可以随时稍后修复它。</li>
<li>将状态类嵌套到 context 类中，但前提是您的编程语言支持嵌套类。</li>
</ul>
</li>
<li><p>在上下文类中，添加状态接口类型的引用字段和允许重写该字段值的公共 setter 。</p>
</li>
<li><p>再次浏览上下文的方法，并将空状态条件替换为对状态对象的相应方法的调用。</p>
</li>
<li><p>若要切换上下文的状态，请创建其中一个状态类的实例并将其传递给上下文。您可以在上下文本身、各种状态或客户端中执行此操作。无论在哪里执行此操作，该类都依赖于它实例化的具体状态类。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>优点√</th>
<th>缺点×</th>
</tr>
</thead>
<tbody><tr>
<td>单一责任原则。将与特定状态相关的代码组织到单独的类中。</td>
<td>如果状态机只有几个状态或很少更改，则应用该模式可能有点矫枉过正。</td>
</tr>
<tr>
<td>开&#x2F;闭原则。在不更改现有状态类或上下文的情况下引入新状态。</td>
<td></td>
</tr>
<tr>
<td>通过消除笨重的状态机条件来简化上下文的代码。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li>桥接、状态、策略（在某种程度上还有适配器）具有非常相似的结构。事实上，所有这些模式都是基于构图的，而构图是将工作委托给其他对象。但是，它们都解决了不同的问题。模式不仅仅是以特定方式构建代码的秘诀。它还可以向其他开发人员传达该模式解决的问题。</li>
<li>状态可以看作是战略的延伸。这两种模式都基于组合：它们通过将一些工作委派给帮助对象来改变上下文的行为。策略使这些对象完全独立，彼此不相知。但是，State 不会限制具体状态之间的依赖关系，而是允许它们随意更改上下文的状态。</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h1 id="State-in-Python"><a href="#State-in-Python" class="headerlink" title="State in Python"></a><strong>State</strong> in Python</h1><p>状态是一种行为设计模式，它允许对象在其内部状态更改时更改行为。</p>
<p>该模式将与状态相关的行为提取到单独的状态类中，并强制原始对象将工作委托给这些类的实例，而不是自行操作。</p>
<p>使用示例：状态模式在 Python 中常用于将大量 使用示例：状态模式在 Python 中常用于将大量 <code>switch</code> -base 状态机转换为对象。 -base 状态机转换为对象。</p>
<p>标识：状态模式可以通过根据对象状态改变其行为的方法识别，并由外部控制。</p>
<h2 id="Conceptual-Example-概念示例"><a href="#Conceptual-Example-概念示例" class="headerlink" title="Conceptual Example 概念示例"></a>Conceptual Example 概念示例</h2><p>此示例说明了状态设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>它由哪些类组成？</li>
<li>这些课程扮演什么角色？</li>
<li>模式的元素以何种方式相关？</li>
</ul>
<h4 id="main-py：概念示例"><a href="#main-py：概念示例" class="headerlink" title="main.py：概念示例"></a>main.py：概念示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Context defines the interface of interest to clients. It also maintains</span></span><br><span class="line"><span class="string">    a reference to an instance of a State subclass, which represents the current</span></span><br><span class="line"><span class="string">    state of the Context.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _state = <span class="literal">None</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A reference to the current state of the Context.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state: State</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.transition_to(state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transition_to</span>(<span class="params">self, state: State</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Context allows changing the State object at runtime.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Context: Transition to <span class="subst">&#123;<span class="built_in">type</span>(state).__name__&#125;</span>&quot;</span>)</span><br><span class="line">        self._state = state</span><br><span class="line">        self._state.context = self</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Context delegates part of its behavior to the current State object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request1</span>(<span class="params">self</span>):</span><br><span class="line">        self._state.handle1()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request2</span>(<span class="params">self</span>):</span><br><span class="line">        self._state.handle2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The base State class declares methods that all Concrete State should</span></span><br><span class="line"><span class="string">    implement and also provides a backreference to the Context object,</span></span><br><span class="line"><span class="string">    associated with the State. This backreference can be used by States to</span></span><br><span class="line"><span class="string">    transition the Context to another State.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">context</span>(<span class="params">self</span>) -&gt; Context:</span><br><span class="line">        <span class="keyword">return</span> self._context</span><br><span class="line"></span><br><span class="line"><span class="meta">    @context.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">context</span>(<span class="params">self, context: Context</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._context = context</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle2</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete States implement various behaviors, associated with a state of the</span></span><br><span class="line"><span class="string">Context.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateA</span>(<span class="title class_ inherited__">State</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateA handles request1.&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateA wants to change the state of the context.&quot;</span>)</span><br><span class="line">        self.context.transition_to(ConcreteStateB())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle2</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateA handles request2.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateB</span>(<span class="title class_ inherited__">State</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateB handles request1.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle2</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateB handles request2.&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateB wants to change the state of the context.&quot;</span>)</span><br><span class="line">        self.context.transition_to(ConcreteStateA())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code.</span></span><br><span class="line"></span><br><span class="line">    context = Context(ConcreteStateA())</span><br><span class="line">    context.request1()</span><br><span class="line">    context.request2()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a><strong>Output.txt:</strong> Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Context: Transition to ConcreteStateA</span><br><span class="line">ConcreteStateA handles request1.</span><br><span class="line">ConcreteStateA wants to change the state of the context.</span><br><span class="line">Context: Transition to ConcreteStateB</span><br><span class="line">ConcreteStateB handles request2.</span><br><span class="line">ConcreteStateB wants to change the state of the context.</span><br><span class="line">Context: Transition to ConcreteStateA</span><br></pre></td></tr></table></figure>

<h1 id="State-in-Rust"><a href="#State-in-Rust" class="headerlink" title="State in Rust"></a><strong>State</strong> in Rust</h1><p>状态是一种行为设计模式，它允许对象在其内部状态更改时更改行为。</p>
<p>该模式将与状态相关的行为提取到单独的状态类中，并强制原始对象将工作委托给这些类的实例，而不是自行操作。</p>
<p>状态模式与有限状态机 （FSM） 概念相关，但是，每个状态都由实现公共状态特征的单独类型表示，而不是实现大量条件语句。状态之间的转换取决于每种状态类型的特定特征实现。</p>
<h2 id="Music-Player-音乐播放器"><a href="#Music-Player-音乐播放器" class="headerlink" title="Music Player 音乐播放器"></a>Music Player 音乐播放器</h2><p>让我们构建一个具有以下状态转换的音乐播放器：</p>
<div align="center"> <img src="/images/state-code-rust-example.jpeg"/><p style="text-align: center;"></p></div>


<p>有一个基本特征 <code>State</code> 和 <code>play</code> <code>stop</code> 方法，可以进行状态转换：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">play</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">stop</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>next</code> 和 <code>prev</code> 不会改变状态，它们在一个单独的 <code>impl dyn State</code> 块中有默认实现，无法被重写。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">dyn</span> State &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">next</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">prev</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个状态都是实现以下各项的 <code>trait State</code> 类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StoppedState</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PausedState</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PlayingState</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">StoppedState</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">PausedState</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论如何，它的工作原理如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">state</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(StoppedState);   <span class="comment">// StoppedState.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">state</span> = state.<span class="title function_ invoke__">play</span>(&amp;<span class="keyword">mut</span> player);  <span class="comment">// StoppedState -&gt; PlayingState.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">state</span> = state.<span class="title function_ invoke__">play</span>(&amp;<span class="keyword">mut</span> player);  <span class="comment">// PlayingState -&gt; PausedState.</span></span><br></pre></td></tr></table></figure>

<p>在这里，相同的操作 <code>play</code> 会根据调用位置转换到不同的状态：</p>
<ol>
<li><p><code>StoppedState</code> <code>play</code> 的实现开始播放并返回 <code>PlayingState</code> 。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">play</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">    player.<span class="title function_ invoke__">play</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stopped -&gt; Playing.</span></span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PlayingState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>PlayingState</code> 再次点击“播放”按钮后暂停播放：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn play(self: Box&lt;Self&gt;, player: &amp;mut Player) -&gt; Box&lt;dyn State&gt; &#123;</span><br><span class="line">    player.pause();</span><br><span class="line"></span><br><span class="line">    // Playing -&gt; Paused.</span><br><span class="line">    Box::new(PausedState)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些方法使用特殊 <code>self: Box&lt;Self&gt;</code> 表示法定义。</p>
<p>为什么？</p>
<ol>
<li>首先， <code>self</code> 不是引用，它意味着该方法是“一次性”，它销毁 <code>self</code> 并交换到另一个状态返回 <code>Box&lt;dyn State&gt;</code> 。</li>
<li>其次，该方法使用<code>Box</code>对象 <code>Box&lt;dyn State&gt;</code> 而不是具体类型的对象 <code>PlayingState</code> ，因为具体状态在编译时是未知的。</li>
</ol>
<h4 id="player-rs"><a href="#player-rs" class="headerlink" title="player.rs"></a><strong>player.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A music track.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Track</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> duration: <span class="type">u32</span>,</span><br><span class="line">    cursor: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Track</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(title: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>, duration: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            title: title.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            duration,</span><br><span class="line">            cursor: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A music player holds a playlist and it can do basic operations over it.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    playlist: <span class="type">Vec</span>&lt;Track&gt;,</span><br><span class="line">    current_track: <span class="type">usize</span>,</span><br><span class="line">    _volume: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Default</span> <span class="keyword">for</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            playlist: <span class="built_in">vec!</span>[</span><br><span class="line">                Track::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Track 1&quot;</span>, <span class="number">180</span>),</span><br><span class="line">                Track::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Track 2&quot;</span>, <span class="number">165</span>),</span><br><span class="line">                Track::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Track 3&quot;</span>, <span class="number">197</span>),</span><br><span class="line">                Track::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Track 4&quot;</span>, <span class="number">205</span>),</span><br><span class="line">            ],</span><br><span class="line">            current_track: <span class="number">0</span>,</span><br><span class="line">            _volume: <span class="number">25</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">next_track</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.current_track = (<span class="keyword">self</span>.current_track + <span class="number">1</span>) % <span class="keyword">self</span>.playlist.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">prev_track</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.current_track = (<span class="keyword">self</span>.playlist.<span class="title function_ invoke__">len</span>() + <span class="keyword">self</span>.current_track - <span class="number">1</span>) % <span class="keyword">self</span>.playlist.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">play</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">track_mut</span>().cursor = <span class="number">10</span>; <span class="comment">// Playback imitation.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">pause</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">track_mut</span>().cursor = <span class="number">43</span>; <span class="comment">// Paused at some moment.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rewind</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">track_mut</span>().cursor = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">track</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;Track &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.playlist[<span class="keyword">self</span>.current_track]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">track_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> Track &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.playlist[<span class="keyword">self</span>.current_track]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="state-rs"><a href="#state-rs" class="headerlink" title="state.rs"></a><strong>state.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> cursive::views::TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::player::Player;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StoppedState</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PausedState</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PlayingState</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// There is a base `State` trait with methods `play` and `stop` which make</span></span><br><span class="line"><span class="comment">/// state transitions. There are also `next` and `prev` methods in a separate</span></span><br><span class="line"><span class="comment">/// `impl dyn State` block below, those are default implementations</span></span><br><span class="line"><span class="comment">/// that cannot be overridden.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// What is the `self: Box&lt;Self&gt;` notation? We use the state as follows:</span></span><br><span class="line"><span class="comment">/// ```rust</span></span><br><span class="line"><span class="comment">///   let prev_state = Box::new(PlayingState);</span></span><br><span class="line"><span class="comment">///   let next_state = prev_state.play(&amp;mut player);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// A method `play` receives a whole `Box&lt;PlayingState&gt;` object,</span></span><br><span class="line"><span class="comment">/// and not just `PlayingState`. The previous state &quot;disappears&quot; in the method,</span></span><br><span class="line"><span class="comment">/// in turn, it returns a new `Box&lt;PausedState&gt;` state object.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">play</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">stop</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>, player: &amp;Player, view: &amp;<span class="keyword">mut</span> TextView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">StoppedState</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">play</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        player.<span class="title function_ invoke__">play</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stopped -&gt; Playing.</span></span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PlayingState)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">stop</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, _: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="comment">// Change no state.</span></span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>, _: &amp;Player, view: &amp;<span class="keyword">mut</span> TextView) &#123;</span><br><span class="line">        view.<span class="title function_ invoke__">set_content</span>(<span class="string">&quot;[Stopped] Press &#x27;Play&#x27;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">PausedState</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">play</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        player.<span class="title function_ invoke__">pause</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Paused -&gt; Playing.</span></span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PlayingState)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">stop</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        player.<span class="title function_ invoke__">pause</span>();</span><br><span class="line">        player.<span class="title function_ invoke__">rewind</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Paused -&gt; Stopped.</span></span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(StoppedState)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>, player: &amp;Player, view: &amp;<span class="keyword">mut</span> TextView) &#123;</span><br><span class="line">        view.<span class="title function_ invoke__">set_content</span>(<span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;[Paused] &#123;&#125; - &#123;&#125; sec&quot;</span>,</span><br><span class="line">            player.<span class="title function_ invoke__">track</span>().title,</span><br><span class="line">            player.<span class="title function_ invoke__">track</span>().duration</span><br><span class="line">        ))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">PlayingState</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">play</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        player.<span class="title function_ invoke__">pause</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Playing -&gt; Paused.</span></span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PausedState)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">stop</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        player.<span class="title function_ invoke__">pause</span>();</span><br><span class="line">        player.<span class="title function_ invoke__">rewind</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Playing -&gt; Stopped.</span></span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(StoppedState)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>, player: &amp;Player, view: &amp;<span class="keyword">mut</span> TextView) &#123;</span><br><span class="line">        view.<span class="title function_ invoke__">set_content</span>(<span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;[Playing] &#123;&#125; - &#123;&#125; sec&quot;</span>,</span><br><span class="line">            player.<span class="title function_ invoke__">track</span>().title,</span><br><span class="line">            player.<span class="title function_ invoke__">track</span>().duration</span><br><span class="line">        ))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default &quot;next&quot; and &quot;prev&quot; implementations for the trait.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">dyn</span> State &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">next</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        player.<span class="title function_ invoke__">next_track</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Change no state.</span></span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">prev</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;, player: &amp;<span class="keyword">mut</span> Player) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        player.<span class="title function_ invoke__">prev_track</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Change no state.</span></span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a><strong>main.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> player;</span><br><span class="line"><span class="keyword">mod</span> state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> cursive::&#123;</span><br><span class="line">    event::Key,</span><br><span class="line">    view::Nameable,</span><br><span class="line">    views::&#123;Dialog, TextView&#125;,</span><br><span class="line">    Cursive,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> player::Player;</span><br><span class="line"><span class="keyword">use</span> state::&#123;State, StoppedState&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Application context: a music player and a state.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerApplication</span> &#123;</span><br><span class="line">    player: Player,</span><br><span class="line">    state: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app</span> = cursive::<span class="title function_ invoke__">default</span>();</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_ invoke__">set_user_data</span>(PlayerApplication &#123;</span><br><span class="line">        player: Player::<span class="title function_ invoke__">default</span>(),</span><br><span class="line">        state: <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(StoppedState),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_ invoke__">add_layer</span>(</span><br><span class="line">        Dialog::<span class="title function_ invoke__">around</span>(TextView::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Press Play&quot;</span>).<span class="title function_ invoke__">with_name</span>(<span class="string">&quot;Player Status&quot;</span>))</span><br><span class="line">            .<span class="title function_ invoke__">title</span>(<span class="string">&quot;Music Player&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">button</span>(<span class="string">&quot;Play&quot;</span>, |s| <span class="title function_ invoke__">execute</span>(s, <span class="string">&quot;Play&quot;</span>))</span><br><span class="line">            .<span class="title function_ invoke__">button</span>(<span class="string">&quot;Stop&quot;</span>, |s| <span class="title function_ invoke__">execute</span>(s, <span class="string">&quot;Stop&quot;</span>))</span><br><span class="line">            .<span class="title function_ invoke__">button</span>(<span class="string">&quot;Prev&quot;</span>, |s| <span class="title function_ invoke__">execute</span>(s, <span class="string">&quot;Prev&quot;</span>))</span><br><span class="line">            .<span class="title function_ invoke__">button</span>(<span class="string">&quot;Next&quot;</span>, |s| <span class="title function_ invoke__">execute</span>(s, <span class="string">&quot;Next&quot;</span>)),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_ invoke__">add_global_callback</span>(Key::Esc, |s| s.<span class="title function_ invoke__">quit</span>());</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">execute</span>(s: &amp;<span class="keyword">mut</span> Cursive, button: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">PlayerApplication</span> &#123;</span><br><span class="line">        <span class="keyword">mut</span> player,</span><br><span class="line">        <span class="keyword">mut</span> state,</span><br><span class="line">    &#125; = s.<span class="title function_ invoke__">take_user_data</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">view</span> = s.find_name::&lt;TextView&gt;(<span class="string">&quot;Player Status&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here is how state mechanics work: the previous state</span></span><br><span class="line">    <span class="comment">// executes an action and returns a new state.</span></span><br><span class="line">    <span class="comment">// Each state has all 4 operations but reacts differently.</span></span><br><span class="line">    state = <span class="keyword">match</span> button &#123;</span><br><span class="line">        <span class="string">&quot;Play&quot;</span> =&gt; state.<span class="title function_ invoke__">play</span>(&amp;<span class="keyword">mut</span> player),</span><br><span class="line">        <span class="string">&quot;Stop&quot;</span> =&gt; state.<span class="title function_ invoke__">stop</span>(&amp;<span class="keyword">mut</span> player),</span><br><span class="line">        <span class="string">&quot;Prev&quot;</span> =&gt; state.<span class="title function_ invoke__">prev</span>(&amp;<span class="keyword">mut</span> player),</span><br><span class="line">        <span class="string">&quot;Next&quot;</span> =&gt; state.<span class="title function_ invoke__">next</span>(&amp;<span class="keyword">mut</span> player),</span><br><span class="line">        _ =&gt; <span class="built_in">unreachable!</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    state.<span class="title function_ invoke__">render</span>(&amp;player, &amp;<span class="keyword">mut</span> view);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">set_user_data</span>(PlayerApplication &#123; player, state &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><div align="center"> <img src="/images/state-rust-example-screenshots1.png"/><p style="text-align: center;"></p></div>





<div align="center"> <img src="/images/state-rust-example-screenshots2.png"/><p style="text-align: center;"></p></div>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Strategy 策略模式</title>
    <url>/2024/04/21/design-pattern/strategy/</url>
    <content><![CDATA[<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p>策略是一种行为设计模式，可用于定义一系列算法，将每个算法放入单独的类中，并使其对象可互换。</p>
<div align="center"> <img src="/images/strategy-header.png"/><p style="text-align: center;"></p></div>


<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>有一天，您决定为休闲旅行者创建一个导航应用程序。该应用程序以一张漂亮的地图为中心，可帮助用户在任何城市快速定位自己。</p>
<p>该应用程序最需要的功能之一是自动路线规划。用户应该能够输入地址，并查看地图上显示的到达该目的地的最快路线。</p>
<p>该应用程序的第一个版本只能在道路上构建路线。开车旅行的人们都欢呼雀跃。但显然，并不是每个人都喜欢在度假时开车。因此，在下一次更新中，您添加了一个构建步行路线的选项。在那之后，你添加了另一个选项，让人们在他们的路线中使用公共交通工具。</p>
<p>然而，这仅仅是个开始。后来，您计划为骑自行车的人添加路线建设。甚至后来，还有另一种选择，可以建造穿越城市所有旅游景点的路线。</p>
<div align="center"> <img src="/images/strategy-problem1.png"/><p style="text-align: center;">导航器的代码变得臃肿。</p></div>


<p>虽然从商业角度来看，该应用程序是成功的，但技术部分却让您头疼不已。每次添加新的路由算法时，导航器的主类大小都会增加一倍。在某些时候，野兽变得太难维护了。</p>
<p>对其中一种算法的任何更改，无论是简单的错误修复还是街道分数的轻微调整，都会影响整个班级，从而增加在已经工作的代码中产生错误的机会。</p>
<p>此外，团队合作变得效率低下。你的队友在成功发布后立即被雇用，他们抱怨他们花了太多时间解决合并冲突。实现一个新功能需要你改变同一个巨大的类，与其他人生成的代码冲突。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>策略模式建议你选择一个以多种不同方式做特定事情的类，并将所有这些算法提取到称为策略的单独类中。</p>
<p>原始类（称为 context）必须具有一个字段，用于存储对其中一个策略的引用。上下文将工作委托给链接的策略对象，而不是单独执行它。</p>
<p>上下文不负责为作业选择适当的算法。相反，客户端将所需的策略传递给上下文。事实上，上下文对策略知之甚少。它通过相同的通用接口与所有策略一起工作，该接口仅公开用于触发封装在所选策略中的算法的单一方法。</p>
<p>这样，上下文就独立于具体策略，因此您可以添加新算法或修改现有算法，而无需更改上下文或其他策略的代码。</p>
<div align="center"> <img src="/images/strategy-problem1.png"/><p style="text-align: center;">路线规划策略。</p></div>


<p>在我们的导航应用程序中，可以使用单个 <code>buildRoute</code> 方法将每个路由算法提取到其自己的类中。该方法接受起点和终点，并返回路由检查点的集合。</p>
<p>尽管给定相同的参数，每个路由类可能会构建不同的路由，但主导航器类并不真正关心选择哪种算法，因为它的主要工作是在地图上呈现一组检查点。该类具有切换活动路由策略的方法，因此其客户端（如用户界面中的按钮）可以将当前选定的路由行为替换为另一个路由行为。</p>
<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><div align="center"> <img src="/images/strategy-comic1.png"/><p style="text-align: center;">前往机场的各种策略。</p></div>


<p>想象一下，你必须去机场。您可以搭乘公共汽车、叫出租车或骑自行车。这些是您的运输策略。您可以根据预算或时间限制等因素选择其中一种策略。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/strategy-structure.png"/><p style="text-align: center;"></p></div>


<ol>
<li>上下文维护对其中一个具体策略的引用，并仅通过策略接口与此对象进行通信。</li>
<li>策略界面是所有具体策略的通用界面。它声明上下文用于执行策略的方法。</li>
<li>具体策略实现上下文使用的算法的不同变体。</li>
<li>上下文每次需要运行算法时都会在链接的策略对象上调用执行方法。上下文不知道它使用哪种类型的策略，也不知道算法是如何执行的。</li>
<li>客户端创建一个特定的策略对象并将其传递给上下文。上下文公开了一个 setter，它允许客户端在运行时替换与上下文关联的策略。</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>在此示例中，上下文使用多种策略来执行各种算术运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The strategy interface declares operations common to all</span></span><br><span class="line"><span class="comment">// supported versions of some algorithm. The context uses this</span></span><br><span class="line"><span class="comment">// interface to call the algorithm defined by the concrete</span></span><br><span class="line"><span class="comment">// strategies.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> is</span><br><span class="line">    method <span class="title function_">execute</span><span class="params">(a, b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete strategies implement the algorithm while following</span></span><br><span class="line"><span class="comment">// the base strategy interface. The interface makes them</span></span><br><span class="line"><span class="comment">// interchangeable in the context.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyAdd</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> is</span><br><span class="line">    method <span class="title function_">execute</span><span class="params">(a, b)</span> is</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategySubtract</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> is</span><br><span class="line">    method <span class="title function_">execute</span><span class="params">(a, b)</span> is</span><br><span class="line">        <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyMultiply</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> is</span><br><span class="line">    method <span class="title function_">execute</span><span class="params">(a, b)</span> is</span><br><span class="line">        <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="comment">// The context defines the interface of interest to clients.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> is</span><br><span class="line">    <span class="comment">// The context maintains a reference to one of the strategy</span></span><br><span class="line">    <span class="comment">// objects. The context doesn&#x27;t know the concrete class of a</span></span><br><span class="line">    <span class="comment">// strategy. It should work with all strategies via the</span></span><br><span class="line">    <span class="comment">// strategy interface.</span></span><br><span class="line">    <span class="keyword">private</span> strategy: Strategy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Usually the context accepts a strategy through the</span></span><br><span class="line">    <span class="comment">// constructor, and also provides a setter so that the</span></span><br><span class="line">    <span class="comment">// strategy can be switched at runtime.</span></span><br><span class="line">    method <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> is</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The context delegates some work to the strategy object</span></span><br><span class="line">    <span class="comment">// instead of implementing multiple versions of the</span></span><br><span class="line">    <span class="comment">// algorithm on its own.</span></span><br><span class="line">    method <span class="title function_">executeStrategy</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> is</span><br><span class="line">        <span class="keyword">return</span> strategy.execute(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The client code picks a concrete strategy and passes it to</span></span><br><span class="line"><span class="comment">// the context. The client should be aware of the differences</span></span><br><span class="line"><span class="comment">// between strategies in order to make the right choice.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleApplication</span> is</span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">        Create context object.</span><br><span class="line"></span><br><span class="line">        Read first number.</span><br><span class="line">        Read last number.</span><br><span class="line">        Read the desired action from user input.</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action == addition) then</span><br><span class="line">            context.setStrategy(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyAdd</span>())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action == subtraction) then</span><br><span class="line">            context.setStrategy(<span class="keyword">new</span> <span class="title class_">ConcreteStrategySubtract</span>())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action == multiplication) then</span><br><span class="line">            context.setStrategy(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyMultiply</span>())</span><br><span class="line"></span><br><span class="line">        result = context.executeStrategy(First number, Second number)</span><br><span class="line"></span><br><span class="line">        Print result.</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li>如果要在对象中使用算法的不同变体，并且能够在运行时从一种算法切换到另一种算法，请使用 Strategy 模式。</li>
<li>策略模式允许您通过将对象与不同的子对象相关联来间接更改对象在运行时的行为，这些子对象可以以不同的方式执行特定的子任务。</li>
<li>当您有许多相似的类时，请使用策略，这些类仅在执行某些行为的方式上有所不同。</li>
<li>Strategy 模式允许您将不同的行为提取到单独的类层次结构中，并将原始类合并为一个类，从而减少重复代码。</li>
<li>使用该模式将类的业务逻辑与算法的实现细节隔离开来，这些算法在该逻辑的上下文中可能不那么重要。</li>
<li>策略模式允许您将各种算法的代码、内部数据和依赖项与代码的其余部分隔离开来。各种客户端都获得了一个简单的接口来执行算法并在运行时切换它们。</li>
<li>当您的类具有在同一算法的不同变体之间切换的大量条件语句时，请使用该模式。</li>
<li>Strategy 模式允许您通过将所有算法提取到单独的类中来消除这种条件，所有这些类都实现相同的接口。原始对象将执行委托给其中一个对象，而不是实现算法的所有变体。</li>
</ul>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li>在上下文类中，标识容易频繁更改的算法。它也可能是一个大规模条件，在运行时选择并执行同一算法的变体。</li>
<li>声明算法所有变体通用的策略接口。</li>
<li>一个接一个地，将所有算法提取到它们自己的类中。他们都应该实现策略接口。</li>
<li>在上下文类中，添加一个用于存储对策略对象的引用的字段。提供用于替换该字段值的 setter。上下文应仅通过策略接口与策略对象一起使用。上下文可以定义一个接口，让策略访问其数据。</li>
<li>上下文的客户端必须将其与合适的策略相关联，该策略与他们期望上下文执行其主要工作的方式相匹配。</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>优点√</th>
<th>缺点×</th>
</tr>
</thead>
<tbody><tr>
<td>您可以在运行时交换对象内部使用的算法。</td>
<td>如果你只有几种算法，而且它们很少改变，那么就没有真正的理由用模式附带的新类和接口来使程序过于复杂。</td>
</tr>
<tr>
<td>您可以将算法的实现详细信息与使用它的代码隔离开来。</td>
<td>客户必须意识到策略之间的差异，以便能够选择合适的策略。</td>
</tr>
<tr>
<td>您可以将继承替换为组合。</td>
<td>许多现代编程语言都支持函数类型，允许您在一组匿名函数中实现不同版本的算法。然后，您可以像使用策略对象一样使用这些函数，但不会因额外的类和接口而使代码膨胀。</td>
</tr>
<tr>
<td>开&#x2F;闭原则。您可以引入新策略，而无需更改上下文。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>桥接、状态、策略（在某种程度上还有适配器）具有非常相似的结构。事实上，所有这些模式都是基于构图的，而构图是将工作委托给其他对象。但是，它们都解决了不同的问题。模式不仅仅是以特定方式构建代码的秘诀。它还可以向其他开发人员传达该模式解决的问题。</p>
</li>
<li><p>“命令”和“策略”可能看起来很相似，因为您可以使用它们来参数化具有某些操作的对象。但是，他们的意图截然不同。</p>
<ul>
<li>您可以使用 Command 将任何操作转换为对象。操作的参数将成为该对象的字段。转换允许您延迟操作的执行、排队、存储命令的历史记录、将命令发送到远程服务等。</li>
<li>另一方面，Strategy 通常描述执行相同操作的不同方法，允许您在单个上下文类中交换这些算法。</li>
</ul>
</li>
<li><p>Decorator 可让您更改对象的皮肤，而 Strategy 可让您更改内脏。</p>
</li>
<li><p>模板方法基于继承：它允许您通过在子类中扩展算法的各个部分来更改这些部分。策略基于组合：您可以通过为对象提供与该行为相对应的不同策略来改变对象的部分行为。Template Method 在类级别工作，因此它是静态的。策略在对象级别工作，允许您在运行时切换行为。</p>
</li>
<li><p>状态可以看作是战略的延伸。这两种模式都基于组合：它们通过将一些工作委派给帮助对象来改变上下文的行为。策略使这些对象完全独立，彼此不相知。但是，State 不会限制具体状态之间的依赖关系，而是允许它们随意更改上下文的状态。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h1 id="trategy-in-Python"><a href="#trategy-in-Python" class="headerlink" title="trategy in Python"></a><strong>trategy</strong> in Python</h1><p>策略是一种行为设计模式，它将一组行为转换为对象，并使它们在原始上下文对象中可互换。</p>
<p>原始对象（称为 context）包含对策略对象的引用。将执行行为的上下文委托给链接的策略对象。为了改变上下文执行其工作的方式，其他对象可能会用另一个对象替换当前链接的策略对象。</p>
<p>使用示例：Strategy 模式在 Python 代码中很常见。它通常用于各种框架中，为用户提供一种在不扩展类的情况下更改类行为的方法。</p>
<p>标识：策略模式可以通过允许嵌套对象执行实际工作的方法以及允许将该对象替换为其他对象的 setter 来识别。</p>
<h4 id="main-py：概念示例"><a href="#main-py：概念示例" class="headerlink" title="main.py：概念示例"></a>main.py：概念示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Context defines the interface of interest to clients.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, strategy: Strategy</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Usually, the Context accepts a strategy through the constructor, but</span></span><br><span class="line"><span class="string">        also provides a setter to change it at runtime.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self._strategy = strategy</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strategy</span>(<span class="params">self</span>) -&gt; Strategy:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Context maintains a reference to one of the Strategy objects. The</span></span><br><span class="line"><span class="string">        Context does not know the concrete class of a strategy. It should work</span></span><br><span class="line"><span class="string">        with all strategies via the Strategy interface.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self._strategy</span><br><span class="line"></span><br><span class="line"><span class="meta">    @strategy.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strategy</span>(<span class="params">self, strategy: Strategy</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Usually, the Context allows replacing a Strategy object at runtime.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self._strategy = strategy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_some_business_logic</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Context delegates some work to the Strategy object instead of</span></span><br><span class="line"><span class="string">        implementing multiple versions of the algorithm on its own.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Context: Sorting data using the strategy (not sure how it&#x27;ll do it)&quot;</span>)</span><br><span class="line">        result = self._strategy.do_algorithm([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>.join(result))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Strategy interface declares operations common to all supported versions</span></span><br><span class="line"><span class="string">    of some algorithm.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The Context uses this interface to call the algorithm defined by Concrete</span></span><br><span class="line"><span class="string">    Strategies.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_algorithm</span>(<span class="params">self, data: <span class="type">List</span></span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Strategies implement the algorithm while following the base Strategy</span></span><br><span class="line"><span class="string">interface. The interface makes them interchangeable in the Context.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span>(<span class="title class_ inherited__">Strategy</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_algorithm</span>(<span class="params">self, data: <span class="type">List</span></span>) -&gt; <span class="type">List</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span>(<span class="title class_ inherited__">Strategy</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_algorithm</span>(<span class="params">self, data: <span class="type">List</span></span>) -&gt; <span class="type">List</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reversed</span>(<span class="built_in">sorted</span>(data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code picks a concrete strategy and passes it to the context.</span></span><br><span class="line">    <span class="comment"># The client should be aware of the differences between strategies in order</span></span><br><span class="line">    <span class="comment"># to make the right choice.</span></span><br><span class="line"></span><br><span class="line">    context = Context(ConcreteStrategyA())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Strategy is set to normal sorting.&quot;</span>)</span><br><span class="line">    context.do_some_business_logic()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Strategy is set to reverse sorting.&quot;</span>)</span><br><span class="line">    context.strategy = ConcreteStrategyB()</span><br><span class="line">    context.do_some_business_logic()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a><strong>Output.txt:</strong> Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: Strategy is set to normal sorting.</span><br><span class="line">Context: Sorting data using the strategy (not sure how it&#x27;ll do it)</span><br><span class="line">a,b,c,d,e</span><br><span class="line"></span><br><span class="line">Client: Strategy is set to reverse sorting.</span><br><span class="line">Context: Sorting data using the strategy (not sure how it&#x27;ll do it)</span><br><span class="line">e,d,c,b,a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Strategy-in-Rust"><a href="#Strategy-in-Rust" class="headerlink" title="Strategy in Rust"></a><strong>Strategy</strong> in Rust</h1><p>策略是一种行为设计模式，它将一组行为转换为对象，并使它们在原始上下文对象中可互换。</p>
<p>原始对象（称为 context）包含对策略对象的引用。将执行行为的上下文委托给链接的策略对象。为了改变上下文执行其工作的方式，其他对象可能会用另一个对象替换当前链接的策略对象。</p>
<h2 id="Conceptual-Example-概念示例"><a href="#Conceptual-Example-概念示例" class="headerlink" title="Conceptual Example 概念示例"></a>Conceptual Example 概念示例</h2><p>通过特征的概念策略示例。</p>
<h4 id="conceptual-rs"><a href="#conceptual-rs" class="headerlink" title="conceptual.rs"></a><strong>conceptual.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Defines an injectable strategy for building routes.</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">RouteStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build_route</span>(&amp;<span class="keyword">self</span>, from: &amp;<span class="type">str</span>, to: &amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WalkingStrategy</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">RouteStrategy</span> <span class="keyword">for</span> <span class="title class_">WalkingStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build_route</span>(&amp;<span class="keyword">self</span>, from: &amp;<span class="type">str</span>, to: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Walking route from &#123;&#125; to &#123;&#125;: 4 km, 30 min&quot;</span>, from, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PublicTransportStrategy</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">RouteStrategy</span> <span class="keyword">for</span> <span class="title class_">PublicTransportStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build_route</span>(&amp;<span class="keyword">self</span>, from: &amp;<span class="type">str</span>, to: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Public transport route from &#123;&#125; to &#123;&#125;: 3 km, 5 min&quot;</span>,</span><br><span class="line">            from, to</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Navigator</span>&lt;T: RouteStrategy&gt; &#123;</span><br><span class="line">    route_strategy: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: RouteStrategy&gt; Navigator&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(route_strategy: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; route_strategy &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">route</span>(&amp;<span class="keyword">self</span>, from: &amp;<span class="type">str</span>, to: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.route_strategy.<span class="title function_ invoke__">build_route</span>(from, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">navigator</span> = Navigator::<span class="title function_ invoke__">new</span>(WalkingStrategy);</span><br><span class="line">    navigator.<span class="title function_ invoke__">route</span>(<span class="string">&quot;Home&quot;</span>, <span class="string">&quot;Club&quot;</span>);</span><br><span class="line">    navigator.<span class="title function_ invoke__">route</span>(<span class="string">&quot;Club&quot;</span>, <span class="string">&quot;Work&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">navigator</span> = Navigator::<span class="title function_ invoke__">new</span>(PublicTransportStrategy);</span><br><span class="line">    navigator.<span class="title function_ invoke__">route</span>(<span class="string">&quot;Home&quot;</span>, <span class="string">&quot;Club&quot;</span>);</span><br><span class="line">    navigator.<span class="title function_ invoke__">route</span>(<span class="string">&quot;Club&quot;</span>, <span class="string">&quot;Work&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Walking route from Home to Club: 4 km, 30 min</span><br><span class="line">Walking route from Club to Work: 4 km, 30 min</span><br><span class="line">Public transport route from Home to Club: 3 km, 5 min</span><br><span class="line">Public transport route from Club to Work: 3 km, 5 min</span><br></pre></td></tr></table></figure>

<h2 id="Functional-approach-功能方法"><a href="#Functional-approach-功能方法" class="headerlink" title="Functional approach 功能方法"></a>Functional approach 功能方法</h2><p>函数和闭包简化了策略实现，因为您可以将行为直接注入到对象中，而无需复杂的接口定义。</p>
<p>似乎 Strategy 在 Rust 的现代开发中经常被隐式和广泛地使用，例如，它就像迭代器一样工作：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">0i32</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|x| x.<span class="title function_ invoke__">is_positive</span>());</span><br></pre></td></tr></table></figure>

<h4 id="functional-rs"><a href="#functional-rs" class="headerlink" title="functional.rs"></a><strong>functional.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RouteStrategy</span> = <span class="title function_ invoke__">fn</span>(from: &amp;<span class="type">str</span>, to: &amp;<span class="type">str</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">walking_strategy</span>(from: &amp;<span class="type">str</span>, to: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Walking route from &#123;&#125; to &#123;&#125;: 4 km, 30 min&quot;</span>, from, to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">public_transport_strategy</span>(from: &amp;<span class="type">str</span>, to: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;Public transport route from &#123;&#125; to &#123;&#125;: 3 km, 5 min&quot;</span>,</span><br><span class="line">        from, to</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Navigator</span> &#123;</span><br><span class="line">    route_strategy: RouteStrategy,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Navigator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(route_strategy: RouteStrategy) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; route_strategy &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">route</span>(&amp;<span class="keyword">self</span>, from: &amp;<span class="type">str</span>, to: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        (<span class="keyword">self</span>.route_strategy)(from, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">navigator</span> = Navigator::<span class="title function_ invoke__">new</span>(walking_strategy);</span><br><span class="line">    navigator.<span class="title function_ invoke__">route</span>(<span class="string">&quot;Home&quot;</span>, <span class="string">&quot;Club&quot;</span>);</span><br><span class="line">    navigator.<span class="title function_ invoke__">route</span>(<span class="string">&quot;Club&quot;</span>, <span class="string">&quot;Work&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">navigator</span> = Navigator::<span class="title function_ invoke__">new</span>(public_transport_strategy);</span><br><span class="line">    navigator.<span class="title function_ invoke__">route</span>(<span class="string">&quot;Home&quot;</span>, <span class="string">&quot;Club&quot;</span>);</span><br><span class="line">    navigator.<span class="title function_ invoke__">route</span>(<span class="string">&quot;Club&quot;</span>, <span class="string">&quot;Work&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">navigator</span> = Navigator::<span class="title function_ invoke__">new</span>(|from, to| <span class="built_in">println!</span>(<span class="string">&quot;Specific route from &#123;&#125; to &#123;&#125;&quot;</span>, from, to));</span><br><span class="line">    navigator.<span class="title function_ invoke__">route</span>(<span class="string">&quot;Home&quot;</span>, <span class="string">&quot;Club&quot;</span>);</span><br><span class="line">    navigator.<span class="title function_ invoke__">route</span>(<span class="string">&quot;Club&quot;</span>, <span class="string">&quot;Work&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Output-输出-1"><a href="#Output-输出-1" class="headerlink" title="Output 输出"></a>Output 输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Walking route from Home to Club: 4 km, 30 min</span><br><span class="line">Walking route from Club to Work: 4 km, 30 min</span><br><span class="line">Public transport route from Home to Club: 3 km, 5 min</span><br><span class="line">Public transport route from Club to Work: 3 km, 5 min</span><br><span class="line">Specific route from Home to Club</span><br><span class="line">Specific route from Club to Work</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Structural Design Patterns 结构设计模式</title>
    <url>/2024/02/01/design-pattern/structural-patterns/</url>
    <content><![CDATA[<p>结构设计模式解释了如何将对象和类组装成更大的结构，同时保持这些结构的灵活性和效率。</p>
<h1 id="Adapter-适配器"><a href="#Adapter-适配器" class="headerlink" title="Adapter 适配器"></a>Adapter 适配器</h1><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/lxvFOqjS8m0DDNrs7qG9_A">
    <img src="/images/adapter-header.png"/>
    Adapter 适配器
    <a/>
</div>

<h1 id="Bridge-桥接"><a href="#Bridge-桥接" class="headerlink" title="Bridge 桥接"></a>Bridge 桥接</h1><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/dSixwlU9Ds3tzR3KmmkbTg">
    <img src="/images/bridge-header.png"/>
    Bridge 桥接
    <a/>
</div>

<h1 id="Composite-部分-整体或复合模式"><a href="#Composite-部分-整体或复合模式" class="headerlink" title="Composite 部分-整体或复合模式"></a>Composite 部分-整体或复合模式</h1><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/qtmrz-mTx_BXj_DhLHTbDw">
    <img src="/images/composite-header.png"/>
    Composite 部分-整体或复合模式
    <a/>
</div>

<h1 id="Decorator-装饰器"><a href="#Decorator-装饰器" class="headerlink" title="Decorator 装饰器"></a>Decorator 装饰器</h1><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/ztmaiAPiNUkysA4HQWevzQ">
    <img src="/images/decorator.png"/>
    Decorator 装饰器
    <a/>
</div>

<h1 id="Facade-门面（外观）模式"><a href="#Facade-门面（外观）模式" class="headerlink" title="Facade 门面（外观）模式"></a>Facade 门面（外观）模式</h1><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/-rVPbWR1AgHIwN5pG0_zsQ">
    <img src="/images/facade.png"/>
    Facade 门面（外观）模式
    <a/>
</div>

<h1 id="Flyweight-享元模式"><a href="#Flyweight-享元模式" class="headerlink" title="Flyweight 享元模式"></a>Flyweight 享元模式</h1><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/FkCGFQSyK-CxpRSXCEnyWw">
    <img src="/images/flyweight.png"/>
    Flyweight 享元模式
    <a/>
</div>

<h1 id="Proxy-代理模式"><a href="#Proxy-代理模式" class="headerlink" title="Proxy 代理模式"></a>Proxy 代理模式</h1><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/EF2x7td1p0UP_YUFCBjmxQ">
    <img src="/images/proxy.png"/>
    Proxy 代理模式
    <a/>
</div>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Template Method 模版方法模式</title>
    <url>/2024/04/21/design-pattern/template-method/</url>
    <content><![CDATA[<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p>模板方法是一种行为设计模式，它定义超类中算法的骨架，但允许子类在不改变其结构的情况下覆盖算法的特定步骤。template-method-header</p>
<div align="center"> <img src="/images/template-method-header.png"/><p style="text-align: center;"></p></div>


<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>假设您正在创建一个用于分析公司文档的数据挖掘应用程序。用户以各种格式（PDF、DOC、CSV）向应用程序提供文档，并尝试以统一格式从这些文档中提取有意义的数据。</p>
<p>该应用程序的第一个版本只能与 DOC 文件一起使用。在以下版本中，它能够支持 CSV 文件。一个月后，您“教”它从PDF文件中提取数据。</p>
<div align="center"> <img src="/images/template-method-problem.png"/><p style="text-align: center;">数据挖掘类包含大量重复代码。</p></div>


<p>在某个时候，你注意到这三个类都有很多相似的代码。虽然处理各种数据格式的代码在所有类中都完全不同，但用于数据处理和分析的代码几乎相同。摆脱代码重复，保持算法结构完好无损不是很好吗？</p>
<p>还有另一个与使用这些类的客户端代码相关的问题。它有很多条件，这些条件根据处理对象的类选择适当的操作过程。如果所有三个处理类都具有公共接口或基类，则可以在客户端代码中消除条件，并在对处理对象调用方法时使用多态性。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>模板方法模式建议将算法分解为一系列步骤，将这些步骤转换为方法，并在单个模板方法中放置对这些方法的一系列调用。这些步骤可以是 模板方法模式建议将算法分解为一系列步骤，将这些步骤转换为方法，并在单个模板方法中放置对这些方法的一系列调用。这些步骤可以是 <code>abstract</code> ，也可以具有一些默认实现。要使用该算法，客户端应该提供自己的子类，实现所有抽象步骤，并在需要时覆盖一些可选步骤（但不是模板方法本身）。 ，也可以具有一些默认实现。要使用该算法，客户端应该提供自己的子类，实现所有抽象步骤，并在需要时覆盖一些可选步骤（但不是模板方法本身）。</p>
<p>我们看看这将如何在我们的数据挖掘应用程序中发挥作用。我们可以为所有三种解析算法创建一个基类。此类定义一个模板方法，该方法由对各种文档处理步骤的一系列调用组成。</p>
<div align="center"> <img src="/images/template-method-solution.png"/><p style="text-align: center;">模板方法将算法分解为多个步骤，允许子类覆盖这些步骤，但不能覆盖实际方法。</p></div>


<p>首先，我们可以声明所有步骤 <code>abstract</code> ，迫使子类为这些方法提供自己的实现。在我们的例子中，子类已经具有所有必要的实现，因此我们唯一需要做的就是调整方法的签名以匹配超类的方法。</p>
<p>现在，让我们看看我们可以做些什么来摆脱重复的代码。对于各种数据格式，打开&#x2F;关闭文件和提取&#x2F;解析数据的代码似乎不同，因此没有必要触及这些方法。但是，其他步骤（例如分析原始数据和编写报告）的实现非常相似，因此可以将其拉到基类中，子类可以在其中共享该代码。</p>
<p>正如你所看到的，我们有两种类型的步骤：</p>
<ul>
<li>抽象步骤必须由每个子类实现</li>
<li>可选步骤已经有一些默认实现，但如果需要，仍然可以覆盖</li>
<li>还有另一种类型的步骤，称为钩子。钩子是具有空体的可选步骤。即使钩子没有被覆盖，模板方法也会起作用。通常，钩子放置在算法的关键步骤之前和之后，为子类提供算法的附加扩展点。</li>
</ul>
<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><div align="center"> <img src="/images/template-method-live-example.png"/><p style="text-align: center;">典型的建筑计划可以稍作改动，以更好地满足客户的需求。</p></div>


<p>模板方法方法可用于大规模住房建设。建造标准房屋的建筑计划可能包含几个扩展点，这些扩展点可以让潜在所有者调整最终房屋的一些细节。</p>
<p>每个建筑步骤，如奠基、框架、砌墙、安装水管和水电布线等，都可以稍作改动，使最终的房子与其他房子略有不同。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/template-method-structure.png"/><p style="text-align: center;"></p></div>


<ol>
<li>Abstract 类声明充当算法步骤的方法，以及按特定顺序调用这些方法的实际模板方法。这些步骤可以声明 Abstract 类声明充当算法步骤的方法，以及按特定顺序调用这些方法的实际模板方法。这些步骤可以声明 <code>abstract</code> ，也可以具有一些默认实现。 ，也可以具有一些默认实现。</li>
<li>具体类可以覆盖所有步骤，但不能覆盖模板方法本身。</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>在此示例中，模板方法模式为简单策略视频游戏中的人工智能的各个分支提供了一个“骨架”。</p>
<div align="center"> <img src="/images/template-method-example.png"/><p style="text-align: center;">简单视频游戏的 AI 类。</p></div>


<p>游戏中的所有种族都有几乎相同类型的单位和建筑物。因此，您可以为各种种族重复使用相同的 AI 结构，同时能够覆盖一些细节。通过这种方法，您可以覆盖兽人的 AI 使其更具攻击性，使人类更具防御性，并使怪物无法建造任何东西。向游戏添加新种族需要创建一个新的 AI 子类并覆盖基 AI 类中声明的默认方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The abstract class defines a template method that contains a</span></span><br><span class="line"><span class="comment">// skeleton of some algorithm composed of calls, usually to</span></span><br><span class="line"><span class="comment">// abstract primitive operations. Concrete subclasses implement</span></span><br><span class="line"><span class="comment">// these operations, but leave the template method itself</span></span><br><span class="line"><span class="comment">// intact.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameAI</span> is</span><br><span class="line">    <span class="comment">// The template method defines the skeleton of an algorithm.</span></span><br><span class="line">    method <span class="title function_">turn</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">collectResources</span><span class="params">()</span></span><br><span class="line">        buildStructures()</span><br><span class="line">        buildUnits()</span><br><span class="line">        attack()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some of the steps may be implemented right in a base</span></span><br><span class="line">    <span class="comment">// class.</span></span><br><span class="line">    method <span class="title function_">collectResources</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">foreach</span> <span class="params">(s in <span class="built_in">this</span>.builtStructures)</span> <span class="keyword">do</span></span><br><span class="line">            s.collect()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// And some of them may be defined as abstract.</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">buildStructures</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">buildUnits</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// A class can have several template methods.</span></span><br><span class="line">    method <span class="title function_">attack</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">enemy</span> <span class="operator">=</span> closestEnemy()</span><br><span class="line">        <span class="keyword">if</span> (enemy == <span class="literal">null</span>)</span><br><span class="line">            sendScouts(map.center)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sendWarriors(enemy.position)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">sendScouts</span><span class="params">(position)</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">sendWarriors</span><span class="params">(position)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete classes have to implement all abstract operations of</span></span><br><span class="line"><span class="comment">// the base class but they must not override the template method</span></span><br><span class="line"><span class="comment">// itself.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrcsAI</span> <span class="keyword">extends</span> <span class="title class_">GameAI</span> is</span><br><span class="line">    method <span class="title function_">buildStructures</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(there are some resources)</span> then</span><br><span class="line">            <span class="comment">// Build farms, then barracks, then stronghold.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">buildUnits</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(there are plenty of resources)</span> then</span><br><span class="line">            <span class="title function_">if</span> <span class="params">(there are no scouts)</span></span><br><span class="line">                <span class="comment">// Build peon, add it to scouts group.</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// Build grunt, add it to warriors group.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">sendScouts</span><span class="params">(position)</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(scouts.length &gt; <span class="number">0</span>)</span> then</span><br><span class="line">            <span class="comment">// Send scouts to position.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">sendWarriors</span><span class="params">(position)</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(warriors.length &gt; <span class="number">5</span>)</span> then</span><br><span class="line">            <span class="comment">// Send warriors to position.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Subclasses can also override some operations with a default</span></span><br><span class="line"><span class="comment">// implementation.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonstersAI</span> <span class="keyword">extends</span> <span class="title class_">GameAI</span> is</span><br><span class="line">    method <span class="title function_">collectResources</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Monsters don&#x27;t collect resources.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">buildStructures</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Monsters don&#x27;t build structures.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">buildUnits</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Monsters don&#x27;t build units.</span></span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><p>如果希望客户端仅扩展算法的特定步骤，而不扩展整个算法或其结构，请使用模板方法模式。</p>
<p>模板方法允许您将单体算法转换为一系列单独的步骤，这些步骤可以由子类轻松扩展，同时保持超类中定义的结构不变。</p>
<p>当您有多个类包含几乎相同的算法但有一些细微差异时，请使用该模式。因此，当算法更改时，您可能需要修改所有类。</p>
<p>当您将此类算法转换为模板方法时，还可以将具有类似实现的步骤拉到超类中，从而消除代码重复。子类之间不同的代码可以保留在子类中。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li>分析目标算法，看看是否可以将其分解为步骤。考虑哪些步骤对所有子类都是通用的，哪些步骤将始终是唯一的。</li>
<li>创建抽象基类并声明模板方法和一组表示算法步骤的抽象方法。通过执行相应的步骤，在模板方法中概述算法的结构。请考虑创建模板方法 <code>final</code> 以防止子类重写它。</li>
<li>如果所有步骤最终都是抽象的，那也没关系。但是，某些步骤可能会受益于默认实现。子类不必实现这些方法。</li>
<li>考虑在算法的关键步骤之间添加钩子。</li>
<li>对于算法的每个变体，创建一个新的具体子类。它必须实现所有抽象步骤，但也可以覆盖一些可选步骤。</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>优点√</th>
<th>缺点×</th>
</tr>
</thead>
<tbody><tr>
<td>您可以让客户端仅覆盖大型算法的某些部分，从而减少它们受到算法其他部分发生更改的影响。</td>
<td>某些客户端可能会受到算法提供的框架的限制。</td>
</tr>
<tr>
<td>您可以将重复的代码拉取到超类中。</td>
<td>通过子类抑制默认步骤实现，可能会违反 Liskov 替换原则。</td>
</tr>
<tr>
<td></td>
<td>模板方法的步骤越多，维护起来就越难。</td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns"><a href="#Relations-with-Other-Patterns" class="headerlink" title="Relations with Other Patterns"></a>Relations with Other Patterns</h2><p>与其他模式的关系</p>
<ul>
<li>工厂方法是模板方法的专业化。同时，工厂方法可以作为大型模板方法中的一个步骤。</li>
<li>模板方法基于继承：它允许您通过在子类中扩展算法的各个部分来更改这些部分。策略基于组合：您可以通过为对象提供与该行为相对应的不同策略来改变对象的部分行为。Template Method 在类级别工作，因此它是静态的。策略在对象级别工作，允许您在运行时切换行为。</li>
</ul>
<h1 id="Template-Method-in-Python"><a href="#Template-Method-in-Python" class="headerlink" title="Template Method in Python"></a><strong>Template Method</strong> in Python</h1><p>模板方法是一种行为设计模式，它允许您在基类中定义算法的骨架，并让子类在不更改整体算法结构的情况下覆盖这些步骤。</p>
<h4 id="main-py：概念示例"><a href="#main-py：概念示例" class="headerlink" title="main.py：概念示例"></a>main.py：概念示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Abstract Class defines a template method that contains a skeleton of</span></span><br><span class="line"><span class="string">    some algorithm, composed of calls to (usually) abstract primitive</span></span><br><span class="line"><span class="string">    operations.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Concrete subclasses should implement these operations, but leave the</span></span><br><span class="line"><span class="string">    template method itself intact.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">template_method</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The template method defines the skeleton of an algorithm.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self.base_operation1()</span><br><span class="line">        self.required_operations1()</span><br><span class="line">        self.base_operation2()</span><br><span class="line">        self.hook1()</span><br><span class="line">        self.required_operations2()</span><br><span class="line">        self.base_operation3()</span><br><span class="line">        self.hook2()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># These operations already have implementations.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">base_operation1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;AbstractClass says: I am doing the bulk of the work&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">base_operation2</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;AbstractClass says: But I let subclasses override some operations&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">base_operation3</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;AbstractClass says: But I am doing the bulk of the work anyway&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># These operations have to be implemented in subclasses.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">required_operations1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">required_operations2</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># These are &quot;hooks.&quot; Subclasses may override them, but it&#x27;s not mandatory</span></span><br><span class="line">    <span class="comment"># since the hooks already have default (but empty) implementation. Hooks</span></span><br><span class="line">    <span class="comment"># provide additional extension points in some crucial places of the</span></span><br><span class="line">    <span class="comment"># algorithm.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hook1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hook2</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass1</span>(<span class="title class_ inherited__">AbstractClass</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Concrete classes have to implement all abstract operations of the base</span></span><br><span class="line"><span class="string">    class. They can also override some operations with a default implementation.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">required_operations1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteClass1 says: Implemented Operation1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">required_operations2</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteClass1 says: Implemented Operation2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass2</span>(<span class="title class_ inherited__">AbstractClass</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Usually, concrete classes override only a fraction of base class&#x27;</span></span><br><span class="line"><span class="string">    operations.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">required_operations1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteClass2 says: Implemented Operation1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">required_operations2</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteClass2 says: Implemented Operation2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hook1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteClass2 says: Overridden Hook1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">abstract_class: AbstractClass</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code calls the template method to execute the algorithm. Client</span></span><br><span class="line"><span class="string">    code does not have to know the concrete class of an object it works with, as</span></span><br><span class="line"><span class="string">    long as it works with objects through the interface of their base class.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    abstract_class.template_method()</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Same client code can work with different subclasses:&quot;</span>)</span><br><span class="line">    client_code(ConcreteClass1())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Same client code can work with different subclasses:&quot;</span>)</span><br><span class="line">    client_code(ConcreteClass2())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="输出-txt：执行结果"><a href="#输出-txt：执行结果" class="headerlink" title="输出.txt：执行结果"></a>输出.txt：执行结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Same client code can work with different subclasses:</span><br><span class="line">AbstractClass says: I am doing the bulk of the work</span><br><span class="line">ConcreteClass1 says: Implemented Operation1</span><br><span class="line">AbstractClass says: But I let subclasses override some operations</span><br><span class="line">ConcreteClass1 says: Implemented Operation2</span><br><span class="line">AbstractClass says: But I am doing the bulk of the work anyway</span><br><span class="line"></span><br><span class="line">Same client code can work with different subclasses:</span><br><span class="line">AbstractClass says: I am doing the bulk of the work</span><br><span class="line">ConcreteClass2 says: Implemented Operation1</span><br><span class="line">AbstractClass says: But I let subclasses override some operations</span><br><span class="line">ConcreteClass2 says: Overridden Hook1</span><br><span class="line">ConcreteClass2 says: Implemented Operation2</span><br><span class="line">AbstractClass says: But I am doing the bulk of the work anyway</span><br></pre></td></tr></table></figure>

<h1 id="Template-Method-in-Rust"><a href="#Template-Method-in-Rust" class="headerlink" title="Template Method in Rust"></a><strong>Template Method</strong> in Rust</h1><p>模板方法是一种行为设计模式，它允许您在基类中定义算法的骨架，并让子类在不更改整体算法结构的情况下覆盖这些步骤。</p>
<h2 id="Conceptual-Example-概念示例"><a href="#Conceptual-Example-概念示例" class="headerlink" title="Conceptual Example 概念示例"></a>Conceptual Example 概念示例</h2><h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a><strong>main.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">TemplateMethod</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">template_method</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">base_operation1</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">required_operations1</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">base_operation2</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">hook1</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">required_operations2</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">base_operation3</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">hook2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">base_operation1</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;TemplateMethod says: I am doing the bulk of the work&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">base_operation2</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;TemplateMethod says: But I let subclasses override some operations&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">base_operation3</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;TemplateMethod says: But I am doing the bulk of the work anyway&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hook1</span>(&amp;<span class="keyword">self</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hook2</span>(&amp;<span class="keyword">self</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">required_operations1</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">required_operations2</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConcreteStruct1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TemplateMethod</span> <span class="keyword">for</span> <span class="title class_">ConcreteStruct1</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">required_operations1</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ConcreteStruct1 says: Implemented Operation1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">required_operations2</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ConcreteStruct1 says: Implemented Operation2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConcreteStruct2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TemplateMethod</span> <span class="keyword">for</span> <span class="title class_">ConcreteStruct2</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">required_operations1</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ConcreteStruct2 says: Implemented Operation1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">required_operations2</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ConcreteStruct2 says: Implemented Operation2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">client_code</span>(concrete: <span class="keyword">impl</span> <span class="title class_">TemplateMethod</span>) &#123;</span><br><span class="line">    concrete.<span class="title function_ invoke__">template_method</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Same client code can work with different concrete implementations:&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">client_code</span>(ConcreteStruct1);</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Same client code can work with different concrete implementations:&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">client_code</span>(ConcreteStruct2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Same client code can work with different concrete implementations:</span><br><span class="line">TemplateMethod says: I am doing the bulk of the work</span><br><span class="line">ConcreteStruct1 says: Implemented Operation1</span><br><span class="line">TemplateMethod says: But I let subclasses override some operations</span><br><span class="line">ConcreteStruct1 says: Implemented Operation2</span><br><span class="line">TemplateMethod says: But I am doing the bulk of the work anyway</span><br><span class="line"></span><br><span class="line">Same client code can work with different concrete implementations:</span><br><span class="line">TemplateMethod says: I am doing the bulk of the work</span><br><span class="line">ConcreteStruct2 says: Implemented Operation1</span><br><span class="line">TemplateMethod says: But I let subclasses override some operations</span><br><span class="line">ConcreteStruct2 says: Implemented Operation2</span><br><span class="line">TemplateMethod says: But I am doing the bulk of the work anyway</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Visitor 访问者模式</title>
    <url>/2024/04/21/design-pattern/visitor/</url>
    <content><![CDATA[<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p>Visitor 是一种行为设计模式，可用于将算法与操作算法的对象分开。</p>
<div align="center"> <img src="/images/visitor-header.png"/><p style="text-align: center;"></p></div>


<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>想象一下，您的团队开发了一个应用程序，该应用程序使用结构为一个巨大的图形的地理信息。图形的每个节点可能代表一个复杂的实体，例如城市，但也代表更精细的事物，例如工业、观光区等。如果节点所代表的真实对象之间有一条道路，则节点与其他节点相连。在后台，每个节点类型都由自己的类表示，而每个特定节点都是一个对象。</p>
<div align="center"> <img src="/images/visitor-problem1.png"/><p style="text-align: center;">将图形导出为 XML。</p></div>


<p>在某个时候，您接到一项任务，要实现将图形导出为 XML 格式。起初，这项工作似乎很简单。您计划向每个节点类添加一个导出方法，然后利用递归遍历图形的每个节点，从而执行导出方法。解决方案简单而优雅：多亏了多态性，您没有将调用导出方法的代码耦合到具体的节点类。</p>
<p>不幸的是，系统架构师拒绝允许您更改现有的节点类。他说代码已经在生产中，他不想因为更改中的潜在错误而冒着破坏它的风险。</p>
<div align="center"> <img src="/images/visitor-problem1.png"/><p style="text-align: center;">必须将 XML 导出方法添加到所有节点类中，如果任何 bug 随更改而漏掉，则存在破坏整个应用程序的风险。</p></div>


<p>此外，他质疑在节点类中包含XML导出代码是否有意义。这些类的主要工作是处理地理数据。XML 导出行为在那里看起来很陌生。</p>
<p>拒绝还有另一个原因。很有可能在实现此功能后，营销部门的某个人会要求您提供导出为不同格式的功能，或者请求其他一些奇怪的东西。这将迫使你再次改变那些珍贵而脆弱的职业。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>Visitor 模式建议您将新行为放入一个名为 visitor 的单独类中，而不是尝试将其集成到现有类中。现在，必须执行该行为的原始对象将作为参数传递给访问者的方法之一，从而为该方法提供对对象中包含的所有必要数据的访问。</p>
<p>现在，如果该行为可以对不同类的对象执行呢？例如，在我们的 XML 导出示例中，实际实现在各种节点类之间可能会略有不同。因此，访问者类可以定义的不是一个方法，而是一组方法，每个方法都可以采用不同类型的参数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExportVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> is</span><br><span class="line">    method <span class="title function_">doForCity</span><span class="params">(City c)</span> &#123; ... &#125;</span><br><span class="line">    method <span class="title function_">doForIndustry</span><span class="params">(Industry f)</span> &#123; ... &#125;</span><br><span class="line">    method <span class="title function_">doForSightSeeing</span><span class="params">(SightSeeing ss)</span> &#123; ... &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>但是，我们究竟该如何称呼这些方法，尤其是在处理整个图形时呢？这些方法具有不同的特征，因此我们不能使用多态性。要选择能够处理给定对象的适当访问者方法，我们需要检查其类。这听起来不像一场噩梦吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">foreach (Node node in graph)</span><br><span class="line">    <span class="keyword">if</span> (node <span class="keyword">instanceof</span> City)</span><br><span class="line">        exportVisitor.doForCity((City) node)</span><br><span class="line">    <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Industry)</span><br><span class="line">        exportVisitor.doForIndustry((Industry) node)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会问，我们为什么不使用方法重载呢？这时，您为所有方法指定相同的名称，即使它们支持不同的参数集。不幸的是，即使假设我们的编程语言完全支持它（就像 Java 和 C# 一样），它也不会帮助我们。由于节点对象的确切类事先未知，因此重载机制将无法确定要执行的正确方法。默认为采用基 <code>Node</code> 类对象的方法。</p>
<p>但是，Visitor 模式解决了这个问题。它使用一种称为 Double Dispatch 的技术，它有助于在没有繁琐条件的情况下对对象执行正确的方法。与其让客户端选择要调用的方法的正确版本，不如将此选择委托给作为参数传递给访问者的对象？由于对象知道自己的类，因此它们将能够不那么笨拙地对访问者选择适当的方法。他们“接受”访客并告诉它应该执行哪种访问方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client code</span></span><br><span class="line">foreach (Node node in graph)</span><br><span class="line">    node.accept(exportVisitor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// City</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">City</span> is</span><br><span class="line">    method <span class="title function_">accept</span><span class="params">(Visitor v)</span> is</span><br><span class="line">        v.doForCity(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Industry</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Industry</span> is</span><br><span class="line">    method <span class="title function_">accept</span><span class="params">(Visitor v)</span> is</span><br><span class="line">        v.doForIndustry(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>我承认。毕竟，我们必须更改节点类。但至少这个变化是微不足道的，它允许我们在不再次更改代码的情况下添加进一步的行为。</p>
<p>现在，如果我们为所有访问者提取一个通用界面，则所有现有节点都可以与您引入应用程序的任何访问者一起工作。如果你发现自己引入了一个与节点相关的新行为，你所要做的就是实现一个新的访客类。</p>
<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><div align="center"> <img src="/images/visitor-comic1.png"/><p style="text-align: center;">一个好的保险代理人随时准备为各种类型的组织提供不同的政策。</p></div>


<p>想象一下，一位经验丰富的保险代理人渴望获得新客户。他可以走访附近的每栋建筑，试图向他遇到的每个人推销保险。根据占用建筑物的组织类型，他可以提供专门的保险单：</p>
<ul>
<li>如果是住宅楼，他就卖医疗保险。</li>
<li>如果是银行，他卖盗窃保险。</li>
<li>如果是咖啡店，他卖火灾和洪水保险。</li>
</ul>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/visitor-structure.png"/><p style="text-align: center;"></p></div>


<ol>
<li>Visitor 接口声明了一组访问方法，这些方法可以将对象结构的具体元素作为参数。如果程序是用支持重载的语言编写的，则这些方法可能具有相同的名称，但其参数的类型必须不同。</li>
<li>每个 Concrete Visitor 都实现了相同行为的多个版本，这些版本针对不同的 Concrete 元素类进行了定制。</li>
<li>Element 接口声明了一种“接受”访问者的方法。此方法应使用访问器接口的类型声明一个参数。</li>
<li>每个混凝土元素都必须实现验收方法。此方法的目的是将调用重定向到与当前元素类对应的正确访问者方法。请注意，即使基元素类实现了此方法，所有子类仍必须在其自己的类中重写此方法，并在访问器对象上调用相应的方法。</li>
<li>客户端通常表示集合或其他一些复杂对象（例如，复合树）。通常，客户端并不知道所有具体元素类，因为它们通过一些抽象接口处理该集合中的对象。</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>在此示例中，Visitor 模式向几何形状的类层次结构添加了 XML 导出支持。</p>
<div align="center"> <img src="/images/visitor-example1.png"/><p style="text-align: center;">通过访问者对象将各种类型的对象导出为 XML 格式。</p></div>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The element interface declares an `accept` method that takes</span></span><br><span class="line"><span class="comment">// the base visitor interface as an argument.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> is</span><br><span class="line">    method <span class="title function_">move</span><span class="params">(x, y)</span></span><br><span class="line">    method <span class="title function_">draw</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">accept</span><span class="params">(v: Visitor)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Each concrete element class must implement the `accept`</span></span><br><span class="line"><span class="comment">// method in such a way that it calls the visitor&#x27;s method that</span></span><br><span class="line"><span class="comment">// corresponds to the element&#x27;s class.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dot</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note that we&#x27;re calling `visitDot`, which matches the</span></span><br><span class="line">    <span class="comment">// current class name. This way we let the visitor know the</span></span><br><span class="line">    <span class="comment">// class of the element it works with.</span></span><br><span class="line">    method <span class="title function_">accept</span><span class="params">(v: Visitor)</span> is</span><br><span class="line">        v.visitDot(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    method <span class="title function_">accept</span><span class="params">(v: Visitor)</span> is</span><br><span class="line">        v.visitCircle(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    method <span class="title function_">accept</span><span class="params">(v: Visitor)</span> is</span><br><span class="line">        v.visitRectangle(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompoundShape</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    method <span class="title function_">accept</span><span class="params">(v: Visitor)</span> is</span><br><span class="line">        v.visitCompoundShape(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The Visitor interface declares a set of visiting methods that</span></span><br><span class="line"><span class="comment">// correspond to element classes. The signature of a visiting</span></span><br><span class="line"><span class="comment">// method lets the visitor identify the exact class of the</span></span><br><span class="line"><span class="comment">// element that it&#x27;s dealing with.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Visitor</span> is</span><br><span class="line">    method <span class="title function_">visitDot</span><span class="params">(d: Dot)</span></span><br><span class="line">    method <span class="title function_">visitCircle</span><span class="params">(c: Circle)</span></span><br><span class="line">    method <span class="title function_">visitRectangle</span><span class="params">(r: Rectangle)</span></span><br><span class="line">    method <span class="title function_">visitCompoundShape</span><span class="params">(cs: CompoundShape)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete visitors implement several versions of the same</span></span><br><span class="line"><span class="comment">// algorithm, which can work with all concrete element classes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You can experience the biggest benefit of the Visitor pattern</span></span><br><span class="line"><span class="comment">// when using it with a complex object structure such as a</span></span><br><span class="line"><span class="comment">// Composite tree. In this case, it might be helpful to store</span></span><br><span class="line"><span class="comment">// some intermediate state of the algorithm while executing the</span></span><br><span class="line"><span class="comment">// visitor&#x27;s methods over various objects of the structure.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XMLExportVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> is</span><br><span class="line">    method <span class="title function_">visitDot</span><span class="params">(d: Dot)</span> is</span><br><span class="line">        <span class="comment">// Export the dot&#x27;s ID and center coordinates.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">visitCircle</span><span class="params">(c: Circle)</span> is</span><br><span class="line">        <span class="comment">// Export the circle&#x27;s ID, center coordinates and</span></span><br><span class="line">        <span class="comment">// radius.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">visitRectangle</span><span class="params">(r: Rectangle)</span> is</span><br><span class="line">        <span class="comment">// Export the rectangle&#x27;s ID, left-top coordinates,</span></span><br><span class="line">        <span class="comment">// width and height.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">visitCompoundShape</span><span class="params">(cs: CompoundShape)</span> is</span><br><span class="line">        <span class="comment">// Export the shape&#x27;s ID as well as the list of its</span></span><br><span class="line">        <span class="comment">// children&#x27;s IDs.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The client code can run visitor operations over any set of</span></span><br><span class="line"><span class="comment">// elements without figuring out their concrete classes. The</span></span><br><span class="line"><span class="comment">// accept operation directs a call to the appropriate operation</span></span><br><span class="line"><span class="comment">// in the visitor object.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    field allShapes: array of Shapes</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">export</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">exportVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLExportVisitor</span>()</span><br><span class="line"></span><br><span class="line">        foreach (shape in allShapes) <span class="keyword">do</span></span><br><span class="line">            shape.accept(exportVisitor)</span><br></pre></td></tr></table></figure>

<p>如果您想知道为什么我们需要此示例中的方法 如果您想知道为什么我们需要此示例中的方法 <code>accept</code> ，我的文章 Visitor and Double Dispatch 详细解决了这个问题。 ，我的文章 Visitor and Double Dispatch 详细解决了这个问题。</p>
<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li>当需要对复杂对象结构(例如，对象树)的所有元素执行操作时，可以使用Visitor。</li>
<li>Visitor 模式允许您通过让 Visitor 对象实现同一操作的多个变体（对应于所有目标类）对一组具有不同类的对象执行操作。</li>
<li>使用 Visitor 清理辅助行为的业务逻辑。</li>
<li>该模式允许您通过将所有其他行为提取到一组访客类中，使应用的主要类更专注于其主要工作。</li>
<li>当行为仅在类层次结构的某些类中有意义，而在其他类中没有意义时，请使用该模式。</li>
<li>您可以将此行为提取到单独的访问者类中，并仅实现那些接受相关类对象的访问方法，其余部分为空。</li>
</ul>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>使用一组“访问”方法声明访问者接口，每个程序中存在的每个具体元素类一个。</p>
</li>
<li><p>声明元素接口。如果要使用现有的元素类层次结构，请将抽象的“acceptance”方法添加到层次结构的基类中。此方法应接受访问者对象作为参数。</p>
</li>
<li><p>在所有具体图元类中实现验收方法。这些方法必须简单地将调用重定向到与当前元素的类匹配的传入访问对象上的访问方法。</p>
</li>
<li><p>元素类应仅通过访客界面与访客一起使用。但是，访问者必须了解所有具体元素类，这些类被引用为访问方法的参数类型。</p>
</li>
<li><p>对于无法在元素层次结构中实现的每个行为，请创建一个新的具体访问者类并实现所有访问方法。</p>
<p>您可能会遇到这样的情况：访问者需要访问元素类的某些专用成员。在这种情况下，您可以公开这些字段或方法，从而违反元素的封装，或者将访问者类嵌套在元素类中。只有当你有幸使用支持嵌套类的编程语言时，后者才有可能。</p>
</li>
<li><p>客户端必须创建访问者对象，并通过“接受”方法将它们传递到元素中。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>优点√</th>
<th>缺点×</th>
</tr>
</thead>
<tbody><tr>
<td>开&#x2F;闭原则。您可以引入一种新行为，该行为可以处理不同类的对象，而无需更改这些类。</td>
<td>每次将类添加到元素层次结构中或从元素层次结构中删除类时，都需要更新所有访问者。</td>
</tr>
<tr>
<td>单一责任原则。您可以将同一行为的多个版本移动到同一类中。</td>
<td>访问者可能缺乏对他们应该使用的元素的私有字段和方法的必要访问权限。</td>
</tr>
<tr>
<td>访客对象在处理各种对象时可以积累一些有用的信息。当您想要遍历一些复杂的对象结构（如对象树）并将访问者应用于此结构的每个对象时，这可能很方便。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li>您可以将 Visitor 视为 Command 模式的强大版本。它的对象可以对不同类的各种对象执行操作。</li>
<li>您可以使用 Visitor 对整个复合树执行操作。</li>
<li>您可以将 Visitor 与 Iterator 一起使用来遍历复杂的数据结构，并对其元素执行一些操作，即使它们都具有不同的类。</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h1 id="Visitor-in-Python"><a href="#Visitor-in-Python" class="headerlink" title="Visitor in Python"></a><strong>Visitor</strong> in Python</h1><p>Visitor 是一种行为设计模式，允许在不更改任何现有代码的情况下向现有类层次结构添加新行为。</p>
<h4 id="main-py：概念示例"><a href="#main-py：概念示例" class="headerlink" title="main.py：概念示例"></a>main.py：概念示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Component interface declares an `accept` method that should take the</span></span><br><span class="line"><span class="string">    base visitor interface as an argument.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accept</span>(<span class="params">self, visitor: Visitor</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponentA</span>(<span class="title class_ inherited__">Component</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Each Concrete Component must implement the `accept` method in such a way</span></span><br><span class="line"><span class="string">    that it calls the visitor&#x27;s method corresponding to the component&#x27;s class.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accept</span>(<span class="params">self, visitor: Visitor</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Note that we&#x27;re calling `visitConcreteComponentA`, which matches the</span></span><br><span class="line"><span class="string">        current class name. This way we let the visitor know the class of the</span></span><br><span class="line"><span class="string">        component it works with.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        visitor.visit_concrete_component_a(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exclusive_method_of_concrete_component_a</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Concrete Components may have special methods that don&#x27;t exist in their</span></span><br><span class="line"><span class="string">        base class or interface. The Visitor is still able to use these methods</span></span><br><span class="line"><span class="string">        since it&#x27;s aware of the component&#x27;s concrete class.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponentB</span>(<span class="title class_ inherited__">Component</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Same here: visitConcreteComponentB =&gt; ConcreteComponentB</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accept</span>(<span class="params">self, visitor: Visitor</span>):</span><br><span class="line">        visitor.visit_concrete_component_b(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">special_method_of_concrete_component_b</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Visitor Interface declares a set of visiting methods that correspond to</span></span><br><span class="line"><span class="string">    component classes. The signature of a visiting method allows the visitor to</span></span><br><span class="line"><span class="string">    identify the exact class of the component that it&#x27;s dealing with.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visit_concrete_component_a</span>(<span class="params">self, element: ConcreteComponentA</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visit_concrete_component_b</span>(<span class="params">self, element: ConcreteComponentB</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Visitors implement several versions of the same algorithm, which can</span></span><br><span class="line"><span class="string">work with all concrete component classes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You can experience the biggest benefit of the Visitor pattern when using it with</span></span><br><span class="line"><span class="string">a complex object structure, such as a Composite tree. In this case, it might be</span></span><br><span class="line"><span class="string">helpful to store some intermediate state of the algorithm while executing</span></span><br><span class="line"><span class="string">visitor&#x27;s methods over various objects of the structure.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor1</span>(<span class="title class_ inherited__">Visitor</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visit_concrete_component_a</span>(<span class="params">self, element</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.exclusive_method_of_concrete_component_a()&#125;</span> + ConcreteVisitor1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visit_concrete_component_b</span>(<span class="params">self, element</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.special_method_of_concrete_component_b()&#125;</span> + ConcreteVisitor1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor2</span>(<span class="title class_ inherited__">Visitor</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visit_concrete_component_a</span>(<span class="params">self, element</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.exclusive_method_of_concrete_component_a()&#125;</span> + ConcreteVisitor2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visit_concrete_component_b</span>(<span class="params">self, element</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.special_method_of_concrete_component_b()&#125;</span> + ConcreteVisitor2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">components: <span class="type">List</span>[Component], visitor: Visitor</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code can run visitor operations over any set of elements without</span></span><br><span class="line"><span class="string">    figuring out their concrete classes. The accept operation directs a call to</span></span><br><span class="line"><span class="string">    the appropriate operation in the visitor object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> component <span class="keyword">in</span> components:</span><br><span class="line">        component.accept(visitor)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    components = [ConcreteComponentA(), ConcreteComponentB()]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The client code works with all visitors via the base Visitor interface:&quot;</span>)</span><br><span class="line">    visitor1 = ConcreteVisitor1()</span><br><span class="line">    client_code(components, visitor1)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It allows the same client code to work with different types of visitors:&quot;</span>)</span><br><span class="line">    visitor2 = ConcreteVisitor2()</span><br><span class="line">    client_code(components, visitor2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="输出-txt：执行结果"><a href="#输出-txt：执行结果" class="headerlink" title="输出.txt：执行结果"></a>输出.txt：执行结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The client code works with all visitors via the base Visitor interface:</span><br><span class="line">A + ConcreteVisitor1</span><br><span class="line">B + ConcreteVisitor1</span><br><span class="line">It allows the same client code to work with different types of visitors:</span><br><span class="line">A + ConcreteVisitor2</span><br><span class="line">B + ConcreteVisitor2</span><br></pre></td></tr></table></figure>

<h1 id="Visitor-in-Rust"><a href="#Visitor-in-Rust" class="headerlink" title="Visitor in Rust"></a><strong>Visitor</strong> in Rust</h1><p>Visitor 是一种行为设计模式，允许在不更改任何现有代码的情况下向现有类层次结构添加新行为。</p>
<h2 id="Deserialization-反序列化"><a href="#Deserialization-反序列化" class="headerlink" title="Deserialization 反序列化"></a>Deserialization 反序列化</h2><ol>
<li>Visitor 模式的一个真实示例是 serde 序列化框架及其反序列化模型（请参阅 Serde 数据模型）。</li>
<li><code>Visitor</code> 传递给 a  传递给 a  传递给 a <code>Deserializer</code> （根据 Visitor 模式的“元素”），它接受并驱动 以  （根据 Visitor 模式的“元素”），它接受并驱动 以  （根据 Visitor 模式的“元素”），它接受并驱动 以 <code>Visitor</code> 构造所需的类型。 构造所需的类型。</li>
</ol>
<p>让我们在示例中重现此反序列化模型。</p>
<h4 id="visitor-rs"><a href="#visitor-rs" class="headerlink" title="visitor.rs"></a><strong>visitor.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;TwoValuesArray, TwoValuesStruct&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Visitor can visit one type, do conversions, and output another type.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// It&#x27;s not like all visitors must return a new type, it&#x27;s just an example</span></span><br><span class="line"><span class="comment">/// that demonstrates the technique.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Visits a vector of integers and outputs a desired type.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">visit_vec</span>(&amp;<span class="keyword">self</span>, v: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Visitor implementation for a struct of two values.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Visitor</span> <span class="keyword">for</span> <span class="title class_">TwoValuesStruct</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Value</span> = TwoValuesStruct;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">visit_vec</span>(&amp;<span class="keyword">self</span>, v: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Value &#123;</span><br><span class="line">        TwoValuesStruct &#123; a: v[<span class="number">0</span>], b: v[<span class="number">1</span>] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Visitor implementation for a struct of values array.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Visitor</span> <span class="keyword">for</span> <span class="title class_">TwoValuesArray</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Value</span> = TwoValuesArray;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">visit_vec</span>(&amp;<span class="keyword">self</span>, v: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Value &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ab</span> = [<span class="number">0i32</span>; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        ab[<span class="number">0</span>] = v[<span class="number">0</span>];</span><br><span class="line">        ab[<span class="number">1</span>] = v[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        TwoValuesArray &#123; ab &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a><strong>main.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> visitor::Visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A struct of two integer values.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// It&#x27;s going to be an output of `Visitor` trait which is defined for the type</span></span><br><span class="line"><span class="comment">/// in `visitor.rs`.</span></span><br><span class="line"><span class="meta">#[derive(Default, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TwoValuesStruct</span> &#123;</span><br><span class="line">    a: <span class="type">i32</span>,</span><br><span class="line">    b: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A struct of values array.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// It&#x27;s going to be an output of `Visitor` trait which is defined for the type</span></span><br><span class="line"><span class="comment">/// in `visitor.rs`.</span></span><br><span class="line"><span class="meta">#[derive(Default, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TwoValuesArray</span> &#123;</span><br><span class="line">    ab: [<span class="type">i32</span>; <span class="number">2</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// `Deserializer` trait defines methods that can parse either a string or</span></span><br><span class="line"><span class="comment">/// a vector, it accepts a visitor which knows how to construct a new object</span></span><br><span class="line"><span class="comment">/// of a desired type (in our case, `TwoValuesArray` and `TwoValuesStruct`).</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Deserializer</span>&lt;V: Visitor&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create</span>(visitor: V) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">parse_str</span>(&amp;<span class="keyword">self</span>, input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;V::Value, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;parse_str is unimplemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">parse_vec</span>(&amp;<span class="keyword">self</span>, input: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;V::Value, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;parse_vec is unimplemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StringDeserializer</span>&lt;V: Visitor&gt; &#123;</span><br><span class="line">    visitor: V,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;V: Visitor&gt; Deserializer&lt;V&gt; <span class="keyword">for</span> <span class="title class_">StringDeserializer</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create</span>(visitor: V) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; visitor &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">parse_str</span>(&amp;<span class="keyword">self</span>, input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;V::Value, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// In this case, in order to apply a visitor, a deserializer should do</span></span><br><span class="line">        <span class="comment">// some preparation. The visitor does its stuff, but it doesn&#x27;t do everything.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">input_vec</span> = input</span><br><span class="line">            .<span class="title function_ invoke__">split_ascii_whitespace</span>()</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|x| x.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">            .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="keyword">self</span>.visitor.<span class="title function_ invoke__">visit_vec</span>(input_vec))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VecDeserializer</span>&lt;V: Visitor&gt; &#123;</span><br><span class="line">    visitor: V,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;V: Visitor&gt; Deserializer&lt;V&gt; <span class="keyword">for</span> <span class="title class_">VecDeserializer</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create</span>(visitor: V) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; visitor &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">parse_vec</span>(&amp;<span class="keyword">self</span>, input: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;V::Value, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="keyword">self</span>.visitor.<span class="title function_ invoke__">visit_vec</span>(input))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">deserializer</span> = StringDeserializer::<span class="title function_ invoke__">create</span>(TwoValuesStruct::<span class="title function_ invoke__">default</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = deserializer.<span class="title function_ invoke__">parse_str</span>(<span class="string">&quot;123 456&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">deserializer</span> = VecDeserializer::<span class="title function_ invoke__">create</span>(TwoValuesStruct::<span class="title function_ invoke__">default</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = deserializer.<span class="title function_ invoke__">parse_vec</span>(<span class="built_in">vec!</span>[<span class="number">123</span>, <span class="number">456</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">deserializer</span> = VecDeserializer::<span class="title function_ invoke__">create</span>(TwoValuesArray::<span class="title function_ invoke__">default</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = deserializer.<span class="title function_ invoke__">parse_vec</span>(<span class="built_in">vec!</span>[<span class="number">123</span>, <span class="number">456</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;Error: &#123;&#125;&quot;</span>,</span><br><span class="line">        deserializer.<span class="title function_ invoke__">parse_str</span>(<span class="string">&quot;123 456&quot;</span>).<span class="title function_ invoke__">err</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ok(TwoValuesStruct &#123; a: 123, b: 456 &#125;)</span><br><span class="line">Ok(TwoValuesStruct &#123; a: 123, b: 456 &#125;)</span><br><span class="line">Ok(TwoValuesArray &#123; ab: [123, 456] &#125;)</span><br><span class="line">Error: parse_str unimplemented</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>What&#39;s a design pattern?</title>
    <url>/2023/11/09/design-pattern/what-is-a-design-pattern/</url>
    <content><![CDATA[<h1 id="What’s-a-design-pattern"><a href="#What’s-a-design-pattern" class="headerlink" title="What’s a design pattern?"></a>What’s a design pattern?</h1><h1 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h1><p>Design patterns are typical solutions to commonly occurring problems in software design. They are like pre-made blueprints that you can customize to solve a recurring design problem in your code.</p>
<p>设计模式是软件设计中常见问题的典型解决方案。它们就像预制的蓝图，您可以自定义这些蓝图来解决代码中反复出现的设计问题。</p>
<p>You can’t just find a pattern and copy it into your program, the way you can with off-the-shelf functions or libraries. The pattern is not a specific piece of code, but a general concept for solving a particular problem. You can follow the pattern details and implement a solution that suits the realities of your own program.</p>
<p>你不能只是找到一个模式并将其复制到你的程序中，就像你使用现成的函数或库一样。模式不是一段特定的代码，而是解决特定问题的一般概念。您可以遵循模式详细信息，并实现适合您自己程序实际情况的解决方案。</p>
<p>Patterns are often confused with algorithms, because both concepts describe typical solutions to some known problems. While an algorithm always defines a clear set of actions that can achieve some goal, a pattern is a more high-level description of a solution. The code of the same pattern applied to two different programs may be different.</p>
<p>模式经常与算法混淆，因为这两个概念都描述了一些已知问题的典型解决方案。虽然算法始终定义一组可以实现某些目标的明确操作，但模式是对解决方案的更高级描述。应用于两个不同程序的相同模式的代码可能不同。</p>
<p>An analogy to an algorithm is a cooking recipe: both have clear steps to achieve a goal. On the other hand, a pattern is more like a blueprint: you can see what the result and its features are, but the exact order of implementation is up to you.</p>
<p>算法的类比是烹饪食谱：两者都有明确的步骤来实现目标。另一方面，模式更像是一个蓝图：你可以看到结果及其功能是什么，但实现的确切顺序取决于你。</p>
<h1 id="What-does-the-pattern-consist-of"><a href="#What-does-the-pattern-consist-of" class="headerlink" title="What does the pattern consist of?"></a>What does the pattern consist of?</h1><h1 id="模式由什么组成？"><a href="#模式由什么组成？" class="headerlink" title="模式由什么组成？"></a>模式由什么组成？</h1><p>Most patterns are described very formally so people can reproduce them in many contexts. Here are the sections that are usually present in a pattern description:</p>
<p>大多数模式都描述得非常正式，因此人们可以在许多情况下重现它们。以下是模式描述中通常存在的部分：</p>
<ul>
<li>Intent of the pattern briefly describes both the problem and the solution.<br>模式的意图简要描述了问题和解决方案。</li>
<li>Motivation further explains the problem and the solution the pattern makes possible.<br>动机进一步解释了问题和模式使解决方案成为可能。</li>
<li>Structure of classes shows each part of the pattern and how they are related.<br>类的结构显示了模式的每个部分以及它们之间的关系。</li>
<li>Code example in one of the popular programming languages makes it easier to grasp the idea behind the pattern.<br>使用一种流行的编程语言的代码示例可以更容易地掌握模式背后的思想。</li>
</ul>
<p>Some pattern catalogs list other useful details, such as applicability of the pattern, implementation steps and relations with other patterns.</p>
<p>一些模式目录列出了其他有用的细节，例如模式的适用性、实现步骤以及与其他模式的关系。</p>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Why should I learn patterns?</title>
    <url>/2023/11/15/design-pattern/why-should-i-learn-patterns/</url>
    <content><![CDATA[<h1 id="Why-should-I-learn-patterns"><a href="#Why-should-I-learn-patterns" class="headerlink" title="Why should I learn patterns?"></a>Why should I learn patterns?</h1><h1 id="我为什么要学习模式？"><a href="#我为什么要学习模式？" class="headerlink" title="我为什么要学习模式？"></a>我为什么要学习模式？</h1><p>The truth is that you might manage to work as a programmer for many years without knowing about a single pattern. A lot of people do just that. Even in that case, though, you might be implementing some patterns without even knowing it. So why would you spend time learning them?</p>
<p>事实是，你可能在不了解单一模式的情况下设法作为程序员工作多年。很多人就是这样做的。但是，即使在这种情况下，您也可能在不知不觉中实现某些模式。那么，你为什么要花时间学习它们呢？</p>
<ul>
<li><p>Design patterns are a toolkit of tried and tested solutions to common problems in software design. Even if you never encounter these problems, knowing patterns is still useful because it teaches you how to solve all sorts of problems using principles of object-oriented design.<br>设计模式是软件设计中常见问题的久经考验的解决方案工具包。即使你从未遇到过这些问题，了解模式仍然很有用，因为它教会了你如何使用面向对象设计的原则来解决各种问题。</p>
</li>
<li><p>Design patterns define a common language that you and your teammates can use to communicate more efficiently. You can say, “Oh, just use a Singleton for that,” and everyone will understand the idea behind your suggestion. No need to explain what a singleton is if you know the pattern and its name.<br>设计模式定义了一种通用语言，您和您的团队成员可以使用该语言来更有效地进行通信。你可以说，“哦，就用一个单例来做这件事吧”，每个人都会理解你的建议背后的想法。如果您知道模式及其名称，则无需解释什么是单例。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>山姆 奥特曼的野心</title>
    <url>/2023/11/27/sam_altman/Successful-people/</url>
    <content><![CDATA[<h1 id="Successful-people-成功人士"><a href="#Successful-people-成功人士" class="headerlink" title="Successful people 成功人士"></a>Successful people 成功人士</h1><p>“Successful people create companies.  More successful people create countries.  The most successful people create religions.”<br>“成功的人创造了公司。 更成功的人创造了国家。 最成功的人创造了宗教。</p>
<p>I heard this from Qi Lu; I’m not sure what the source is.  It got me thinking, though–the most successful founders do not set out to create companies.  They are on a mission to create something closer to a religion, and at some point it turns out that forming a company is the easiest way to do so.<br>我是从齐璐那里听说的;我不确定来源是什么。 不过，这让我开始思考，最成功的创始人不会着手创建公司。 他们的使命是创造更接近宗教的东西，在某些时候，事实证明，成立一家公司是最简单的方法。</p>
<p>In general, the big companies don’t come from pivots, and I think this is most of the reason why.<br>一般来说，大公司不是转型而来，我认为这是大部分原因。</p>
]]></content>
      <categories>
        <category>sam_altman</category>
      </categories>
  </entry>
  <entry>
    <title>Growth and Government</title>
    <url>/2023/11/24/sam_altman/growth-and-government/</url>
    <content><![CDATA[<p>这是一篇11年前于2013年3月5日,山姆 奥特曼写的一篇探讨了经济增长和政府的关系。他认为，政府可以在某些情况下促进经济增长，但在其他情况下，政府的干预可能会阻碍经济增长。</p>
<p>作者提到，政府可以通过提供教育和基础设施来促进经济增长，这些投资可以帮助提高人们的技能和生产力，并促进创新。此外，政府还可以通过减少管制和税收来鼓励企业家精神和创新。</p>
<p>然而，作者也指出了政府过度干预可能会对经济产生负面影响。他认为，政府应该避免过度管制和税收，并确保市场能够有效地运作。如果政府过度干预市场，可能会导致资源的浪费和低效率。</p>
<p>总之，作者认为政府可以在某些情况下促进经济增长，但需要谨慎地权衡利弊，并确保市场能够自由运作。</p>
<h1 id="Growth-and-Government-增长与政府"><a href="#Growth-and-Government-增长与政府" class="headerlink" title="Growth and Government 增长与政府"></a>Growth and Government 增长与政府</h1><p>TL;DR Without economic growth, democracy doesn’t work because voters occupy a zero-sum system.<br>TL;DR：没有经济增长，民主就无法运作，因为选民占据的是零和博弈体系。</p>
<p>The first piece of startup wisdom I heard was “increasing your sales will fix all problems”.   This turns out to be another way of phrasing Paul Graham’s point that growth is critical, which is true for all sorts of reasons—for example, justifying high valuations to raise large amounts of capital in the early days, attracting the best people and paying them with equity, providing a buffer to allow for some mistakes, and smoothing over internal tensions.<br>我听到的第一条创业智慧是“增加销售额将解决所有问题”。  事实证明，这是保罗·格雷厄姆（Paul Graham）的观点的另一种表达方式，即增长至关重要，出于各种原因，这都是正确的——例如，在早期证明高估值以筹集大量资金是合理的，吸引最优秀的人才并以股权支付他们，提供缓冲以允许一些错误， 并抚平内部紧张局势。</p>
<p>I believe that growth is not only critical for startups, but for most systems.   Either you’re growing, or you’re slowly dying.  Perfect equilibrium is rare.<br>我相信增长不仅对初创公司至关重要，而且对大多数系统也至关重要。  要么你在成长，要么你在慢慢死去。 完美的平衡是罕见的。</p>
<p>One system that seems to be in early death throes is the United States government.  There’s a lot of political rancor, which is particularly puzzling when one considers that in the 2012 presidential election, Obama and Romney said roughly the same thing.  Dysfunction is high—the sequester, which was supposed to be so unpalatable it would never take effect, actually (and likely temporarily) happened last Friday because the parties couldn’t agree on an alternative. There’s a lot of arguing over insignificant issues—enough, in fact, to distract us from the fact that no one has new ideas on the big issues.  We have trillion dollar deficits and no plan to reduce them, and yet the media focus on the sideshows.<br>一个似乎处于早期死亡阵痛中的系统是美国政府。 有很多政治仇恨，当人们考虑到在2012年总统大选中，奥巴马和罗姆尼说了大致相同的话时，这尤其令人费解。 功能失调很严重——本来应该非常难吃以至于永远不会生效的隔离，实际上（而且可能是暂时的）发生在上周五，因为双方无法就替代方案达成一致。关于无关紧要的问题有很多争论——事实上，这足以分散我们的注意力，让我们忽视这样一个事实，即没有人对重大问题有新的想法。 我们有数万亿美元的赤字，但没有减少赤字的计划，但媒体却把注意力集中在杂耍上。</p>
<p>A good metric for government dysfunction is inability to pass a budget, either leading to a government shutdown or a continuing resolution, which lets agencies continue to operate on the previous budget, for a theoretically short time period until we can agree on a new one.  Passing a budget is a fundamental job of Congress and the President.<br>衡量政府功能失调的一个很好的指标是无法通过预算，要么导致政府关闭，要么导致持续决议，这让各机构在理论上很短的时间内继续按照以前的预算运作，直到我们能够就新的预算达成一致。 通过预算是国会和总统的一项基本工作。</p>
<p>As far as I can tell, the US government managed to make it about 200 years without any shutdowns.  We had one in 1976, and then a bunch more in the 70s and 80s, plus 3 in the 90s, including one that lasted 21 days.  Shutdowns have fallen out of fashion, and now we just operate with continuing resolutions, and lots of them—for example, 21 for the 2001 budget alone.  The real issue with shutdowns and continuing resolutions is the same—inability to agree on a federal budget.<br>据我所知，美国政府设法做到了大约 200 年而没有任何停工。 我们在 1976 年有一个，然后在 70 年代和 80 年代又有一堆，再加上 90 年代的 3 个，包括一个持续了 21 天。 停摆已经过时了，现在我们只是在持续的决议下运作，而且很多决议——例如，仅2001年预算就有21项决议。 关门和持续决议的真正问题是一样的——无法就联邦预算达成一致。</p>
<p>Every few months, there’s brief discussion of some sort of grand bargain, but it always ends in deferral—even the deferrals get deferred!  Everyone feels screwed, and almost no one feels like the government is doing a great job.   We can’t agree on anything, and anyone that proposes doing something radically different doesn’t get elected.<br>每隔几个月，就会有关于某种大交易的简短讨论，但它总是以推迟而告终——即使是推迟也会被推迟！ 每个人都觉得自己搞砸了，几乎没有人觉得政府做得很好。  我们无法就任何事情达成一致，任何提议做一些完全不同的事情的人都不会当选。</p>
<p>But democracy (I’m using democracy to include republics and other forms of government where the people get an effectively direct say in who the leaders are) worked in the US for a long time—we were able to make real progress, pass budgets, be the world superpower, evolve as a country, etc.  Something has changed.<br>但是民主（我用民主来包括共和国和其他形式的政府，人民对谁是领导人有有效的直接发言权）在美国工作了很长时间——我们能够取得真正的进步，通过预算，成为世界超级大国，作为一个国家发展，等等。 有些事情发生了变化。</p>
<p>The US has been blessed with economic growth for a very long time, first due to natural resources and massive amounts of land in which to expand, and then due to a period of technological progress rarely matched in human history that lasted approximately until we realized just how dangerous nuclear bombs really were and got scared of new technology.  But the frontier is long over, and although technological innovation has continued at a blistering rate for computers and the Internet, it seems to have slowed down in most other industries.<br>很长一段时间以来，美国一直享有经济增长的福气，首先是由于自然资源和大量可供扩张的土地，然后是由于人类历史上罕见的技术进步时期，这种进步大约持续到我们意识到核弹到底有多危险并害怕新技术。 但这个前沿早已结束，尽管计算机和互联网的技术创新继续以极快的速度发展，但在大多数其他行业似乎已经放缓。</p>
<p>Growth may be the root cause of American exceptionalism—things consistently got better every decade largely because we were growing.  People from other countries wanted to live here, we led the world in technological innovation, social mobility was high because everyone was getting richer, and we had the resources to get involved around the world.  This is still at least partially true.<br>增长可能是美国例外论的根本原因——情况每十年就会变得更好，这主要是因为我们在成长。 来自其他国家的人们想住在这里，我们在技术创新方面引领世界，社会流动性很高，因为每个人都越来越富有，我们有资源参与世界各地的活动。 这至少部分是正确的。</p>
<p>But growth has slowed quite a bit.  Here is a graph of real GDP percentage growth in the United States from 1950 until now, with a trendline.  The trendline goes from just under 5% to just under 2%.  This is a much more significant drop than it appears, because it compounds exponentially.<br>但增长已经放缓了不少。 这是一张从1950年至今美国实际GDP增长百分比的图表，并带有趋势线。 趋势线从略低于 5% 到略低于 2%。 这是一个比看起来要大得多的下降，因为它呈指数级复合。</p>
<div align="center"> <img src="/images/samaltman-medium_Ycc26Om.png"/></div>

<p>A shocking data point about how things are going is that the median real net worth for households headed by someone under 35 dropped 68% from 1984 to 2009, to $3,662.  For those over 65, it increased 42% to $170,494 (largely due to a gain in property values).  This disparity is good evidence of a lack of real growth (and also a very unstable situation where an older generation benefits at the expense of a younger).<br>关于事情进展的一个令人震惊的数据点是，从1984年到2009年，以35岁以下的人为户主的家庭的实际净资产中位数下降了68%，至3,662美元。对于65岁以上的人，它增加了42%，达到170,494美元（主要是由于房产价值的增加）。这种差距很好地证明了缺乏实际增长（也是一种非常不稳定的情况，即老一代人以牺牲年轻人为代价而受益）。</p>
<p>Here are two more graphs, the first showing the US unemployment rate (the real numbers are perhaps worse, as people drop out of the work force) and the second showing the US interest rate, both of which make a case for slowing growth:<br>这里还有两张图表，第一张显示美国失业率（实际数字可能更糟，因为人们退出劳动力市场），第二张显示美国利率，两者都表明经济增长放缓：</p>
<div align="center"> <img src="/images/samlatman-growth-and-government-medium_pa0IzIq.png"/></div>
<div align="center"> <img src="/images/samlatman-growth-and-government-medium_tXYg4oM.png.png"/></div>
All of that said, in absolute sense I’d much rather live in the world of today than 1950—it’s tough for me to imagine living in a world without the Internet.  However, in the same way that one can feel acceleration but not velocity, people seem more sensitive to the annual rate of improvement than the absolute quality of life.  So even though people should be happier in an absolutely better world, no one wants to stand still on the hedonic treadmill.
综上所述，从绝对意义上讲，我宁愿生活在今天的世界，而不是1950年——我很难想象生活在一个没有互联网的世界里。 然而，就像人们可以感觉到加速度但不能感觉到速度一样，人们似乎对每年的改善速度比绝对的生活质量更敏感。 因此，尽管人们应该在一个绝对更好的世界中更快乐，但没有人愿意在享乐的跑步机上停滞不前。

<p>Most of us want our lives to get better every year—the hedonic treadmill is a pain that way.  In a democracy, we theoretically vote for what we believe will improve our lives the most.  In a system with economic growth, things can improve for everyone.  In a system without growth, or even one with very little growth, that’s not the case—if things improve for me, it has to come at the expense of things getting worse for you.  Without growth, we’re voting against someone else’s interest as much as we’re voting for our own.  This ends with lots of fighting and everyone feeling screwed, broken into factions, and unmotivated.  Democracy does not work well in a zero-sum world.  Autocratic political systems probably work better with growth too, but the effect of a lack of growth is likely less pronounced right up until the revolution.<br>我们大多数人都希望我们的生活每年都变得更好——享乐跑步机就是这样一种痛苦。在民主国家，从理论上讲，我们会投票选出我们认为最能改善我们生活的东西。在一个经济增长的体系中，每个人都可以改善情况。在一个没有增长的系统中，甚至在一个几乎没有增长的系统中，情况并非如此——如果事情对我来说有所改善，那一定是以你变得更糟为代价的。没有增长，我们就是在投票反对别人的利益，就像我们投票支持自己的利益一样。这以大量的战斗结束，每个人都感到被搞砸了，分裂成派系，没有动力。民主在零和博弈的世界里运作不通。专制政治制度在增长方面可能也更有效，但缺乏增长的影响可能直到革命之前才那么明显。</p>
<p>So we need to get growth back, unless we want to see this grand experiment end.  Our politicians don’t seem to have any good ideas about how to do this.  Saying “I believe in America” and hoping that proof by vigorous assertion starts working is not a strategy.<br>因此，我们需要恢复增长，除非我们想看到这个伟大的实验结束。 我们的政客们似乎对如何做到这一点没有任何好主意。 说“我相信美国”，并希望通过有力的断言来证明开始起作用，这不是一种策略。</p>
<p>I believe democracy only works in a non-zero-sum world.  We are losing jobs that we will never get back, we are borrowing money and spending it on anything but real investment, and it feels like we are managing a slow decline.  Without growth, we will head towards a special case of Malthusian dystopia where we have plenty of junk food but not enough of anything else.<br>我相信民主只有在非零和博弈的世界中才能发挥作用。 我们正在失去永远无法挽回的工作，我们正在借钱并将其花在除实际投资之外的任何事情上，感觉我们正在缓慢下降。 没有增长，我们将走向马尔萨斯反乌托邦的一个特例，在那里我们有很多垃圾食品，但其他任何东西都不够。</p>
<p>Growth is what we should be focusing on.  Growth is great—it lets us run deficits, it means the country is not zero-sum, it lets us invest in innovation and continual improvement in infrastructure, it provides a buffer for a little mismanagement, and it means tomorrow will be better than today.  Contrary to what one might expect, growth provides long-term stability.<br>增长是我们应该关注的。 增长是伟大的——它让我们能够实现赤字，这意味着国家不是零和博弈，它让我们投资于创新和基础设施的持续改善，它为一点管理不善提供了缓冲，这意味着明天会比今天更好。 与人们的预期相反，增长提供了长期的稳定性。</p>
<p>We must return to real growth, growth where we do more with less.  Borrowing money to get ninety growth cents on the dollar does not count, although that may work for a while.  We have to figure out how to fix the real problems with technological innovation—cheaper and cleaner energy, better healthcare (15.2% of GDP in 2008 and 18.2% of GDP in 2011), better transportation, food production, and defense.  GDP growth is probably the only way to fix our national debt and entitlement problems, and it’d be better to have real growth than inflationary growth.<br>我们必须回归真正的增长，即我们用更少的资源做更多的增长。 借钱以获得90美分的美元增长不算数，尽管这可能会在一段时间内奏效。 我们必须弄清楚如何通过技术创新来解决真正的问题——更便宜、更清洁的能源、更好的医疗保健（2008年占GDP的15.2%，2011年占GDP的18.2%）、更好的交通、粮食生产和国防。 GDP增长可能是解决我们国家债务和福利问题的唯一途径，实际增长比通货膨胀增长要好。</p>
<p>How to best drive economic growth is a difficult question.  It’s easy to say we should just invest in science and technology, and although that’s probably right it’s easier said than done.  The government is historically bad at picking winners to invest in, but our leaders can perhaps help reverse the cultural shift from pro-science to anti-science.  Our current culture has shifted to be anti-science; the fear of things like genetically modified food and robots is obviously in the way of growth.<br>如何最好地推动经济增长是一个难题。 说我们应该投资科学技术很容易，虽然这可能是对的，但说起来容易做起来难。 从历史上看，政府不善于挑选赢家进行投资，但我们的领导人或许可以帮助扭转从亲科学到反科学的文化转变。 我们目前的文化已经转变为反科学;对转基因食品和机器人等事物的恐惧显然阻碍了增长。</p>
<p>We should strive to make jobs in science and technology more appealing than jobs in finance (incidentally, it should be a big red flag for growth when the brightest young people start going into finance, since they aren’t actually creating any more wealth, just redistributing it).  Startups are probably the best way to do this—startups let people that develop a new technology get rich, instead of just making GE slightly richer.  So we should encourage startups in whatever way we can.<br>我们应该努力使科学和技术领域的工作比金融领域的工作更具吸引力（顺便说一句，当最聪明的年轻人开始进入金融领域时，这应该是增长的一大危险信号，因为他们实际上并没有创造更多的财富，只是重新分配财富）。 创业公司可能是做到这一点的最好方式——创业公司让开发新技术的人致富，而不仅仅是让通用电气稍微富裕一点。 因此，我们应该尽我们所能鼓励创业公司。</p>
<p>Another issue is the structure of our national budget.  We have, in startup parlance, a high burn, and most of it can’t be considered ‘investment’ but is instead ‘expense’.  Spending money on things like infrastructure improvement or new technology that are likely to generate more money in the future helps growth; spending money on the so-called entitlement programs, and parts of the military, does not.  Of course medical care and defense are important, and we have to have them—this is a tough balancing act.  In some cases, the competitive nature of the private sector may provide a better path.  Sooner or later, we are going to have an ugly conversation about our national budget—we can delay it for a long time but not forever.  The government, when it needs to spend money at all, should aim to invest.  Considering what will drive growth is a useful framework for thinking about the best use of resources.<br>另一个问题是我国国家预算的结构。 用创业公司的话来说，我们有很高的消耗，其中大部分不能被视为“投资”，而是“费用”。 把钱花在基础设施改善或新技术等可能在未来产生更多资金的事情上有助于增长;把钱花在所谓的福利计划和部分军队上，则不会。 当然，医疗和防御很重要，我们必须拥有它们——这是一个艰难的平衡行为。 在某些情况下，私营部门的竞争性质可能提供更好的途径。 迟早，我们将就我们的国家预算进行一场丑陋的对话——我们可以推迟很长时间，但不会永远拖延。 当政府需要花钱时，它应该以投资为目标。 考虑什么将推动增长是思考资源最佳利用的有用框架。</p>
<p>We should not fear innovation or globalization.  Robots are going to replace human workers in lots of factories; jobs that do require human labor are going to continue to move to the lowest-cost place.  But that’s ok, and these sorts of jobs are not what will generate economic growth for us anyway.  We should strive to be a net exporter of ideas and technologies.  For example, the US makes the best software in the world today.  It’d be disastrous for us if that stopped happening.  We should also design the best supersonic jet engines, the best nuclear power plants, and the best agricultural technology.<br>我们不应该害怕创新或全球化。 机器人将取代许多工厂的人类工人;确实需要人力的工作将继续转移到成本最低的地方。 但这没关系，无论如何，这些工作都不会为我们带来经济增长。 我们应该努力成为思想和技术的净输出国。 例如，美国制造了当今世界上最好的软件。 如果这种情况停止发生，对我们来说将是灾难性的。 我们还应该设计最好的超音速喷气发动机、最好的核电站和最好的农业技术。</p>
<p>We should understand that as a consequence of technology and an economy of ideas, the gap between the rich and the poor will likely increase from its already high-seeming levels.  There is good and bad to this, but we should be careful not to legislate against it, which will hurt growth.   Technology magnifies differences in innate ability; startups provide a framework to get compensated for it.  But GDP growth ought to improve the quality of life for everyone, and no growth will reduce quality of life for everyone except the very rich.  A safety net for legitimately poor people is a good thing, and probably becomes more necessary in a world with this sort of divergence.  Quality of life should improve for everyone; the bigger issue will likely be that people are very sensitive to relative fairness.<br>我们应该明白，由于技术和思想经济，贫富差距可能会从已经很高的水平扩大。 这有好有坏，但我们应该小心，不要立法反对它，这会损害增长。  技术放大了先天能力的差异;初创公司提供了一个框架来获得补偿。 但GDP增长应该改善每个人的生活质量，除了富人之外，任何增长都不会降低每个人的生活质量。 为合法的穷人提供安全网是一件好事，在一个存在这种分歧的世界里，它可能变得更加必要。 每个人的生活质量都应该得到改善;更大的问题可能是人们对相对公平非常敏感。</p>
<p>Pro-growth tax and legal changes are a good idea.  As a consequence of a high burn rate, we have to have high taxes.  But other countries don’t have this structural challenge, and so some other countries have lower tax rates than we do.  That makes them an appealing place to start a business or live.  By reducing our burn rate, we can reduce taxes. We don’t need to go crazy here—there are a lot of other factors that make the US a very attractive place to start a new company.  But it would certainly help.  And tax policy should reward activity that drives growth.<br>促进增长的税收和法律变化是个好主意。 由于高烧钱率，我们必须征收高税。 但其他国家没有这种结构性挑战，因此其他一些国家的税率比我们低。 这使它们成为创业或居住的有吸引力的地方。 通过降低我们的燃烧率，我们可以减少税收。我们不需要在这里发疯——还有很多其他因素使美国成为创办新公司的非常有吸引力的地方。 但这肯定会有所帮助。 税收政策应该奖励推动增长的活动。</p>
<p>There are some easy legal changes we can make to increase growth.  Immigration for entrepreneurs and skilled technology workers is an obvious one; we should want the best people creating value here, not elsewhere in the world.  Tort reform is another—legal protection is of course important, but it’s gotten so silly that it discourages innovation.<br>我们可以做出一些简单的法律改变来促进增长。 企业家和熟练技术工人的移民是显而易见的;我们应该希望最优秀的人才在这里创造价值，而不是在世界其他地方。 侵权法改革是另一回事——法律保护当然很重要，但它变得如此愚蠢，以至于阻碍了创新。</p>
<p>There is a lot more we can do.  Most of it is difficult, but growth it is the critical issue.<br>我们可以做的还有很多。 其中大部分是困难的，但增长是关键问题。</p>
<p>As a closing thought, the Airbnb founders used to draw a forward-looking growth graph that they wanted to hit.  It was their number one priority; they put it up on their desks, on their refrigerator, and on the mirror in their bathroom.  You build what you measure, and they built growth.  That seemed to work pretty well for them.<br>最后，Airbnb的创始人曾经画出他们想要达到的前瞻性增长图。 这是他们的首要任务;他们把它放在桌子上、冰箱上和浴室的镜子上。 你建立你所衡量的东西，他们建立增长。 这对他们来说似乎很有效。</p>
<p>It’s not as easy if you’re the US government.  But probably not impossible, either, and it would at least point us in the right direction.<br>如果你是美国政府，那就没那么容易了。 但可能也不是不可能，它至少会为我们指明正确的方向。</p>
]]></content>
      <categories>
        <category>sam_altman</category>
      </categories>
      <tags>
        <tag>sam altman</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 00.00:欢迎来到Rust编程语言世界！</title>
    <url>/2022/12/24/rust_docs/ch_00_00_introducation/</url>
    <content><![CDATA[<h4 id="欢迎来到Rust编程语言世界！"><a href="#欢迎来到Rust编程语言世界！" class="headerlink" title="欢迎来到Rust编程语言世界！"></a>欢迎来到Rust编程语言世界！</h4><p>不管写的好与差，挖坑先，要不然永远不会开始。</p>
<p>Hello, World!</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2022计划开始一系列关于学习Rust入门的学习笔记，主要是根据官方的文档入门学习。</p>
<p>Rust程序设计语言能帮助你编写更快，更可靠的软件。在编程语言的设计中，高层工程学和底层控制常常是冲突的。Rust挑战了这种冲突。通过平衡强大的技术能力（powerful technical capacity）和 极好的开发者体验（great developer experience）,Rust 可以控制底层的细节（比如内存的使用）但不用忍受传统同类型语言那些困扰。</p>
<p>Rust 已经在证明着自己，对于学习过编程知识的不同水平的开发者来说，如果他们开发大型协同项目都是不错的生产工具。底层的代码容易产生各种不易发现的bugs,在其他编程语言中，要发现这些bugs只能通过广泛的测试和团队中经验丰富的大佬们仔细的评审（review）。在Rust设计中，编译器（compiler）扮演着守门员的角色，它会拒绝包含各种bugs代码的编译。通过编译器的帮忙，开发团队将会把更多的时间用在程序的逻辑上，而不是one day day 地在写bugs与修bugs之间疲于奔命。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 01.01:本地文档</title>
    <url>/2022/12/25/rust_docs/ch_01_01_Installation/</url>
    <content><![CDATA[<h4 id="本地文档"><a href="#本地文档" class="headerlink" title="本地文档"></a>本地文档</h4><p>安装过程包括了将对应Rust版本的文档复制到本地。所以你可以阅读官方文档，也可以通过命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> rustup doc</span><br></pre></td></tr></table></figure>

<p>会在浏览器里打开本地文档。</p>
<p>标准库里面的任何一个类型或者函数你不确定的时候，或者你不知道怎么用。使用应用程序编程接口(API)文档来找出答案。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 01.02:编译和运行是彼此独立的步骤</title>
    <url>/2022/12/26/rust_docs/ch_01_02_hello_world/</url>
    <content><![CDATA[<h5 id="编译和运行是彼此独立的步骤"><a href="#编译和运行是彼此独立的步骤" class="headerlink" title="编译和运行是彼此独立的步骤"></a>编译和运行是彼此独立的步骤</h5><p>你刚刚运行了一个新的程序，所以让我们来检查一下这个过程的每一个步骤。</p>
<p>在运行Rust程序之前，你必须通过rustc命令，用Rust编译器来编译这个它，并传入你源代码文件的名字，比如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> rustc main.rs</span><br></pre></td></tr></table></figure>

<p>如果你有C或者C++的技术背景，你可以视作像gcc 或者clang。在编译成功之后，Rust 会输出一个二进制可执行文件。</p>
<p>对于Linux,macOS和PowerShell on Windows,执行ls的shell命令之后，你就可以看到这个可执行文件。对于Linux，macOS，你可以看到两个文件。对于PowerShell on Windows,你会看到和使用CMD一样的三个文件。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">ls</span></span><br><span class="line">main main.rs</span><br></pre></td></tr></table></figure>

<p>在Windows的CMD，输入命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">dir</span> /B %= the /B option says to only show the file names =%</span><br><span class="line">main.exe</span><br><span class="line">main.pdb</span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>

<p>这显示出以.rs为扩展名的源代码文件和可执行文件(main.exe on Windows, but main on all other platforms),并且，当使用Windows，一个文件包括了debugging信息的.pdb扩展名。到此，你可以开始运行main 或者main.exe文件，如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> ./main <span class="comment"># or .\main.exe on Windows</span></span><br></pre></td></tr></table></figure>

<p>如果main.rs是你的”Hello,world!”程序，这行将打印出”Hello,world!”到你的屏幕。</p>
<p>如果你更加熟悉动态语言，如Ruby,Python, JavaScript, 你也许不习惯将编译和运行分为两个单独的步骤。Rust是一个预编译(ahead-of-time compiled)语言，代表你可以编译一个程序并且给可执行文件其他人，并且他们可以直接运行，不需要安装Rust。如果你给某人一个a.rb, .py, .js文件，他们需要安装一个Ruby,Python 或者JavaScript 实现(运行环境)。不过这些语言中，只需要一句命令就可以编译和运行程序。所有的事都是语言设计上的取舍。</p>
<p>仅仅使用rustc编译简单程序是没有问题的。但是随着你的项目发展，你会想要管理所有的选项，使得更简单地共享你的代码。接下来，我们将介绍给你一个叫做Cargo的工具，它将帮助你编写真实世界的Rust程序。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 01.03:养成使用Cargo习惯</title>
    <url>/2022/12/27/rust_docs/ch_01_03_hello_cargo/</url>
    <content><![CDATA[<h5 id="养成使用Cargo习惯"><a href="#养成使用Cargo习惯" class="headerlink" title="养成使用Cargo习惯"></a>养成使用Cargo习惯</h5><p>对于简单的项目，和rustc相比，Cargo不能提供多大的价值，但是对于复杂的项目，安装了很多crates, 它将会证明它的价值所在。让Cargo来协调构建工作会变得容易更多。</p>
<p>即使hello_cargo这么简单的项目，它现在使用了很多你之后的Rust生涯将会用到的使用工具。其实，要在任何已存在的项目上工作时，可以使用如下的命令通过Git拿到代码，移动到你的projects目录，并构建：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git clone example.org/someproject</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> someproject</span><br><span class="line"><span class="variable">$</span> cargo build</span><br></pre></td></tr></table></figure>

<p>更多关于Cargo详情，请查看Cargo 文档(<a href="https://doc.rust-lang.org/cargo/">https://doc.rust-lang.org/cargo/</a>)</p>
<p><strong>总结</strong></p>
<p>对于你的Rust之旅，你已经有一个很棒的开始了！本章你已经学会了如何：</p>
<ul>
<li>使用rustup安装最新稳定版Rust</li>
<li>更新到新版的Rust</li>
<li>打开本地安装的文档</li>
<li>直接通过rustc编写并运行”Hello,world!”程序</li>
<li>使用Cargo创建并运行项目</li>
</ul>
<p>是时候通过构建更实质性的程序来熟悉写Rust代码了。所以在Chapter 2,我们将构建一个猜数字的游戏程序。如果你更想从学习Rust常用的编程概念开始，请阅读Chapter 3，接着回来看Chapter 2.</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 02.00:猜测正确后退出</title>
    <url>/2022/12/28/rust_docs/ch_02_00_guessing_game_tutorial/</url>
    <content><![CDATA[<h5 id="猜测正确后退出"><a href="#猜测正确后退出" class="headerlink" title="猜测正确后退出"></a>猜测正确后退出</h5><p>让我们增加一个break语句，在用户才对时退出游戏：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">       <span class="comment">// --snip--</span></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在You win!之后增加一行break;，用户猜对了神秘数字之后会退出循环。退出循环也意味着退出程序，因为循环是main最后一部分。</p>
<p><strong>处理无效输入</strong></p>
<p> 为了进一步使得游戏表现更好，而不是当用户输入无效数字就崩溃，需要忽略无效输入，让用户继续猜。可以通过修改guess将String转换为u32那部分代码来实现，如Listing 2-5:</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">    .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>

<p>Listing 2-5 Ignoring a non-number guess and asking for another guess instead of crashing the program</p>
<p>我们将expect调用换成match语句，以从遇到错误就崩溃变为处理错误。需知parse返回一个Result类型，而Result是一个用于Ok或Err成员的枚举。这里使用的match表达式，和之前处理cmp方法返回Ordering时用的一样。</p>
<p>如果parse不能将字符串转换一个数字，它会返回一个包含更多错误信息的Err。Err值不能匹配第一个match分支的Ok(num)模式，但是会匹配第二个分支Err(_)模式：_是一个通配符值，本例中用来匹配所有的Err值，不管其中有任何信息。所以程序会执行第二个分支的动作，continue 意味着进入loop的下一次循环，请求另一个猜测。这样程序就有效地忽略了parse可能遇到的所有错误！</p>
<p>现在所有的事情都是我们期待的了，让我们试试：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cargo run</span><br><span class="line">   Compiling guessing_game v0.<span class="number">1.0</span> (file:///projects/guessing_game)</span><br><span class="line">    Finished dev <span class="function">[<span class="type">unoptimized</span> + <span class="type">debuginfo</span>] <span class="title">target</span></span>(s) <span class="keyword">in</span> <span class="number">4.45</span>s</span><br><span class="line">     Running `target/debug/guessing_game`</span><br><span class="line">Guess the number!</span><br><span class="line">The secret number is: <span class="number">61</span></span><br><span class="line">Please input your guess.</span><br><span class="line"><span class="number">10</span></span><br><span class="line">You guessed: <span class="number">10</span></span><br><span class="line">Too small!</span><br><span class="line">Please input your guess.</span><br><span class="line"><span class="number">99</span></span><br><span class="line">You guessed: <span class="number">99</span></span><br><span class="line">Too big!</span><br><span class="line">Please input your guess.</span><br><span class="line">foo</span><br><span class="line">Please input your guess.</span><br><span class="line"><span class="number">61</span></span><br><span class="line">You guessed: <span class="number">61</span></span><br><span class="line">You win!</span><br></pre></td></tr></table></figure>

<p>牛逼！再有一个小的修改，就能完成猜数字游戏了：还记得程序依然会打印出秘密数字吗？那个是为了便于测试，但是它破坏游戏性。让我们删掉这个打印语句吧。Listing 2-6是最终版本的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..<span class="number">101</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 2-6 Complete guessing game code</p>
<p><strong>总结</strong></p>
<p>至此，你成功地构建了猜数字游戏。恭喜你！</p>
<p>这个项目是一个通过动手实践，向你介绍了很多Rust新概念：let,match,函数，使用外部crate等等。在接下来的章节中，你将会学习这些概念的细节。第三章介绍大部分程序语言都有的概念，比如变量，数据类型和函数，以及如何在Rust中使用他们。第四章探索所有权(owership)，一个特性，使得Rust与其他语言不同的特性。第五章讨论结构体和方法的语法，第六章介绍枚举如何工作。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.00:关键字(Keywords)</title>
    <url>/2022/12/29/rust_docs/ch_03_00_common_programming_concepts/</url>
    <content><![CDATA[<h5 id="关键字-Keywords"><a href="#关键字-Keywords" class="headerlink" title="关键字(Keywords)"></a>关键字(Keywords)</h5><p>Rust语言有一个关键字集合，这些关键字预留给语言本使用，和其他大部分语言一样。牢记在心，你不能使用这些单词作为变量名或者函数名。大部分的关键字有其特殊的意义，而且你会用这些关键字来做各种各样的任务在Rust程序里。一些关键词目前没有相应的功能，是为了将来可能添加的功能预留的。可以在Appendix A(<a href="https://doc.rust-lang.org/book/appendix-01-keywords.html)%E6%9F%A5%E7%9C%8B">https://doc.rust-lang.org/book/appendix-01-keywords.html)查看</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.01:隐藏(Shadowing)</title>
    <url>/2022/12/29/rust_docs/ch_03_01_variables_and_mutability/</url>
    <content><![CDATA[<h5 id="隐藏-Shadowing"><a href="#隐藏-Shadowing" class="headerlink" title="隐藏(Shadowing)"></a>隐藏(Shadowing)</h5><p>如你在第二章猜数字游戏教程所见，你可以声明一个新的变量用和前面声明的变量同样的名字。Rustaceans说第一个变量被第二个隐藏(Shadowing)了，意思是第二个变量的值是在程序使用时才看到的。我们可以shadow一个变量使用相同的变量名，并重复地使用let关键字，如下：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序首先绑定了5给x。然后重新用let x&#x3D;隐藏了x，使得原来的值加1，所以变量的值变为了6。然后，在内部作用域，第三次let声明x, 将之前的值乘以2得到12。当内部作用结束，内部的隐藏结束，并且x变回6。当我们运行这个程序，它运行结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cargo run</span><br><span class="line">   Compiling variables v0.<span class="number">1.0</span> (file:///projects/variables)</span><br><span class="line">    Finished dev <span class="function">[<span class="type">unoptimized</span> + <span class="type">debuginfo</span>] <span class="title">target</span></span>(s) <span class="keyword">in</span> <span class="number">0.31</span>s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x <span class="keyword">in</span> the inner scope is: <span class="number">12</span></span><br><span class="line">The value of x is: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>隐藏不同于将变量标记为mut，因为如果我们意外地尝试重新分配这个变量不使用let关键字，我们会得到一个编译错误。通过使用let，我们可以对一个值执行一些转换，但在这些转换完成后，变量是不可变的。</p>
<p>其他的mut和shadowing之间的不同之处是因为当我们再次使用let关键字，我们实际上创建了一个新的变量。例如，假如我们的程序要求用户输入空格来显示文本之间需要多少空格，然后我们希望将输入存储为数字：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先spaces变量是一个string类型，然后第二个spaces变量是数字类型。因此shadowing使我们不需使用不同的变量名，如space_str 和 space_num；然而，如果我们尝试使用mut，如下，我们会得到一个编译时错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    spaces = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误说我们不被允许转变变量的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.<span class="number">1.0</span> (file:<span class="comment">///projects/variables)</span></span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">3</span>:<span class="number">14</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     spaces = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line">  |              ^^^^^^^^^^^^ expected `&amp;<span class="type">str</span>`, found `<span class="type">usize</span>`</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0308`.</span><br><span class="line">error: could not compile `variables` due to previous error</span><br></pre></td></tr></table></figure>

<p>现在，我们探索了变量是如何工作的，我们还有更多的数据类型等着你呢！</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.02:无效的数组元素访问</title>
    <url>/2022/12/29/rust_docs/ch_03_02_data_types/</url>
    <content><![CDATA[<h6 id="无效的数组元素访问"><a href="#无效的数组元素访问" class="headerlink" title="无效的数组元素访问"></a>无效的数组元素访问</h6><p>让我们看看发生了什么，如果你尝试访问数组的一个元素，这个元素在数组的结尾之后呢。运行如下的代码，类似于第二章猜数字游戏，从用户输入那里获取数组索引：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please enter an array index.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index</span><br><span class="line">        .<span class="title function_ invoke__">trim</span>()</span><br><span class="line">        .<span class="title function_ invoke__">parse</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Index entered was not a number&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">element</span> = a[index];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The value of the element at index &#123;&#125; is: &#123;&#125;&quot;</span>,</span><br><span class="line">        index, element</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码编译成功。如果运行这段代码使用cargo run然后输入0，1，2，3，4，这个程序会打印出在数组内对应索引的值。如果你输入一个超出范围的数字，比如10，你会看到输出如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">thread <span class="string">&#x27;main&#x27;</span> panicked at <span class="string">&#x27;index out of bounds: the len is 5 but the index is 10&#x27;</span>, src/main.rs:<span class="number">19</span>:<span class="number">19</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当你使用这个无效的值索引的时候，程序的结果是在运行时间的错误。程序退出并返回错误信息，并且没有运行最后的println!语句。当你试图用一个索引访问一个元素，Rust会检查你指定的这个索引是否会超过数组的长度。如果索引与数组长度相同或者更大，Rust就会死给你看。这个检查在运行时间，特别在这个例子中，因为编译器在编译完之后就不可能知道用户会输入什么。</p>
<p>这是一个Rust的内存安全原则示例的表现。在很多底层代码语言中，当你提供一个错误的索引，这种类型的检查它们是不做的，无效内存就会被访问，会导致你不知道你到底访问到了别的什么奇奇怪怪的值。Rust项目中会立即退出，而不是允许你继续访问，从而保护你面授此类错误的影响。第九章将会讨论Rust的错误处理。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.03:函数(Functions)</title>
    <url>/2022/12/29/rust_docs/ch_03_03_how_functions_work/</url>
    <content><![CDATA[<h4 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数(Functions)"></a>函数(Functions)</h4><p>函数在Rust代码中是很普遍的。你已经看了在语言中最重要的函数之一：main函数，是很多程序的入口。你也看到了fn关键字，它允许你声明一个新的函数。</p>
<p>Rust代码中的函数和变量使用snake case的代码风格，所有的单词小写并用下划线隔开。这里有一个程序包含了一个函数的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#![allow(unused)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">let x = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，five函数没有参数并定义了返回值类型，不过函数体只有单单一个5，因为它是一个表达式，可以返回我们想要的值。</p>
<p>让我们看看另外一个例子：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_one</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译这段代码，会产生一个如下的错误：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cargo run</span><br><span class="line">   Compiling functions v0.<span class="number">1.0</span> (file:///projects/functions)</span><br><span class="line">error[<span class="type">E0308</span>]: mismatched types</span><br><span class="line"> <span class="literal">--</span>&gt; src/main.rs:<span class="number">7</span>:<span class="number">24</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">7</span> | fn plus_one(x: i32) -&gt; i32 &#123;</span><br><span class="line">  |    <span class="literal">--------</span>            ^^^ expected `i32`, found `()`</span><br><span class="line">  |    |</span><br><span class="line">  |    implicitly returns `()` as its body has no tail or `return` expression</span><br><span class="line"><span class="number">8</span> |     x + <span class="number">1</span>;</span><br><span class="line">  |          - help: consider removing this semicolon</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0308`.</span><br><span class="line">error: could not compile `functions` due to previous error</span><br></pre></td></tr></table></figure>

<p>主要的错误信息”mismatched types”揭示了这段代码的核心问题所在。定义函数plus_one，然后说要返回一个i32，但是语句不会计算得到一个值，使用单位类型()表示不返回值。因为不返回值与函数返回一个i32类型的值矛盾，从而出现一个错误。在输出中，Rust提供了一条信息，可能有助于纠正这个错误：它建议删除分号，这会修复这个错误。</p>
<p>正确的代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_one</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.04:注释(Comments)</title>
    <url>/2022/12/29/rust_docs/ch_03_04_comments/</url>
    <content><![CDATA[<h4 id="注释-Comments"><a href="#注释-Comments" class="headerlink" title="注释(Comments)"></a>注释(Comments)</h4><p>所有的程序设计人员努力使他们的代码更容易理解，但是有时候额外的解释是有必要的。在这种情况下程序设计人员在源代码中留下注释(comments)，编译器会忽略这些注释，但是人阅读源码会发现它很有用。</p>
<p>这里有一个简单的注释例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="comment">// So we’re doing something complicated here, long enough that we need</span></span><br><span class="line"><span class="comment">// multiple lines of comments to do it! Whew! Hopefully, this comment will</span></span><br><span class="line"><span class="comment">// explain what’s going on.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释可以放在代码行结尾：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lucky_number</span> = <span class="number">7</span>; <span class="comment">// I’m feeling lucky today</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是你经常看到更多是如下的格式，在代码的上方的单独一行注释：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// I’m feeling lucky today</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lucky_number</span> = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 也有其他类型的注释，文档注释(documentation comments)，详细在第14章的”Publishing a Crate to Crates.io” 部分介绍。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.05:总结(Summary)</title>
    <url>/2022/12/29/rust_docs/ch_03_05_control_flow/</url>
    <content><![CDATA[<h4 id="总结-Summary"><a href="#总结-Summary" class="headerlink" title="总结(Summary)"></a>总结(Summary)</h4><p>你做到了！这是相当大的一章：你学习了关于variables, scalar and compound data type, functions, comments, if expressions, and loops! 讨论并练习这些概念。尝试构建如下的程序：</p>
<ul>
<li>相互转换摄氏与华氏温度(Convert temperatures between Fahrenheit and Celsius.)</li>
<li>生成n阶斐波那契数列(Generate th nth Fibonacci number.)</li>
<li>打印圣诞颂歌词，并利用歌词中的重复部分(编写循环)(Print the lyrics to the Christmas carol “The Twelve Days of Christmas,” taking advantage of the repetition in the song.)</li>
</ul>
<p>当你准备好继续的时候，让我们讨论一个其他语言中不常见的概念：所有权(ownership)</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 04.00:Understanding Ownership</title>
    <url>/2022/12/29/rust_docs/ch_04_00_understanding_ownership/</url>
    <content><![CDATA[<h4 id="Understanding-Ownership"><a href="#Understanding-Ownership" class="headerlink" title="Understanding Ownership"></a>Understanding Ownership</h4><p>Ownership 是Rust最独特的特性，并且对剩下的部分有着深刻的意义。它能让Rust在不需要垃圾回收(garbage collection)就能保证内存安全，所以能够很好地理解owership是如何工作的是非常重要的。在本章，我们将讲和ownership关联的一些特性：borrowing, slice, 和Rust如何在内存中布局数据。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 04.01:返回值与作用域(Return Values and Scope)</title>
    <url>/2022/12/29/rust_docs/ch_04_01_what_id_ownership/</url>
    <content><![CDATA[<h4 id="返回值与作用域-Return-Values-and-Scope"><a href="#返回值与作用域-Return-Values-and-Scope" class="headerlink" title="返回值与作用域(Return Values and Scope)"></a>返回值与作用域(Return Values and Scope)</h4><p>返回值也可以转移所有权。Listing 4-4展示了一个示例，与Listing4-3一样带有类似的注释。</p>
<p>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership moves its return</span></span><br><span class="line">                                        <span class="comment">// value into s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 comes into scope</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 is moved into</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back, which also</span></span><br><span class="line">                                        <span class="comment">// moves its return value into s3</span></span><br><span class="line">&#125; <span class="comment">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span></span><br><span class="line">  <span class="comment">// happens. s1 goes out of scope and is dropped.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">// gives_ownership will move its</span></span><br><span class="line">                                             <span class="comment">// return value into the function</span></span><br><span class="line">                                             <span class="comment">// that calls it</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string comes into scope</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// some_string is returned and</span></span><br><span class="line">                                             <span class="comment">// moves out to the calling</span></span><br><span class="line">                                             <span class="comment">// function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function takes a String and returns one</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string comes into</span></span><br><span class="line">                                                      <span class="comment">// scope</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// a_string is returned and moves out to the calling function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 4-4: Transferring ownership of return values</p>
<p>变量的所有权总是遵循相同的模式：将赋值给另一个变量时移动它。当持有堆中数据的变量离开作用域时，其值将通过drop被清理，除非数据被移动为另一个变量所有。</p>
<p>虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都穿进去再返回来就有点烦人了，除此之外，我们可能想返回函数中产生的一些数据。</p>
<p>我们可以使用元组来返回多个值，如Listing 4-5。</p>
<p>Filename：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s2, len) = <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = s.<span class="title function_ invoke__">len</span>(); <span class="comment">// len() returns the length of a String</span></span><br><span class="line"></span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 4-5: Returning ownership of parameters</p>
<p>但是，对于一个应该是普通的概念来说，这太多的仪式和大量的工作。幸运的是，Rust有一个特性，可以在不用转移所有权的情况下使用值，它叫做引用(references)。</p>
<p>接下来将讲”引用和借用(References and Borrowing)”</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 04.02:引用的规则(The Rules of References)</title>
    <url>/2022/12/29/rust_docs/ch_04_02_references_and_borrowing/</url>
    <content><![CDATA[<h4 id="引用的规则-The-Rules-of-References"><a href="#引用的规则-The-Rules-of-References" class="headerlink" title="引用的规则(The Rules of References)"></a>引用的规则(The Rules of References)</h4><p>让我们来重新概况一下之前对引用的讨论：</p>
<ul>
<li>在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。</li>
<li>引用必须总是有效的。</li>
</ul>
<p>接下来，我们来看看另一种不同类型的引用：slice。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 04.03:总结</title>
    <url>/2022/12/29/rust_docs/ch_04_03_slices/</url>
    <content><![CDATA[<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>所有权、借用和slice这些概念让Rust程序在编译时保证内存安全。Rust语言提供了跟其他系统编程语言相同的方式来控制你使用内存，但拥有数据所有者在离开作用域后自动清除其数据的功能意味着你无需额外编写和调试相关的控制代码。</p>
<p>所有权系统影响了Rust中很多其他部分的工作方式，所以我们还会继续讲到这些概念，这将贯穿本书余下的内容。让我们开始第五章吧，来看看如何将多份数据组合进一个struct中。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 05.00:Using Structs to Structure Related Data</title>
    <url>/2022/12/29/rust_docs/ch_05_00_structs/</url>
    <content><![CDATA[<h4 id="Using-Structs-to-Structure-Related-Data"><a href="#Using-Structs-to-Structure-Related-Data" class="headerlink" title="Using Structs to Structure Related Data"></a>Using Structs to Structure Related Data</h4><p>struct or structure 是一个自定义的数据类型，允许你包装和命名多个相关联的值，从而形成一个有意义的组合。如果你熟悉一门面向对象语言，struct就像对象中的数据属性。在本章中，我们会对元组和结构体进行对比和对照。还将演示如何定义和实现实例化结构体，并讨论如何定义关联函数，特别是被称为方法的那种关联函数，以指定与结构体类型相关的行为。你可以在程序中基于结构体和枚举(enum)（在第六章中介绍）创建新类型，以充分利用Rust的编译时类型检查。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 05.01:结构体数据的所有权(Ownership of Struct Data)</title>
    <url>/2022/12/29/rust_docs/ch_05_01_defining_and_instantiating_structs/</url>
    <content><![CDATA[<h4 id="结构体数据的所有权-Ownership-of-Struct-Data"><a href="#结构体数据的所有权-Ownership-of-Struct-Data" class="headerlink" title="结构体数据的所有权(Ownership of Struct Data)"></a>结构体数据的所有权(Ownership of Struct Data)</h4><p>在Listing 5-1中的<code>User</code>结构体定义中，我们使用了自身拥有所有权的String类型而不是&amp;str字符串slice类型。这是一个有意为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话数据也是有效的。可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上生命周期(lifetimes)，这是一个第十章会讨论的Rust功能。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。如果你尝试在结构体中存储一个引用而不是指定生命周期将是无效的，比如这样：</p>
<p>filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: &amp;<span class="type">str</span>,</span><br><span class="line">    email: &amp;<span class="type">str</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="string">&quot;someone@example.com&quot;</span>,</span><br><span class="line">        username: <span class="string">&quot;someusername123&quot;</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会控诉它需要生命周期标识符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling structs v0.<span class="number">1.0</span> (file:<span class="comment">///projects/structs)</span></span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">3</span>:<span class="number">15</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     username: &amp;<span class="type">str</span>,</span><br><span class="line">  |               ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> ~ <span class="keyword">struct</span> <span class="title class_">User</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line"><span class="number">2</span> |     active: <span class="type">bool</span>,</span><br><span class="line"><span class="number">3</span> ~     username: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">4</span>:<span class="number">12</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     email: &amp;<span class="type">str</span>,</span><br><span class="line">  |            ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> ~ <span class="keyword">struct</span> <span class="title class_">User</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line"><span class="number">2</span> |     active: <span class="type">bool</span>,</span><br><span class="line"><span class="number">3</span> |     username: &amp;<span class="type">str</span>,</span><br><span class="line"><span class="number">4</span> ~     email: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0106`.</span><br><span class="line">error: could not compile `structs` due to <span class="number">2</span> previous errors=</span><br></pre></td></tr></table></figure>

<p>第十章会讲到如何修复这个问题以便在结构体中存储引用，不过现在，我们使用像String这类拥有所有权的类型来替代&amp;str这样的引用以修正这个错误。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 05.02:An Example Program Using Structs</title>
    <url>/2022/12/29/rust_docs/ch_05_02_example_structs/</url>
    <content><![CDATA[<h4 id="An-Example-Program-Using-Structs"><a href="#An-Example-Program-Using-Structs" class="headerlink" title="An Example Program Using Structs"></a>An Example Program Using Structs</h4><p>为了理解何时需要使用结构体，让我们编写一个计算矩形面积的程序。我们将通过使用单个变量开始，然后重构这个程序，直到用结构体替代它。</p>
<p>让我们用cargo创建一个新的项目叫做<code>rectangles</code>的二进制程序，它获取以像素为单位的矩形的宽度和高度，并计算出矩形的面积。Listing 5-8 展示一个简短的程序：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scale</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: dbg!(<span class="number">30</span> * scale),</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dbg!(&amp;rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把<code>dbg!</code>放在表达式放在<code>30 * scale</code>周围，以为你<code>dbg!</code>返回表达式的值的所有权，所以width字段将获得相同的值，就像我们在这里没有<code>dbg!</code>调用一样。我们不希望dbg!拥有rect1的所有权，所以我们在下一次调用dbg!时传递一个引用。下面是这个例子的输出结果：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling rectangles v0.<span class="number">1.0</span> (file:<span class="comment">///projects/rectangles)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.61</span>s</span><br><span class="line">     Running `target/debug/rectangles`</span><br><span class="line">[src/main.rs:<span class="number">10</span>] <span class="number">30</span> * scale = <span class="number">60</span></span><br><span class="line">[src/main.rs:<span class="number">14</span>] &amp;rect1 = Rectangle &#123;</span><br><span class="line">    width: <span class="number">60</span>,</span><br><span class="line">    height: <span class="number">50</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到第一条输出来自src&#x2F;main.rs第10行，我们正在调用表达式<code>30 * scale</code>，其结果值是60(为整数实现的Debug格式化是只打印它们的值)。在src&#x2F;main.rs第14行的dbg!调用输出&amp;rect1的值，即<code>Rectangle</code>类型。<code>dbg!</code>宏确实很有用。</p>
<p>除了<code>Debug</code>trait，Rust还为我们提供了很多通过derive属性来使用的trait，它们可以为我们的自定义类型增加实用的行为。这些trait和行为被列举在附录C(Appendix C)。第十章会介绍如何通过自定义行为来实现这些trait，同时还有如何创建你自己的trait。除了derive之外，还有很多属性；更多信息见”Rust Reference”的Attribute部分。</p>
<p>我们的<code>area</code>函数是非常特殊的，它只计算长方形的面积。如果这个行为与<code>Rectangle</code>结构体再结合得更紧密一些就更好了，因为它不能用于其他类型。现在让我们看看如何继续重构这些代码，来将<code>area</code>函数协调进<code>Rectangle</code>类型定义的<code>area</code>方法中。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 05.03:总结(Summary)</title>
    <url>/2022/12/29/rust_docs/ch_05_03_method_syntax/</url>
    <content><![CDATA[<h4 id="总结-Summary"><a href="#总结-Summary" class="headerlink" title="总结(Summary)"></a>总结(Summary)</h4><p>结构体让你创建自定义的类型在你的domain中。通过使用结构体，你可以将数据关联起来，使得它看起来更加清晰。在impl块内，你可以定义函数并关联你的类型，而且方法是一个很好的关联方式，它让你的结构体有了可以指定它特定行为的能力。</p>
<p>但是结构体不是唯一的方式来创建自定义类型：让我们转到Rust的枚举(enum)特性来，为你的工具箱再添加一个工具。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 06.00:Enums and Pattern Matching</title>
    <url>/2022/12/29/rust_docs/ch_06_00_enums_and_pattern_matching/</url>
    <content><![CDATA[<h4 id="Enums-and-Pattern-Matching"><a href="#Enums-and-Pattern-Matching" class="headerlink" title="Enums and Pattern Matching"></a>Enums and Pattern Matching</h4><p>本章中，我们讲述枚举(enumerations)，也称作enums。枚举允许你通过列举可能的成员(variants)来定义一个类型。首先，我们会定义并使用一个枚举来展示它是如何连同数据一起编码信息的。接下来，我们会探索一个特别有用的枚举，叫做<code>Option</code>，它代表一个值，要么是某个值要么是什么都不是。然后会讲到<code>match</code>表达式中使用模式匹配，针对不同的枚举值编写相应要执行的代码。然后会介绍<code>if let</code>，另一个简洁方便处理代码中枚举的结构。</p>
<p>枚举是一个很多语言都有的功能，不过不同语言中其功能各不相同。Rust的枚举与F#，OCaml和Haskell这样的函数式编程语言中的代数数据类型(olgebraic data types)最为相似。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 06.01:The Option Enum and Its Advantages Over Null Values</title>
    <url>/2022/12/29/rust_docs/ch_06_01_defining_an_enum/</url>
    <content><![CDATA[<h3 id="The-Option-Enum-and-Its-Advantages-Over-Null-Values"><a href="#The-Option-Enum-and-Its-Advantages-Over-Null-Values" class="headerlink" title="The Option Enum and Its Advantages Over Null Values"></a>The Option Enum and Its Advantages Over Null Values</h3><p>这一部分探索学习<code>Option</code>，另外一个标准库的枚举定义。<code>Option</code>类型编码了非常常见的场景，其中可以是某个值，也可以都不是。</p>
<p>例如，如果请求一个包含项的列表的第一个值，会得到一个值，如果请求一个空的列表，就什么也不会得到。从类型系统的角度来表达这个概念意思就是编译器需要检查是否处理了所有应该处理的情况，这样就可以避免在其他语言中非常常见的bug.</p>
<p>编程语言的设计通常考虑的是包含哪些特性，但是你排除的特性也很重要。Rust没有许多其他语言所具有的null特性。<code>Null</code>是一个值，表示什么也没有。在带有null特性的语言中，变量总是可以处于两种状态之一：null 或 not-null.</p>
<p>Null的发明者Tony Hoare在他2009年的报告”Null Reference: The Billon Dollar Mistake”中这样说：</p>
<blockquote>
<p>我称之为十亿美元的错误。当时，我在为一个面向对象语言设计第一个综合性的面向引用的类型系统。我的目标是通过编译器的自动检查来保证所引用的使用都应该是绝对安全的。不过我未能抵抗住引入一个空引用的诱惑，仅仅是因为它是这么的容易实现。这引发了无数错误，漏洞和系统崩溃，在之后的四十多年中造成了十亿美元的苦痛和伤害。</p>
</blockquote>
<p>空值的问题在于，如果你试图将空值用作非空值，会出现某种形式的错误。因为空和非空的属性到处都是，非常容易出现这类错误。</p>
<p>然而，null试图表达的概念仍然是有用的：null是当前由于某种原因无效或者不存在的值。</p>
<p>问题不在于概念，而在于具体的实现。因此，Rust没有空值，但它有一个枚举，可以编码值存在或者不存在的概念。这个枚举就是<code>Option&lt;T&gt;</code>，它由标准库定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Option&lt;T&gt;</code>枚举非常有用，以至于它被包含在relude中；你不需要将它显式地引入作用域。另外，它的成员也是如此（被包含在prelude中），可以不需要<code>Option::</code>前缀来使用<code>Some</code>和<code>None</code>。即便如此<code>Option&lt;T&gt;</code>也仍是常规的枚举，<code>Some&lt;T&gt;</code>和<code>None</code>仍是<code>Option&lt;T&gt;</code>的成员。</p>
<p><code>&lt;T&gt;</code>语法是我们还没讲到的Rust特性。它是一个泛型参数，在Chapter 10我们将会详细讲解。目前，你需要知道的就是<code>&lt;T&gt;</code>意味着<code>Option</code>枚举的<code>Some</code>成员可以包含任意类型的数据，同事每一个用于<code>T</code>位置的具体类型使得<code>Option&lt;T&gt;</code>整体作为不同的类型。这里是一些包含数字类型和字符串类型<code>Option</code>值的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_char</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>some_number</code>的类型是<code>Option&lt;i32&gt;</code>。<code>some_char</code>的类型是<code>Option&lt;char&gt;</code>，是不同的类型。因为我们在<code>Some</code>成员中指定了值，Rust可以推断出其类型。对于<code>absent_number</code>，Rust需要我们指定<code>Option</code>整体的类型，因为编译器只通过<code>None</code>值无法推断出<code>Some</code>成员保存的值的类型。这里我们告诉Rust我们需要<code>absent_number</code>的类型是<code>Option&lt;i32&gt;</code>。</p>
<p>当我们有一个<code>Some</code>值，我们就知道存在一个值，这个值保存在<code>Some</code>中。当我们有一个值<code>None</code>，在某种意义上，它跟空值是有相同的意义：并没有一个有效的值。那么<code>Option&lt;T&gt;</code>为什么就比Null要好呢？</p>
<p>简单来说，因为<code>Option&lt;T&gt;</code>和<code>T</code>（<code>T</code>可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用<code>Option&lt;T&gt;</code>。例如：这段代码不能编译，因为它尝试将<code>Option&lt;i8&gt;</code>与<code>i8</code>相加：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们运行这段代码，我们会得到一个错误信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling enums v0.1.0 (file:///projects/enums)</span><br><span class="line">error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`</span><br><span class="line"> --&gt; src/main.rs:5:17</span><br><span class="line">  |</span><br><span class="line">5 |     let sum = x + y;</span><br><span class="line">  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`</span><br><span class="line">  = help: the following other types implement trait `Add&lt;Rhs&gt;`:</span><br><span class="line">            &lt;&amp;&#x27;a f32 as Add&lt;f32&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a f64 as Add&lt;f64&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i128 as Add&lt;i128&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i16 as Add&lt;i16&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i32 as Add&lt;i32&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i64 as Add&lt;i64&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i8 as Add&lt;i8&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a isize as Add&lt;isize&gt;&gt;</span><br><span class="line">          and 48 others</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `enums` due to previous error</span><br></pre></td></tr></table></figure>

<p>铛!铛!铛!事实上，这个错误意味着Rust不知道如何将<code>i8</code>和<code>Option&lt;i8&gt;</code>相加，因为它们是不同类型。在Rust中，当我们有一个值像<code>i8</code>，编译器将会确保我们总是有一个有效的值。我们可以自信地使用而无需做空检查。只有当使用<code>Option&lt;i8&gt;</code>(或者任何用到的类型)我们需要担心可能没有一个有效值，并且编译器将会确保我们在使用值之前处理了空的情况。</p>
<p>换句话说，你必须将<code>Option&lt;T&gt;</code>转换成<code>T</code>之后才能对<code>T</code>进行运算。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空，但实际上是空的情况。</p>
<p>消除错误地假设非空值的风险有助于你对代码更有信心。为了有一个可能为空的值，你必须显式地使用<code>Option&lt;T&gt;</code>。然后，在使用该值时，需要显式地处理值为空的情况。任何地方，一个值不是<code>Option&lt;T&gt;</code>类型，你都可以放心地假设他不是null。这是Rust有意为之的设计决定，目的就是限制null的滥用，以增加Rust代码的安全性。</p>
<p>所以，当你有一个类型为<code>Option&lt;T&gt;</code>的值时，你如何从<code>Some</code>变量中获得<code>T</code>的值呢？<code>Option&lt;T&gt;</code>枚举有大量很有用的方法适用于各种情况；你可以查看它的文档(<a href="https://doc.rust-lang.org/std/option/enum.Option.html)%E3%80%82%E7%86%9F%E6%82%89%60Option">https://doc.rust-lang.org/std/option/enum.Option.html)。熟悉`Option</a><T>&#96;上的方法将对你的Rust之旅很有用哦！</p>
<p>通常，为了使用<code>Option&lt;T&gt;</code>值，你需要有处理每个变量的代码。你希望一些代码只在具有<code>Some&lt;T&gt;</code>值时运行，并且允许这些代码使用内部的<code>T</code>。你希望如果有个<code>None</code>值时运行一些其他的代码，而且这些代码也没有一个<code>T</code>的有效值。<code>match</code>表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 06.02:通用模式和_占位符(Catch-all Patterns and the _ Placeholder)</title>
    <url>/2022/12/29/rust_docs/ch_06_02_match/</url>
    <content><![CDATA[<h4 id="通用模式和-占位符-Catch-all-Patterns-and-the-Placeholder"><a href="#通用模式和-占位符-Catch-all-Patterns-and-the-Placeholder" class="headerlink" title="通用模式和_占位符(Catch-all Patterns and the _ Placeholder)"></a>通用模式和_占位符(Catch-all Patterns and the _ Placeholder)</h4><p>使用枚举，我们希望对一些特定的值采取特殊操作，而对其他的值采用默认操作。想象我们正在玩一个游戏，如果你掷出一个骰子的值为3，角色不会移动，而是会得到一顶新奇的帽子。如果你掷出了7，你的角色将会失去新奇的帽子。对于其他的数值，你的角色会在棋盘上移动想的格子。这是一个实现了上述逻辑的<code>match</code>。骰子的结果是硬编码而不是一个随机值，其他的逻辑部分使用了没有函数体的函数来表示，实现它们超出了本例的范围：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">        other =&gt; <span class="title function_ invoke__">move_player</span>(other),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">move_player</span>(num_spaces: <span class="type">u8</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于前两个分支，匹配模式是字面值3和7，最后一个分支则涵盖了所有其他可能性的值，模式使我们命名为<code>other</code>的一个变量。<code>other</code>分支的代码通过将其传递给<code>move_player</code>函数来使用这个变量。</p>
<p>即使我们没有列出<code>u8</code>所有可能的值，这段代码依然能够编译，因为最后一个模式将匹配所有未被特殊列出的值。这种通配模式满足了<code>match</code>必须穷尽的要求。请注意，我们必须将通过通配分支放在最后，因为模式是按顺序匹配的。如果哦我们在通配分支后添加其他分支，Rust将会警告我们，因为此后的分支永远不会被匹配到。</p>
<p>Rust还提供了一个模式，当我们不想使用通配模式的值时，请使用<code>_</code>，这是一个特殊模式，可以匹配任意值而不用绑定到该值。这告诉Rust我们不会使用这个值，所以Rust也不会警告我们存在未使用的变量。</p>
<p>让我们改变游戏规则：现在，当你掷出的值不是3或7的时候，你必须再次掷出。这种情况下我们不需要使用这个值，所以我们改动代码使用<code>_</code>来替代变量<code>other</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">        _ =&gt; <span class="title function_ invoke__">reroll</span>(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">reroll</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子也满足穷举性要求，因为我们在最后一个分支中明确地忽略了其他的值。我们没有忘记任何东西。</p>
<p>最后，我们再次改动游戏规则，如果投掷出3或者7以外的值，你的回合将无事发生。我们可以使用单元值(unit value：就是空的tuple，在”The Tuple Type”部分有提及)作为<code>_</code>分支的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们明确告诉Rust我们不会使用与前面模式不匹配的值，并且这种情况下我们不想运行任何代码。</p>
<p>更详细的模式匹配相关我们将会在Chapter 18进行讲解。目前，我们继续讨论<code>if let</code>语法，这在<code>match</code>表达式有点冗长的情况下比较有用。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 06.03:总结</title>
    <url>/2023/05/16/rust_docs/ch_06_03_if_let/</url>
    <content><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们学习了如何使用枚举创建自定义类型。我们也展示了标准库的<code>Option&lt;T&gt;</code>类型是如何帮助你利用类型系统来避免出错的。当枚举值包含数据时，你可以根据你需要处理多少种情况来选择使用<code>mathc</code>或者<code>if let</code>来提取或者使用这些值。</p>
<p>你的Rust程序现在能够使用结构体和枚举在你自己的作用域内表现其内容了。在你的API中使用定义类型保证了类型安全：编译器会确保你的函数只会得到它期望的类型的值。</p>
<p>为了提供一个有条理的API给你的用户，它使用起来很简单易懂，值暴露了你的用户需要的东西，现在我们准备开始学习Rust的模块。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.00:使用包、Crate和模块管理不断增长的项目</title>
    <url>/2023/05/18/rust_docs/ch_07_00_managing_growing_projects_with_packages_crates_and_modules/</url>
    <content><![CDATA[<h2 id="使用包、Crate和模块管理不断增长的项目"><a href="#使用包、Crate和模块管理不断增长的项目" class="headerlink" title="使用包、Crate和模块管理不断增长的项目"></a>使用包、Crate和模块管理不断增长的项目</h2><p>当你编写大型程序时，组织代码将变得越来越重要。通过相关功能进行分组，并将具有不同特性的代码分开，你将可以清楚地在哪里可以找到现实特定特性的代码，以及在哪里可以更改一个特性的工作方式。</p>
<p>到目前为止，我们编写的代码都只在一个文件中的一个模块中。 随着项目不断增长，你应该通过多个模块和多个文件来组织拆分你的代码。一个包可以包含多个二进制crates和一个可选的crate程序库。随着你的包的增长，你可以将部分提取到单独的crates使它变成外部依赖。本章涵盖了所有这些技巧。对于由一组相互关联的包组成的非常大的项目，Cargo提供了工作区(workspaces)，我们将在第14章”Cargo Workspaces”部分学习。</p>
<p>我们还将讨论封装实现的细节，这让你可以高水平重用代码：一旦你实现了一个操作，其他代码可以通过代码的公共接口调用，无需知道你的实现过程是如何运作。编写代码的方式定义了那些部分是其他代码使用的公共部分，那些代码是你保留更改权利的私有实现细节。这是另一种限制，减少你必须记住项目内容细节的数量的方法。</p>
<p>这里还一个相关的概念是作用域(scope)：代码所在的嵌套上下文有一组定义”in scope”的名称。当你阅读，编写和编译代码，程序设计师和编译器需要知道模块，常量或者其他有意义的项。你可以创建作用域并改变那些名称再作用域内还是在作用域外。同一个作用域不能拥有两个相同名称的项；可以使用一些工具来解决名称冲突。</p>
<p>Rust有许多特性允许你来管理你的代码组织结构，包括那些内容可以被公开，那些内容作为私有部分，以及程序每个作用域中的名字。这些功能。有时被称为”模块系统(the module system)”，包括：</p>
<ul>
<li>包(Packages)：Cargo的一个功能，它允许你构建，测试和分享crate。</li>
<li>Crates：一个模块的树形结构，它形成了库或者二进制项目。</li>
<li>模块(Modules)和Use：允许你控制组织结构的作用域和路径的私有性。</li>
<li>路径(path)：一个命名例如结构体，函数或模块等项的方式。</li>
</ul>
<p>在本章，我们将涵盖所有这些特性，讨论他们怎样相互作用，并解释如何使用他们管理作用域。最后，你应该对模块系统有一个坚实的理解，并能够像专业人士一样使用作用域！</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.01:包和Crates</title>
    <url>/2023/05/18/rust_docs/ch_07_01_packages_and_crates/</url>
    <content><![CDATA[<h2 id="包和Crates"><a href="#包和Crates" class="headerlink" title="包和Crates"></a>包和Crates</h2><p>模块系统的第一部分我们将介绍包和crate。</p>
<p>crate是Rust编译时最小的代码单位。如果你用<code>rustc</code>而不是<code>cargo</code>来编译一个文件(第一章我们这么做)，编译器还是会将那个文件认作一个crate。crate可以包含模块，模块可以定义在其他文件，然后和crate一起编译，我们会在接下来的章节中遇到。</p>
<p>crate有两种形式：二进制项和库。二进制crate可以被编译为可执行程序，比如一个命令行程序或者一个服务器。它们必须有一个<code>main</code>函数来定义当程序被执行的时候所需要做的事情。到目前为止，我们所创建的crate都是二进制crate。</p>
<p>库(Library crates) 没有<code>main</code>函数，而且它们不会编译成可执行文件。相反，它们定义了旨在与多个项目共享的功能。例如，我们在第二章用过的<code>rand</code>函数，用来生成随机数。大多数的Rust开发者说的crate指的都是库，这与其他变成语言中的library概念一致。</p>
<p>crate root是一个资源文件，Rust编译器以它为起始点，并组成crate的根模块(我们将在”Defining Modules to Control Scope and Privacy” 部分深度解析)。</p>
<p>包(package)是提供一系列功能的一个或者多个crate。一个包会包含Cargo.toml文件，阐述如何去创建这些crates。Cargo就是一个包含构建你代码的二进制项的包。Cargo也包含这些二进制项所依赖的库。其他项目也能用Cargo库来实现与Cargo命令行程序一样的逻辑。</p>
<p>包可以包含很多二进制(binary) crate，但是最多只能有一个库(library) crate。包无论是一个库(library crate)还是一个二进制库(binary crate)， 至少要包含一个library crate。</p>
<p>让我们来看看创建包的时候会发生什么。首先，我们输入命令<code>cargo new</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new my-project</span></span><br><span class="line">     Created binary (application) `my-project` package</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> my-project</span></span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> my-project/src</span></span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>

<p>运行<code>cargo new</code>之后，我们使用<code>ls</code>查看Cargo创建了什么，在这个项目目录里，Cargo会给我们创建一个Cargo.toml文件，这就是一个包(package)。这里也有一个src目录包含main.rs文件。用编辑器打开Cargo.toml，并且文件内容里面没有提及src&#x2F;main.rs。因为Cargo遵循的一个约定：src&#x2F;main.rs就是一个与包同名的二进制crate的crate根。同样地，Cargo知道如果包目录中包含src&#x2F;lib.rs，则包带有与其同名的库(library) crate。crate根文件将由Cargo传递给<code>rustc</code>来构建库(library)或者二进制(binary)。</p>
<p>这里，我们有一个只包含src&#x2F;main.rs的包，意味着它只含有一个名为<code>my-project</code>的二进制crate。如果一个包同时含有src&#x2F;main.rs和src&#x2F;lib.rs，则它有两个crate：一个二进制(binary)的和一个库(library)，并且名字都与包相同。通过将文件放在src&#x2F;bin目录下，一个包可以拥有多个二进制crate：每个src&#x2F;bin下的文件都会被编译成一个独立的二进制crate。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.02:在模块中对相关代码进行分组(Grouping Related Code in Modules)</title>
    <url>/2023/05/18/rust_docs/ch_07_02_defining_modules_to_control_scope_and_privacy/</url>
    <content><![CDATA[<h4 id="在模块中对相关代码进行分组-Grouping-Related-Code-in-Modules"><a href="#在模块中对相关代码进行分组-Grouping-Related-Code-in-Modules" class="headerlink" title="在模块中对相关代码进行分组(Grouping Related Code in Modules)"></a>在模块中对相关代码进行分组(Grouping Related Code in Modules)</h4><p>模块让我们在crate中组织代码，以提高可读性和易于重用。模块还允许我们控制items的私有性，因为在module中的代码默认是私有的。Private items是内部实现的细节不对外使用。我们可以选择将模块以及其中的items设置为公共的，这样，外部代码就可以使用并依赖于它们。</p>
<p>例如，让我们编写一个提供餐厅服务功能的library crate。我们将会定义函数的签名，但是函数的主题留空，集中于代码的组织，而不是实现一个餐馆。</p>
<p>在餐厅业中，餐馆的某些部分被称为前台(front of house)，其他的部分称为后台(back of house)。前台是顾客所在的空间；这包括主座的顾客的位置，服务员接单和付款，以及调酒师调酒的地方。后台是主厨和厨师们在厨房，洗碗机清理，经历做行政工作。</p>
<p>这样构建我们的crate，我们可以将这些功能组织成嵌套的模块。创建一个新的库(library)命名为<code>restaurant</code>，通过命令<code>cargo new restaurant --lib</code>。输入如下Listing 7-1代码到src&#x2F;lib.rs来定义一些模块和函数签名。这里是前台部分：</p>
<p>src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 7-1: A <code>front_of_house</code>module containing other modules that then contain functions</p>
<p>我们用<code>mod</code>关键字定义一个模块(在上面的例子中定义了<code>front_of_house</code>模块)。并用花括号包围模块的主体。在模块内，我们还可以定义其他模块，就像本例子中的<code>hosting</code>和<code>serving</code>模块。模块还可以hold一些定义的其他items，例如structs, enums, constants, traits, 以及Listing 7-1中的函数。</p>
<p>通过使用模块，我们可以将相关的定义分组到一起，并指出他们为什么相关。程序设计者可以通过使用这段代码，更加容易找到他们想要的定义，因为他们可以基于分组来对代码进行导航，而不需要阅读所有的定义。程序设计者向这段代码中添加一个新功能时，他们也会知道代码应该放置在何处，可以保持程序的组织性。</p>
<p>在前面我们提到了，<code>src/main.rs</code>和<code>src/lib.rs</code>叫做crate根。之所以这么叫它们是因为这两个文件中的任何一个内容都在crate模块结构的根组成了一个名为crate的模块，该结构被称为模块树(module tree)。</p>
<p>Listing 7-2 展示了示例Listing 7-1中的模块树(modules tree)的结构。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">crate</span></span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure>

<p>Listing 7-2: The module tree for the code in Listing 7-1</p>
<p>这个模块树展示了一些模块内嵌到另一个模块；例如，<code>hosting</code>内嵌在<code>front_of_house</code>之中。这个树结构还展示了一些模块是互为兄弟(siblings)的，这意味着它们定义在同一模块中(<code>hosting</code>和<code>serving</code>被一起定义在<code>front_of_house</code>中)。继续沿用家庭关系的比喻，如果一个模块A被包含在模块B中，我们将模块A称为模块B的子模块，B模块为A的父模块。注意，整个模块树都植根于隐式模块名为<code>crate</code>之下。</p>
<p>模块树可能会让你想起计算机上的文件系统的目录树；这是一个非常恰当的比较！就像文件系统中的目录一样，你用模块来组织你的代码。就像文件目录中的文件，我们需要一个方式来找到我们的模块(modules)。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.03:创建公有的结构体和枚举(Making Structs and Enums Public)</title>
    <url>/2023/05/18/rust_docs/ch_07_03_paths_for_referring_to_an_item_the_the_module_tree/</url>
    <content><![CDATA[<h4 id="创建公有的结构体和枚举-Making-Structs-and-Enums-Public"><a href="#创建公有的结构体和枚举-Making-Structs-and-Enums-Public" class="headerlink" title="创建公有的结构体和枚举(Making Structs and Enums Public)"></a>创建公有的结构体和枚举(Making Structs and Enums Public)</h4><p>我们也可以使用<code>pub</code>来指定结构体和枚举为公有，但是这里有一些额外的使用详情需要注意。如果我们在使用<code>pub</code>定义一个结构体，我们使得这个结构体为公有，但是结构体的字段将仍是私有的。我们可以视情况而定让每一个字段成为公有或者私有。在Listing 7-9中，我们定义了一个公有的<code>back_of_house::Breakfast</code>结构体并且<code>toast</code>为公有字段，而<code>seasonal_fruit</code>为私有字段。该模型以餐厅为例，顾客可以选择随餐面包的类型，但是主厨会根据当季水果和库存来搭配什么水果。可选择的水果变化很快，所以顾客不能选择水果，甚至不能看到他们能得到的水果。</p>
<p>src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="type">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// Order a breakfast in the summer with Rye toast</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="comment">// Change our mind about what bread we&#x27;d like</span></span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The next line won&#x27;t compile if we uncomment it; we&#x27;re not allowed</span></span><br><span class="line">    <span class="comment">// to see or modify the seasonal fruit that comes with the meal</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from(&quot;blueberries&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 7-9: A struct with some public fields and some private fields</p>
<p>因为<code>toast</code>字段在<code>back_of_house::Breakfast</code>结构体内是公有的，在<code>eat_at_restaurant</code>中我们可以编写并且读到<code>toast</code>字段使用点(.)号。注意，我们不能在<code>eat_at_restaurant</code>中使用<code>seasonal_fruit</code>字段，因为<code>seasonal_fruit</code>字段是私有的。尝试取消注释修改季节水果字段的值，看看会得到什么错误。</p>
<p>同样，注意因为<code>back_of_house::Breakfast</code>有一个私有字段，这个结构体需要提供一个公有的关联函数来构造一个<code>Breakfast</code>实例(这里是名为<code>summer</code>的函数)。如果<code>Breakfast</code>没有这样一个函数，我们就不能在<code>eat_at_restaurant</code>中创建<code>Breakfast</code>实例，因为我们不能在<code>eat_at_rest_aurant</code>中给<code>seasonal_fruit</code>私有字段设置值。</p>
<p>相反地，如果我们设置枚举为公有，它所有的字段都是公有的。我们只需要在<code>enum</code>关键字前面加上<code>pub</code>即可，如Listing 7-10所示：</p>
<p>src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Appetizer</span> &#123;</span><br><span class="line">        Soup,</span><br><span class="line">        Salad,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">order1</span> = back_of_house::Appetizer::Soup;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">order2</span> = back_of_house::Appetizer::Salad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 7-10: Designating an enum as public makes all its variants public</p>
<p>因为我们设置了<code>Appetizer</code>为公有枚举，我们可以在<code>eat_at_restaurant</code>中使用<code>Soup</code>和<code>Salad</code>成员变量。</p>
<p>除非设置枚举的变量为公开的，否则枚举就没什么用了；在每种情况下都必须使用<code>pub</code>来声明所有枚举变量，这将是很恼人的设计，所以默认情况下枚举的所有变量都是公有的。结构体在字段为私有的情况通常是有用的，所以结构体字段默认遵循所有内容为私有的普遍规则，除非使用<code>pub</code>声明公有。</p>
<p>这里还涉及<code>pub</code>另外一个情况我们没有讨论到，那就是我们最后要讲的模块功能：<code>use</code>关键字。我们将单独介绍<code>use</code>，然后展示如何结合<code>pub</code>和<code>use</code>起来使用。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.04:全局操作符(The Glob Operator)</title>
    <url>/2023/05/18/rust_docs/ch_07_04_bringing_paths_into_scope_with_the_use_key_word/</url>
    <content><![CDATA[<h4 id="全局操作符-The-Glob-Operator"><a href="#全局操作符-The-Glob-Operator" class="headerlink" title="全局操作符(The Glob Operator)"></a>全局操作符(The Glob Operator)</h4><p>如果想将一个路径下所有公有项引入作用域，可以使用指定路径后跟<code>*</code>，glob操作符:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure>

<p>这个<code>use</code>语句会将<code>std::collections</code>中定义的所有的公有项引入到当前作用域。使用全局操作符时一定要多加小心！全局操作符会使得我们难以推导作用域中有什么名称和它们是定义在何处。</p>
<p>全局操作符经常用于测试模块<code>tests</code>中，这时会将所有内容引入作用域；我们将在第十一章”How to Write Tests”部分中讲解。全局操作符有时也用于preclude模式；查看”标准库文档”(<a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes)%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82%E3%80%82">https://doc.rust-lang.org/std/prelude/index.html#other-preludes)了解更多细节。</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.05:总结</title>
    <url>/2023/05/18/rust_docs/ch_07_05_separating_modules_into_different_files/</url>
    <content><![CDATA[<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Rust提供了将包分成多个crate，将crate分成模块，以及通过指定绝对或者相对路径从一个模块引用另一个模块中定义的项的方式。你可以指定绝对路径或者相对路径。这个路径可以通过<code>use</code>声明引入到作用域，所以你可以在多次使用时可以使用更短的路径。模块定义的代码默认是私有的，不过可以选择增加<code>pub</code>关键字使其定义为公有。</p>
<p>接下来，我们来看一些标准库提供的集合数据类型，你可以利用它们写出更漂亮整洁的代码。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 08.00:常见集合</title>
    <url>/2023/05/18/rust_docs/ch_08_00_common_collections/</url>
    <content><![CDATA[<h2 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h2><p>Rust标准库中包含一些非常有用的数据结构叫做结合(collections).大多数其他的数据类型代表一个特殊的值，但是集合可以包含多个值。不像内建的数组和元组类型，这些集合数据指向堆，意味着在编译时不需要知道数据量，并且可以随着程序运行而增加或减少。每一种集合有不同的性能和消耗，并且选择一个合适的集合，对你当前的情景是需要你慢慢学习的技巧。在本章，我们将会讨论三个集合，它们在Rust编程中很常用：</p>
<ul>
<li>vector 允许你一个挨着一个地存储一系列数量的可变的值</li>
<li>string 是一个字符类型的集合。我们之前已经提到过<code>String</code>类型，但是在本章，我们将更加深入地讨论它。</li>
<li>hash map 允许你用一个特定的key关联一个值(value)，它是成为映射的更通用数据结构的一种实现。</li>
</ul>
<p>要学习标准库提供的其他类型的集合，请查看文档<a href="https://doc.rust-lang.org/std/collections/index.html">std::collections</a></p>
<p>我们将要讨论如何创建和更新vectors, strings，和hash map，以及他们每个类型的独特之处。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 08.01:丢弃vector 时也会丢弃其所有元素(Dropping a Vector Drops Its Elements)</title>
    <url>/2023/05/18/rust_docs/ch_08_01_vectors/</url>
    <content><![CDATA[<h4 id="丢弃vector-时也会丢弃其所有元素-Dropping-a-Vector-Drops-Its-Elements"><a href="#丢弃vector-时也会丢弃其所有元素-Dropping-a-Vector-Drops-Its-Elements" class="headerlink" title="丢弃vector 时也会丢弃其所有元素(Dropping a Vector Drops Its Elements)"></a>丢弃vector 时也会丢弃其所有元素(Dropping a Vector Drops Its Elements)</h4><p>像其他数据结构一样，当一个vector离开了它的作用域，它就会被释放，如Listing 8-10所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do stuff with v</span></span><br><span class="line">    &#125; <span class="comment">// &lt;- v goes out of scope and is freed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 8-10: Showing where the vector and its elements are droped</p>
<p>当vector被删除时，它的所有内容也会被删除，这意味着它所持有的整数将被清除。借用检查器确保仅在vector本身有效时才使用对向量内容的任何引用。</p>
<p>接下来，我们将学习下一个集合类型：<code>String</code></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 08.02:字符串并不简单</title>
    <url>/2023/05/18/rust_docs/ch_08_02_strings/</url>
    <content><![CDATA[<h4 id="字符串并不简单"><a href="#字符串并不简单" class="headerlink" title="字符串并不简单"></a>字符串并不简单</h4><p>总之，字符串是很复杂的。不同的语言会有不同的选择如何将这种复杂性呈现给程序员。Rust选择将String数据的正确处理作为所有Rust程序的默认行为,这意味着程序员必须在处理UTF-8数据上花更多的心思。这个权衡在其他编程语言中暴露了更多字符串的复杂性,但它可以防止你在开发生命周期的后期处理涉及非ASCII字符的错误。<br>好消息是标准库基于String和&amp;str类型提供了许多功能来正确处理这些复杂的情况。确保查看文档中有用的方法,比如在字符串中搜索的contains和用另一个字符串替换字符串的一部分replace。<br>让我们切换到略微简单一点的内容:哈希映射!</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 08.03:总结</title>
    <url>/2023/05/18/rust_docs/ch_08_03_hash_maps/</url>
    <content><![CDATA[<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>vector、字符串和哈希 map 会在你的程序需要储存、访问和修改数据时帮助你。这里有一些你应该能够解决的练习问题:</p>
<ul>
<li>给定一系列数字，使用 vector 并返回这个列表的中位数（排列数组后位于中间的值）和众数（mode，出现次数最多的值；这里哈希 map 会很有帮助）。</li>
<li>将字符串转换为 Pig Latin，也就是每一个单词的第一个辅音字母被移动到单词的结尾并增加 “ay”，所以 “first” 会变成 “irst-fay”。元音字母开头的单词则在结尾增加 “hay”（“apple” 会变成 “apple-hay”）。牢记 UTF-8 编码！</li>
<li>使用哈希 map 和 vector，创建一个文本接口来允许用户向公司的部门中增加员工的名字。例如，“Add Sally to Engineering” 或 “Add Amir to Sales”。接着让用户获取一个部门的所有员工的列表，或者公司每个部门的所有员工按照字典序排列的列表。</li>
</ul>
<p>标准库 API 文档中描述的这些类型的方法将有助于你进行这些练习！</p>
<p>我们已经开始接触可能会有失败操作的复杂程序了，这也意味着接下来是一个了解错误处理的绝佳时机！</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 09.00:错误处理</title>
    <url>/2023/05/18/rust_docs/ch_09_00_error_handing/</url>
    <content><![CDATA[<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在软件中错误是很常见的事实。当有时候软件运行错误的时候，Rust有很多处理这些场景的特性。在很多情况下，Rust要求你确认每一个错误发生的可能，并在代码编译前就采取相应的行为。这个必要前提会让你的程序更加健壮：确保你会提前发现错误，并处理得当，在你将代码部署到生产环境之前。</p>
<p>Rust将错误分为两大类：<strong>可恢复的</strong>(<code>recoverable</code>)和<strong>不可恢复的</strong>(<code>unrecoverable</code>)。对于可恢复错误，比如文件未找打错误，我们很可能只是想向用户报告问题并重试操作。不可恢复错误总是系统性bugs，像尝试访问一个超过数组最尾端的位置，此时，我们就会想要程序立刻停止运行。</p>
<p>大多数编程语言无法区分这两种错误，并且都使用同样的方式，使用如exceptions机制。Rust没有exceptions。而是有一个<code>Result&lt;T, E&gt;</code>的类型来处理可恢复错误。另外，当程序发生一个不可恢复的错误，Rust用<code>panic!</code>宏来中止运行程序。</p>
<p>这一章，首次讨论<code>panic!宏</code>，然后讨论有关<code>Result&lt;T, E&gt;</code>返回的值。</p>
<p>另外，我们还要探索如何决定一个错误应该是恢复或者是停止运行。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 09.01:使用`panic!`的backtrace</title>
    <url>/2023/05/18/rust_docs/ch_09_01_unrecoverable_errors_with_panic/</url>
    <content><![CDATA[<h4 id="使用panic-的backtrace"><a href="#使用panic-的backtrace" class="headerlink" title="使用panic!的backtrace"></a>使用<code>panic!</code>的backtrace</h4><p>让我们来看看另外一个例子，当因为我们自己的代码有bug而导致库函数调用<code>panic!</code>是什么样的。如Listing 9-1所示的代码尝试访问超出范围的vector的索引。</p>
<p>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 9-1: Attempting to access an element beyond the end of a vector, which will cause a call to <code>panic!</code></p>
<p>这里，我们尝试去访问第100个元素(索引99就是第100个元素，索引是从0开始的)，但是vector只有3个元素，肯定会报错。在这个场景中，Rust就会panic。使用<code>[]</code>就是企图返回一个元素，但是你传入一个无效的索引，又不会有这个元素，Rust就肯定不会返回正确的结果。</p>
<p>在C语言中，尝试读取数据结构之后的值是未定义行为(undefined behavior)。你可能会得到一个这个位置的对应的值，但是这个可能是任何的值，但就不是你想要访问的值，因为这个位置的值不属于你想要访问的数据结构范围的值。这个被叫做**缓冲区溢出(buffer overread)**，并且可能会导致安全漏洞，比如攻击者可以像这样操作索引来读取存储在数据结构之后不被允许访问的数据。</p>
<p>为了防止这种漏洞，如果尝试读取一个索引不存在的元素，Rust会停止执行并拒绝继续。尝试运行上面的程序会出现如下的错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling panic v0.<span class="number">1.0</span> (file:<span class="comment">///projects/panic)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.27</span>s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">99</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>

<p>上面的错误信息指出错误发生在<code>src/main.rs</code>文件的第4行第5个字符，我们尝试访问索引为99的元素。接着一行的信息告诉我们可以设置<code>RUST_BACKTRACE</code>环境变量来获取backtrace查看发生了什么错误。一个backtrace是一个已经被调用直到当前这一个点的所有的函数列表。Backtrace在Rust的工作原理和其他语言一样：阅读backtrace的关键是从头开始读一直到发现你编写的代码；往下则是你调用的代码。这些行可能包含核心Rust代码，标准库代码或用到的crate代码。让我们设置<code>RUST_BACKTRACE</code>环境变量在Listing 9-2中看看都输出了些什么：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ RUST_BACKTRACE=<span class="number">1</span> cargo run</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">99</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">stack backtrace:</span><br><span class="line">   <span class="number">0</span>: rust_begin_unwind</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:<span class="number">584</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">1</span>: core::panicking::panic_fmt</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:<span class="number">142</span>:<span class="number">14</span></span><br><span class="line">   <span class="number">2</span>: core::panicking::panic_bounds_check</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:<span class="number">84</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">3</span>: &lt;<span class="type">usize</span> <span class="keyword">as</span> core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:<span class="number">242</span>:<span class="number">10</span></span><br><span class="line">   <span class="number">4</span>: core::slice::index::&lt;<span class="keyword">impl</span> <span class="title class_">core</span>::ops::index::Index&lt;I&gt; <span class="keyword">for</span> [T]&gt;::index</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:<span class="number">18</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">5</span>: &lt;alloc::vec::<span class="type">Vec</span>&lt;T,A&gt; <span class="keyword">as</span> core::ops::index::Index&lt;I&gt;&gt;::index</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/<span class="keyword">mod</span>.rs:<span class="number">2591</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">6</span>: panic::main</span><br><span class="line">             at ./src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">7</span>: core::ops::function::<span class="built_in">FnOnce</span>::call_once</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:<span class="number">248</span>:<span class="number">5</span></span><br><span class="line">note: <span class="literal">Some</span> details are omitted, run with `RUST_BACKTRACE=full` <span class="keyword">for</span> <span class="title class_">a</span> verbose backtrace.</span><br></pre></td></tr></table></figure>

<p>Listing 9-2: The backtrace generated by a <code>panic!</code>displayed when the environment variable <code>RUST_BACKTRACE</code>is set</p>
<p>真是输出了一大坨啊！操作系统不同，Rust版本不同，你看到的输出可能会有所不同。为了使用这些信息进行回溯，必须启用debug模式。默认就是debug模式，只要在<code>cargo build</code>或者<code>cargo run</code>之后不要加<code>--release</code>参数。</p>
<p>在Listing 9-2的第6行的backtrace指出了我们项目造成的问题：<code>src/main.rs</code>的第4行。如果我们不想我们的程序panic，我们就应该开始检查定位到第一行我们自己写的代码。在Listing 9-1中，我们故意写了造成panic的代码，修复这个panic就是不要去访问超出vector范围的索引。当你的代码在将来panic， 你需要弄清楚代码使用什么数据做了什么样的操作，以及正确情况下代码应该做什么。</p>
<p>本章后面的小节 <a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">“To <code>panic!</code> Or not to <code>panic!</code>“</a> 部分讲回<code>panic!</code>，详细讲解应该或者不应该用<code>panic!</code>来处理错误情况。接下来一节我们来讲解如何使用<code>Result</code>恢复一个错误。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 09.02:带有结果的可恢复错误</title>
    <url>/2023/10/18/rust_docs/ch_09_02_recoverable_errors_with_result/</url>
    <content><![CDATA[<h3 id="带有结果的可恢复错误"><a href="#带有结果的可恢复错误" class="headerlink" title="带有结果的可恢复错误"></a>带有结果的可恢复错误</h3><p>大多数错误并不严重到需要程序完全停止。有时，当一个函数失败时，其原因可以很容易地解释和响应。例如，如果您尝试打开一个文件，但由于该文件不存在而导致该操作失败，那么您可能希望创建该文件，而不是终止该进程。</p>
<p>回到第二章<code>Result</code>的枚举定义里，有两个成员，<code>Ok</code> 和<code>Err</code>,如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>T</code>和<code>E</code>是泛型参数：我们将在第十章详细讨论。目前你需要知道当成功时返回枚举成员<code>Ok</code>，当失败时返回枚举成员<code>Err</code>。由于<code>Result</code>具有这些泛型类型参数，因此我们可以在许多不同的情况下使用<code>Result</code>类型及其上定义的函数，其中我们希望返回的成功值和错误值可能不同。</p>
<p>我们来调用一个返回值类型为<code>Result</code>的函数，因为调用可能会失败。如Listing 9-3我们尝试打开一个文件。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">opend</span>(<span class="string">&quot;hello.txt);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Listing 9-3 Openging a file</p>
<p><code>File::open</code>的返回值是一个<code>Result&lt;T, E&gt;</code>。泛型参数<code>T</code>已经被<code>File::open</code>实现，并填入了成功的值，<code>std::fs::File</code>是一个文件句柄(file handle)。类型<code>E</code>的错误值是<code>std::io::Error</code>。<code>File::open</code>返回类型意思是如果成功就会返回一个文件句柄，并且可以进行读写。这个函数也有可能会调用失败：例如，文件不存在，或者没有权限访问。<code>File::open</code>函数需要有个方式告诉我们是成功或者失败，同时返回给我们文件句柄或者错误信息。这个信息正是Result枚举所传达的。</p>
<p>因此，当<code>File::open</code>调用成功，变量<code>greeting_file_result</code>的值将会是成员<code>Ok</code>并包含一个文件句柄。如果失败，<code>greeting_file_result</code>就是一个<code>Err</code>的实例并包含更多错误信息来展示到底发生了什么错误。</p>
<p>我们需要在Listing9-3中根据<code>File::open</code>的返回值来添加额外的代码。如Listing9-4中所示，这是一个基本的<code>Result</code>的处理工具，就是使用<code>match</code>表达式（我们已经在第六章中讲过了）。<br>Filename:src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-4: Using a match expression to handle the <code>Result</code> variants that might be returned</p>
<p>请注意，与Option enum一样，<code>Result</code>枚举及其成员也通过prelude进入了作用域，因此我们不需要在匹配分支中的Ok和Err成员之前指定<code>Result::</code>。</p>
<p>当结果为<code>Ok</code>时，这段代码将返回<code>Ok</code>中的<code>file</code>，然后我们将该文件句柄值赋给变量<code>greeting_file</code>。在<code>match</code>之后，我们可以使用文件句柄进行读写了。<br><code>match</code>的另外一个分支就会从<code>File::open</code>中得到一个<code>Err</code>的值。在这个示例中，我们现在调用<code>panic!</code>宏(macro)。如果没有一个叫<code>hello.txt</code>的文件在当前文件夹，并且运行了这段代码，我们就会看到如下来自<code>panic!</code>宏的错误输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling error-handling v0.1.0 (file:///projects/error-handling)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.73s</span><br><span class="line">     Running `target/debug/error-handling`</span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;Problem opening the file: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;, src/main.rs:8:23</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>
<p>像往常一样，这个输出告诉我们哪里出了问题。</p>
<h4 id="匹配不同的错误-Matching-on-Different-Errors"><a href="#匹配不同的错误-Matching-on-Different-Errors" class="headerlink" title="匹配不同的错误(Matching on Different Errors)"></a>匹配不同的错误(Matching on Different Errors)</h4><p>Listing9-4无论<code>File::open</code>因为什么失败都会报<code>pannic!</code>错误。然而，我们希望针对不同的失败原因采取不同的行动：如果<code>File::open</code>失败是因为文件不存在，我们想创建一个文件并返回新文件的句柄。如果<code>File::open</code>失败是因为其他原因–比如，因为我们没有打开文件的权限–我们仍然和Listing9-4一样<code>panic!</code>。为此，我们在<code>match</code>内添加一个内部表达式，如Listing 9-5所示。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs:File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-5: Handling different kinds of errors in different ways</p>
<p><code>File::open</code>内部返回的<code>Err</code>的值<code>io::Error</code>，它是标准库提供的数据结构。这个数据结构有一个<code>kind</code>方法可以得到一个<code>io::ErrorKind</code>的值。枚举<code>io::ErrorKind</code>是标准库提供的，并且有不同类型的错误都对应着相应的io操作。我们使用的<code>ErrorKing::NotFound</code>枚举成员表明我们尝试打开一个不存在的文件。所以我们在<code>greeting_file_result</code>上匹配，但我们也在error.kind()上进行内部匹配。</p>
<p>我们希望在内部匹配中检查的条件是<code>error.kind()</code>返回的值是否为<code>ErrorKind</code>枚举的<code>NotFound</code>成员。如果是我，我们将尝试通过<code>File::create</code>创建文件，然而我们创建文件也有可能失败，在<code>match</code>内部我们需要第二个分支来处理。当文件不能创建，一个不同的错误就会被打印。<code>match</code>外部保持不变。因此，除文件不存在的情况之外都会报错。</p>
<h4 id="失败时-panic-的简写-unwrap-和-expect"><a href="#失败时-panic-的简写-unwrap-和-expect" class="headerlink" title="失败时 panic 的简写: unwrap 和 expect"></a>失败时 panic 的简写: unwrap 和 expect</h4><p><code>match</code> 已经很好用了，不过它可能有点冗长并且不总是能很好的表明其意图。<code>Result&lt;T, E&gt;</code> 类型定义了很多辅助方法来处理各种情况。其中之一叫做 <code>unwrap</code>，它的实现就类似于Listing 9-4 中的 <code>match</code> 语句。如果 <code>Result</code> 值是成员 <code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值。如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code>。这里是一个实践 <code>unwrap</code> 的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs:File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们运行这段代码，并且<code>hello.txt</code>文件不存在，我们就会看到一个错误信息来自<code>unwrap</code>方法调用了<code>panic!</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;called `Result::unwrap()` on an `Err` value: Os &#123;</span><br><span class="line">code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;,</span><br><span class="line">src/main.rs:4:49</span><br></pre></td></tr></table></figure>
<p>同样，<code>expect</code>方法也可以自定义<code>panic!</code>的错误信息。使用<code>expect</code>而不是<code>unwrap</code>并提供友好的错误信息可以传达您的意图，并使跟踪<code>panic!</code>的来源更容易。<code>expect</code>的语法如下所示：<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs:File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;hello.txt should be included int this project&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以和使用<code>unwrap</code>一样使用<code>expect</code>来返回一个文件句柄或者调用<code>panic!</code>。错误信息通过<code>expect</code>调用<code>panic!</code>时传递，而不是<code>panic!</code>默认的错误信息，展示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;hello.txt should be included in this project: Os &#123;</span><br><span class="line">code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;,</span><br><span class="line">src/main.rs:5:10</span><br></pre></td></tr></table></figure>
<h4 id="传递错误-Propagating-Errors"><a href="#传递错误-Propagating-Errors" class="headerlink" title="传递错误(Propagating Errors)"></a>传递错误(Propagating Errors)</h4><p>当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 传播（propagating）错误，这样能更好的控制代码调用，因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误。<br>例如：Listing 9-6所示，一个函数读一个文件。如果文件不存在或者不能读，函数就会返回一些错误。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">usename_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">usename_file</span> = <span class="keyword">match</span> username_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> user_file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(username),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">read_username_from_file</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-6: A function that returns errors to the calling code using <code>match</code></p>
<p>这个函数可以用更短的方式编写，但我们将从手动做很多事情开始，以探索错误处理;最后，我们将展示较短的方法。我们先看一下函数的返回类型：<code> Result&lt;String, io::Error&gt;</code> 。这意味着该函数返回一个类型的 <code>Result&lt;T, E&gt;</code> 值，其中泛型参数 <code>T</code> 已用具体类型填充，泛型类型已用具体类型 <code>String</code>填充，<code>E</code>用<code>io::Error</code>填充。</p>
<p>如果此函数成功且没有任何问题，则调用此函数的代码将收到一个<code>Ok</code>值，该值包含<code>String</code>此函数从文件中读取的username。如果此函数遇到任何问题，调用代码将收到一个 <code>Err</code> 值，该值包含包含有关问题所在的详细信息的实例 <code>io::Error</code> 。我们选择 <code>io::Error</code> 此函数的返回类型，因为这恰好是我们在此函数主体中调用的两个操作返回的错误值的类型： <code>File::open</code> 函数和 <code>read_to_string</code> 方法。</p>
<p>函数的主体从调用 <code>File::open</code> 函数开始。然后我们用类似于Listing 9-4 <code>match</code> 中的值来处理 <code>match</code> 该 <code>Result</code> 值。如果成功，模式 <code>File::open</code> 变量中的文件句柄将成为可变变量 <code>username_file</code> 中的值，函数将继续。在这种情况下 <code>Err</code> ，我们不是调用，而是使用 <code>return</code> 关键字提前完全返回函数，并从<code>File::open</code>返回的错误传递出去，模式匹配中的<code>e</code>作为该函数的错误值传递回调用 panic! 代码。</p>
<p>因此，如果我们在<code>username_file</code>中有一个文件句柄，那么该函数将在变量<code>username</code>中创建一个新的<code>String</code>，并调用<code>username_file</code>中文件句柄上的<code>read_to_string</code>方法来将文件的内容读入<code>username</code>。<code>read_to_string</code>方法也返回<code>Result</code>，因为它可能失败，即使<code>File::open</code>打开文件成功，读文件也有可能失败。所以我们需要另一个匹配来处理这个<code>Result</code>:如果<code>read_to_string</code>成功，那么我们的函数就成功了，我们从文件中返回username，这个username现在被<code>Ok</code>封装在<code>username</code>中。如果<code>read_to_string</code>操作失败，返回错误值的方式与处理<code>File::open</code>返回值的匹配中返回错误值的方式相同。然而，我们不需要显式<code>return</code>，因为这是函数中的最后一个表达式。</p>
<p>然后，调用该代码的代码将处理获取包含<code>username</code>的<code>Ok</code>值或包含<code>io::Error</code>的<code>Err</code>值。由调用代码决定如何处理这些值。如果调用代码得到一个<code>Err</code>值，它可能会调用<code>panic!</code>并使程序崩溃，使用默认username，或者从文件以外的其他地方查找username。我们没有足够的信息来了解调用代码实际尝试做什么，所以我们向上传播所有成功或错误信息，以便它正确处理。</p>
<p>这种传播错误的模式在Rust中非常常见，因此Rust为了方便起见提供了问号操作符<code>?</code>。</p>
<h4 id="传播错误的快捷方式-操作符"><a href="#传播错误的快捷方式-操作符" class="headerlink" title="传播错误的快捷方式:?操作符"></a>传播错误的快捷方式:<code>?</code>操作符</h4><p>如Listing9-7所示，实现了一个和Listing9-6相同的<code>read_username_from_file</code>的函数，但是使用了<code>?</code>操作来实现。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    username_file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(username)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-7: A function that returns errors to the calling code using the &#96;?&#96;&#96; operator</p>
<p><code>?</code>操作符放置在<code>Result</code>值之后，其工作方式与Listing 9-6中为处理<code>Result</code>值而定义的匹配表达式几乎相同。如果<code>Result</code>的值为<code>Ok</code>，则该表达式将返回<code>Ok</code>中的值，程序将继续执行。如果该值为<code>Err</code>，则整个函数将返回<code>Err</code>，就像我们使用了<code>return</code>关键字一样，因此错误值将传播到调用代码。</p>
<p>Listing 9-6中的匹配表达式的作用与<code>?</code>操作符所做的事情:错误值有<code>?</code>在标准库中的<code>From</code>trait中定义了from函数，该函数用于将值从一种类型转换为另一种类型。什么时候<code>?</code>操作符调用<code>from</code>函数，接收到的错误类型被转换为当前函数返回类型中定义的错误类型。当函数返回一种错误类型来表示函数可能失败的所有方式时，即使部分可能因许多不同的方式而失败，这也是有用的。</p>
<p>例如，我们可以修改Listing 9-7中的<code>read_username_from_file</code>函数，使其返回一个自定义的错误类型<code>OurError</code>。如果我们还为<code>OurError</code>定义<code>impl From&lt;io::Error&gt;</code>，从<code>io::Error</code>构造<code>OurError</code>的实例，那么<code>?</code>操作符会在<code>read_username_from_file</code>函数体中将调用<code>from</code>并转换错误类型，而无需向函数中添加任何代码。</p>
<p>在Listing 9-7的上下文中，<code>?</code>在<code>File::open</code>调用的末尾将把<code>Ok</code>中的值返回给变量<code>username_file</code>。如果发生错误，<code>?</code>操作符将提前返回，并向调用代码提供任何<code>Err</code>值。同样的道理也适用于<code>?</code>在<code>read_to_string</code>调用结束时。</p>
<p><code>?</code>操作符消除了大量的模板代码，使这个函数的实现更简单。我们甚至可以通过在<code>?</code>之后立即连接方法调用来进一步缩短代码，如Listing 9-8所示。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(username)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-8: Chaining method calls after the <code>?</code> operator</p>
<p>我们将<code>username</code>中<code>String</code>的创建移到了函数的开头;这一点没有改变。我们没有创建一个可变的用户名文件，而是将<code>read_to_string</code>调用直接连接到<code>file::open(&quot;hello.txt&quot;)</code>的结果上。我们还有<code>?</code>当<code>File::open</code>和<code>read_to_string</code>都成功时，我们仍然返回一个包含<code>username</code>的<code>Ok</code>值，而不是返回错误。功能与Listing 9-6和Listing 9-7相同;这是一种不同的，更符合工程学的写法。</p>
<p>Listing 9-9 所示使用了<code>fs::read_to_string</code>将使代码更加简短。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-9: Using <code>fs::read_to_string</code> instead of opening and then reading the file</p>
<p>将文件读入字符串是一种相当常见的操作，因此标准库提供了方便的<code>fs::read_to_string</code>函数，该函数打开文件，创建一个新的<code>String</code>，读取文件的内容，将内容放入该<code>String</code>，并返回它。当然，使用<code>fs::read_to_string</code>并不能让我们有机会解释所有的错误处理，所以我们先用更长的方法来解释。</p>
<h4 id="哪里可以使用-操作"><a href="#哪里可以使用-操作" class="headerlink" title="哪里可以使用?操作"></a>哪里可以使用<code>?</code>操作</h4><p><code>?</code>操作符只能用于返回类型与<code>?</code>操作符兼容的函数中。这是因为<code>?</code>操作符的定义是执行从函数中提前返回一个值，方式与Listing 9-6中定义的<code>match</code>表达式相同。在Listing 9-6中，匹配使用一个<code>Result</code>值，而提前返回臂返回一个<code>Err(e)</code>值。函数的返回类型必须是<code>Result</code>，以便与此返回兼容。</p>
<p>在Listing 9-10中，让我们看看如果使用<code>?</code>返回类型与我们使用的值的类型不兼容的主函数中的操作符<code>?</code>:<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-10: Attempting to use the <code>?</code> in the <code>main</code> function that returns &#96;()&#96;&#96; won’t compile</p>
<p>这段代码打开一个文件，可能会失败。<code>?</code>操作符在<code>File::open</code>返回的<code>Result</code>值之后，但是这个主函数的返回类型是<code>()</code>，而不是<code>Result</code>。当我们编译这段代码时，会得到以下错误消息:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling error-handling v0.1.0 (file:///projects/error-handling)</span><br><span class="line">error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:4:48</span></span><br><span class="line">  |</span><br><span class="line">3 | fn main() &#123;</span><br><span class="line">  | --------- this function should return `Result` or `Option` to accept `?`</span><br><span class="line">4 |     let greeting_file = File::open(&quot;hello.txt&quot;)?;</span><br><span class="line">  |                                                ^ cannot use the `?` operator in a function that returns `()`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `error-handling` due to previous error</span><br></pre></td></tr></table></figure>
<p>这个错误指出我们只允许使用<code>?</code>返回<code>Result</code>、<code>Option</code>或其他实现<code>FromResidual</code>的类型的函数中的操作符。</p>
<p>要修复这个错误，您有两种选择。一种选择是更改函数的返回类型，使其与使用的值兼容。只要没有限制，就继续操作。另一种技术是使用<code>match</code>或<code>Result&lt;T, E&gt;</code>方法之一，以任何合适的方式处理<code>Result&lt;T, E&gt;</code>。</p>
<p>错误信息中还提到<code>?</code>也可以与<code>Option&lt;T&gt;</code>值一起使用。就像使用<code>?</code>在<code>Result</code>中，您只能使用<code>?</code>在返回一个<code>Option</code>的函数中使用<code>Option</code>。<code>?</code>操作符在<code>Option&lt;T&gt;</code>上调用时的行为与在<code>Result&lt;T, E&gt;</code>上调用时的行为相似:如果值为<code>None</code>，则在该点将提前从函数返回<code>None</code>。如果值是<code>Some</code>，则<code>Some</code>中的值是表达式的结果值，函数继续执行。Listing 9-11给出了一个函数示例，该函数查找给定格式中第一行的最后一个字符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">last_char_of_first_line</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">char</span>&gt; &#123;</span><br><span class="line">    text.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">next</span>()?.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">last</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="title function_ invoke__">last_char_of_first_line</span>(<span class="string">&quot;Hello, world\nHow are you today?&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">last_char_of_first_line</span>(<span class="string">&quot;&quot;</span>), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">last_char_of_first_line</span>(<span class="string">&quot;\nhi&quot;</span>), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-11: Using the <code>?</code> operator on an <code>Option&lt;T&gt;</code> value</p>
<p>这个函数返回<code>Option&lt;char&gt;</code>，因为有可能有字符，但也有可能没有。这段代码接受<code>text</code>字符串切片参数并对其调用<code>lines</code>方法，该方法返回一个遍历字符串中的行的迭代器。因为这个函数想要检查第一行，所以它在迭代器上调用<code>next</code>以从迭代器中获取第一个值。如果<code>text</code>是空字符串，对<code>next</code>的调用将返回<code>None</code>，在这种情况下我们使用<code>?</code>停止并从第一行的最后一个字符返回<code>None</code>。如果<code>text</code>不是空字符串，<code>next</code>将返回一个<code>Some</code>值, 其中包含<code>text</code>中第一行的字符串切片。</p>
<p><code>?</code>操作符提取字符串切片，然后调用该字符串切片上的<code>chars</code>来获取其字符的迭代器。我们对第一行的最后一个字符感兴趣，因此调用<code>last</code>来返回迭代器中的最后一项。这是一个选项，因为第一行可能是空字符串，例如，如果文本以空行开头，但在其他行上有字符，如<code>“\nhi”</code>。但是，如果第一行有最后一个字符，它将在<code>Some</code>变体中返回。<code>?</code>运算符在中间给了我们一种简洁的方式来表达这个逻辑，允许我们实现</p>
<p>注意，您可以使用<code>?</code>操作符对返回<code>Result</code>的函数中的<code>Result</code>进行操作，您可以使用?操作符在返回<code>Option</code>的函数中对<code>Option</code>进行操作，但不能混合匹配。<code>?</code>操作符不会自动将<code>Result</code>转换为<code>Option</code>，反之亦然;在这些情况下，您可以使用诸如<code>Result</code>上的<code>ok</code>方法或<code>Option</code>上的<code>ok_or</code>方法来显式地进行转换。</p>
<p>到目前为止，我们使用的所有主要函数都是<code>return()</code>。<code>main</code>函数的特殊之处在于它是可执行程序的入口和出口点，它的返回类型是有限制的，这样程序才能按照预期的方式运行。</p>
<p>幸运的是，<code>main</code>也可以返回<code>Result&lt;()， E&gt;</code>。Listing 9-12拥有Listing 9-10的代码，但我们将<code>main</code>的返回类型更改为<code>Result&lt;()</code>， <code>Box&lt;dyn Error&gt;&gt;</code>，并在末尾添加返回值<code>Ok(())</code>。这段代码现在可以编译了:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-12: Changing main to return <code>Result&lt;(), E&gt;</code> allows the use of the <code>?</code> operator on <code>Result</code> values</p>
<p><code>Box&lt;dyn Error&gt;</code>类型是一个<code>trait</code>对象，我们将在第17章使用允许不同类型值的<code>trait</code>对象一节中讨论它。现在，您可以读取<code>Box&lt;dyn Error&gt;</code>来表示任何类型的错误。使用<code>?</code>允许在错误类型为<code>Box&lt;dyn error &gt;</code>的主函数中返回<code>Result</code>值，因为它允许提前返回任何<code>Err</code>值。即使这个主函数的主体只会返回<code>std::io::Error</code>类型的错误，通过指定<code>Box&lt;dyn Error&gt;</code>，即使将返回其他错误的更多代码添加到main的主体中，该签名仍然是正确的。</p>
<p>当<code>main</code>函数返回<code>Result&lt;()， E&gt;</code>时，如果<code>main</code>函数返回<code>Ok(())</code>，可执行程序将以<code>0</code>的值退出;如果<code>main</code>函数返回<code>Err</code>值，可执行程序将以非<code>0</code>的值退出。用C编写的可执行程序在退出时返回整数:成功退出的程序返回整数<code>0</code>，出错的程序返回非0的整数。Rust还从可执行文件返回整数，以与此约定兼容。</p>
<p>main函数可以返回任何实现<code>std::process::Termination</code> trait的类型，它包含一个可以返回<code>ExitCode</code>的函数<code>report</code>。有关为您自己的类型实现<code>Termination</code>特性的更多信息，请参阅标准库文档。</p>
<p>到现在，我们已经详细讨论了调用<code>panic!</code>或者返回<code>Result</code>。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么看到别人过得好，我就心里好难受呢？</title>
    <url>/2023/08/18/rust_docs/why/</url>
    <content><![CDATA[<h3 id="为什么看到别人过得好，我就心里好难受呢？"><a href="#为什么看到别人过得好，我就心里好难受呢？" class="headerlink" title="为什么看到别人过得好，我就心里好难受呢？"></a>为什么看到别人过得好，我就心里好难受呢？</h3><p>早上刚来到公司，一个深圳有房，长得高又帅，身价已然超过95%深圳人的同事发出这样的灵魂拷问：为什么看到别人过得好，我就心里好难受呢？</p>
<h4 id="来看看AI如何看待："><a href="#来看看AI如何看待：" class="headerlink" title="来看看AI如何看待："></a>来看看AI如何看待：</h4><blockquote>
<p>根据你的描述,你已经达到了生活物质上很高的满足度,拥有自己的房产,生活质量远超过大多数人。但即便如此,看见别人过得很好,你还是会感到心理难受。这主要还是出于以下几个原因:</p>
<ol>
<li>心理比较并不会随着物质生活的提高而消失。人们的社会比较心理往往与生活状态相关不大,更加源自内在的不安全感。所以即便生活质量很高,这种比较心理仍然存在。</li>
<li>你可能理想化别人拥有的东西。比如羡慕别人拥有的人际关系,职业成就,生活状态等,而忽视了自己已经拥有的很多东西。这也会带来难受的感觉。</li>
<li>你期望得到的不仅是物质生活。人的内心渴望往往不仅限于物质层面,也包括精神层面,如获得认同,建立亲密关系,实现自我价值等。如果这些方面没有得到满足,也会感到心理上的难受。</li>
<li>你可能在某些方面感到不满意。尽管生活总体质量很高,但在情感生活,人际交往,事业发展等某一具体方面,你可能还是感到不如意或不足,这也是产生难受心理的原因之一。<br>所以,要解决这个问题,重点不在于提高生活质量,而是要在心理和精神层面获得安定。学会理性看待他人,不必过度羡慕别人所拥有的一切。关注自己的内心真实需求,努力在各个方面获得满足和进步。培养自己独立稳定的心态,增强自我价值感。这些可以有效地帮助你摆脱这种由社会比较所带来的难受情绪。</li>
</ol>
</blockquote>
<p>根据我党的判断，我们现在仍处于社会主义初级阶段，现阶段中国社会的主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。也是涵盖了上述矛盾心理内涵的。近些年，特别是改革开放之后，中国高速发展，让一部分人抓住了高速发展的红利，以不匹配自己能力增长的速度拥有了超速增长的财富和资产。即身心发展和财富发展并不平衡，导致了内心不够充盈，格局尚未完全打开，自我定位错乱。矛盾逐渐凸显扭曲就会发生这样莫名奇怪的心理。</p>
<p>实际上，在深圳这种高度发达，贫富差距巨大的快节奏生活的城市，大部分年轻人都特别焦虑，焦虑的本质就是日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。大部分年轻人都是来自外地十八线小城市或者小县城，或者农村。回不去，留不下随着时间的推移，越来越焦虑。这部分人特别像小资产阶级的表现：</p>
<blockquote>
<p>作为劳动者，在思想上倾向于无产阶级，作为私有者，又倾向于资产阶级，极易受资产阶级思想的影响。因此，在反对封建主义的斗争中既具有革命性，同时也存在政治上的动摇性、斗争中的软弱性和革命的不彻底性。</p>
</blockquote>
<p>让我想起了抓猴子的故事里伸手进树洞紧紧抓住坚果，即使猎人来了也舍不得放手。这个猴子是我们每个人。</p>
<p>对于这种外因短时间无法改变的问题，我们只能改变内因了。看看AI又会给出什么样的建议呢？</p>
<blockquote>
<p>这里有些简单实用的建议可以帮助你摆脱由社会比较带来的难受心理:</p>
<ol>
<li>转移注意力。当你开始羡慕别人或感到自卑时,立即转移注意力,不要过多聚焦在别人身上。可以换个环境,做点运动,转而关注自己喜欢的事物。这可以有效地改变心情。</li>
<li>记录自己的收获。时常记录自己生活中已经实现的小成就和收获,提醒自己生活的美好之处。这可以建立信心,也让你意识到自己已经拥有很多。</li>
<li>限制社交媒体使用。社交媒体上人们主要分享生活的美好时刻,这会助长羡慕心理。适当限制使用社交媒体,关注生活中真实的一面。</li>
<li>珍惜你所拥有的。时常想想你已经拥有但当作理所当然的东西,会让你觉得很满足和幸运。这可以避免过度关注别人拥有的。</li>
<li>关注自己的需求。理解自己真正想要什么,并努力实现,这可以让你没有时间和精力过度关注别人,也会让你感到人生有目标和意义。</li>
<li>施比受更有福。当你羡慕别人时,想想你能为别人带来什么好处。关注别人的需求,提供帮助,这可以让你转移注意力,也会带来成就感。</li>
<li>培养内在安定。通过冥想,听音乐,上瑜伽课等方式,培养安定的心态。当内心足够安定,外界的比较就不会那么轻易影响你。<br>这些实用的方法,帮助调节心态,关注自我,减少对他人生活的过度比较,可以有效地让你摆脱社会比较带来的难受情绪。需要时间去实践,但效果会非常显著。</li>
</ol>
</blockquote>
<p>这些方法对我都很有启发，对与解决自身的焦虑也很受用。生活在快节奏的深圳，周围人都是狠角色，焦虑对每个人来说是常态。人生的各个阶段也会有不同的焦虑，只有学会面对焦虑，利用焦虑，焦虑也可以是人类进步的助推器。加油吧，少年郎！</p>
]]></content>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>计算边长200以内的直角三角形有那些？</title>
    <url>/2024/04/29/algorithm/algorithm_count_right-angled-triangles/</url>
    <content><![CDATA[<h1 id="计算边长200以内的直角三角形有那些？用python，java，go，rust，haskell，c，c-实现"><a href="#计算边长200以内的直角三角形有那些？用python，java，go，rust，haskell，c，c-实现" class="headerlink" title="计算边长200以内的直角三角形有那些？用python，java，go，rust，haskell，c，c++实现"></a>计算边长200以内的直角三角形有那些？用python，java，go，rust，haskell，c，c++实现</h1><p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_right_triangles</span>(<span class="params">max_side</span>):</span><br><span class="line">    triangles = []</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_side + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(a, max_side + <span class="number">1</span>):</span><br><span class="line">            c = <span class="built_in">int</span>(math.sqrt(a**<span class="number">2</span> + b**<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> c &lt;= max_side <span class="keyword">and</span> a**<span class="number">2</span> + b**<span class="number">2</span> == c**<span class="number">2</span>:</span><br><span class="line">                triangles.append((a, b, c))</span><br><span class="line">    <span class="keyword">return</span> triangles</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(find_right_triangles(<span class="number">200</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RightTriangles</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="type">int</span>[]&gt; findRightTriangles(<span class="type">int</span> maxSide) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; triangles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= maxSide; a++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a; b &lt;= maxSide; b++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">int</span>) Math.sqrt(a * a + b * b);</span><br><span class="line">                <span class="keyword">if</span> (c &lt;= maxSide &amp;&amp; a * a + b * b == c * c) &#123;</span><br><span class="line">                    triangles.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;a, b, c&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(findRightTriangles(<span class="number">200</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRightTriangles</span><span class="params">(maxSide <span class="type">int</span>)</span></span> [][<span class="number">3</span>]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> triangles [][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= maxSide; a++ &#123;</span><br><span class="line">        <span class="keyword">for</span> b := a; b &lt;= maxSide; b++ &#123;</span><br><span class="line">            c := <span class="type">int</span>(math.Sqrt(<span class="type">float64</span>(a*a + b*b)))</span><br><span class="line">            <span class="keyword">if</span> c &lt;= maxSide &amp;&amp; a*a+b*b == c*c &#123;</span><br><span class="line">                triangles = <span class="built_in">append</span>(triangles, [<span class="number">3</span>]<span class="type">int</span>&#123;a, b, c&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> triangles</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(findRightTriangles(<span class="number">200</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_right_triangles</span>(max_side: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> HashSet&lt;(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">triangles</span>: HashSet&lt;(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>)&gt; = HashSet::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">a</span> <span class="keyword">in</span> <span class="number">1</span>..=max_side &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> a..=max_side &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">c_f</span> = (a <span class="keyword">as</span> <span class="type">f64</span>).<span class="title function_ invoke__">powf</span>(<span class="number">2.0</span>) + (b <span class="keyword">as</span> <span class="type">f64</span>).<span class="title function_ invoke__">powf</span>(<span class="number">2.0</span>);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">c</span> = c_f.<span class="title function_ invoke__">sqrt</span>() <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line">            <span class="keyword">if</span> c &lt;= max_side &amp;&amp; a * a + b * b == c * c &#123;</span><br><span class="line">                triangles.<span class="title function_ invoke__">insert</span>((a, b, c));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    triangles</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">find_right_triangles</span>(<span class="number">200</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Haskell:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Set (<span class="title">fromList</span>, <span class="title">toList</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Tuple (<span class="title">swap</span>)</span><br><span class="line"><span class="keyword">import</span> Data.List (<span class="title">nub</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Function (<span class="title">on</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Ord (<span class="title">comparing</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">findRightTriangles</span> :: <span class="type">Int</span> -&gt; [(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)]</span><br><span class="line"><span class="title">findRightTriangles</span> maxSide = nub . toList $ fromList [(a, b, c) | a &lt;- [<span class="number">1</span>..maxSide], b &lt;- [a..maxSide], <span class="keyword">let</span> c = round $ sqrt $ fromIntegral $ a^<span class="number">2</span> + b^<span class="number">2</span>, c &lt;= maxSide, a^<span class="number">2</span> + b^<span class="number">2</span> == c^<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print $ findRightTriangles <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>C:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">findRightTriangles</span><span class="params">(<span class="type">int</span> maxSide, <span class="type">int</span> (*triangles)[<span class="number">3</span>], <span class="type">int</span> *count)</span> &#123;</span><br><span class="line">    *count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= maxSide; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = a; b &lt;= maxSide; b++) &#123;</span><br><span class="line">            <span class="type">int</span> c = (<span class="type">int</span>)<span class="built_in">sqrt</span>(a * a + b * b);</span><br><span class="line">            <span class="keyword">if</span> (c &lt;= maxSide &amp;&amp; a * a + b * b == c * c) &#123;</span><br><span class="line">                triangles[*count][<span class="number">0</span>] = a;</span><br><span class="line">                triangles[*count][<span class="number">1</span>] = b;</span><br><span class="line">                triangles[*count][<span class="number">2</span>] = c;</span><br><span class="line">                (*count)++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> triangles[<span class="number">1000</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    findRightTriangles(<span class="number">200</span>, triangles, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d, %d)\n&quot;</span>, triangles[i][<span class="number">0</span>], triangles[i][<span class="number">1</span>], triangles[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findRightTriangles</span>(<span class="type">int</span> maxSide) &#123;</span><br><span class="line">    std::set&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; triangles;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= maxSide; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = a; b &lt;= maxSide; b++) &#123;</span><br><span class="line">            <span class="type">int</span> c = std::<span class="built_in">sqrt</span>(a * a + b * b);</span><br><span class="line">            <span class="keyword">if</span> (c &lt;= maxSide &amp;&amp; a * a + b * b == c * c) &#123;</span><br><span class="line">                triangles.<span class="built_in">insert</span>(&#123;a, b, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(triangles.<span class="built_in">begin</span>(), triangles.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> triangles = <span class="built_in">findRightTriangles</span>(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; triangle : triangles) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; triangle[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; triangle[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; triangle[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Overloading And Overriding</title>
    <url>/2024/07/16/notes/overloading-and-overriding/</url>
    <content><![CDATA[<h2 id="Overloading-Or-Overriding-That-is-a-Question"><a href="#Overloading-Or-Overriding-That-is-a-Question" class="headerlink" title="Overloading Or Overriding, That is a Question"></a>Overloading Or Overriding, That is a Question</h2><h3 id="重载和重写在面向对象编程中有什么区别"><a href="#重载和重写在面向对象编程中有什么区别" class="headerlink" title="重载和重写在面向对象编程中有什么区别?"></a>重载和重写在面向对象编程中有什么区别?</h3><p>在面向对象编程中,重载(overloading)和重写(overriding)是两个不同的概念:</p>
<ol>
<li><p>重载(Overloading):</p>
<ul>
<li>重载是在同一个类中定义多个同名的方法,但它们的参数列表不同(参数个数、参数类型或参数顺序不同)。</li>
<li>当调用这个类的方法时,根据实际传入的参数,系统会自动选择与之匹配的方法执行。</li>
<li>示例:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, a, b, c</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line">m = Math()</span><br><span class="line"><span class="built_in">print</span>(m.add(<span class="number">1</span>, <span class="number">2</span>))       <span class="comment"># 输出: 3</span></span><br><span class="line"><span class="built_in">print</span>(m.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))    <span class="comment"># 输出: 6</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重写(Overriding):</p>
<ul>
<li>重写是在子类中定义一个与父类中方法名、参数列表完全相同的方法。</li>
<li>当通过子类的对象调用这个方法时,将会执行子类中重写后的方法,而不是父类中的方法。</li>
<li>示例:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;动物发出声音&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;狗狗汪汪叫&quot;</span>)</span><br><span class="line"></span><br><span class="line">d = Dog()</span><br><span class="line">d.speak()  <span class="comment"># 输出: 狗狗汪汪叫</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>总的来说,重载是在同一个类中定义多个同名方法,而重写是在子类中定义与父类中方法完全相同的方法。重载是编译时行为,重写是运行时行为。</p>
<h3 id="Python是否支持重载"><a href="#Python是否支持重载" class="headerlink" title="Python是否支持重载?"></a>Python是否支持重载?</h3><p>Python 中确实没有像 Java 或 C++ 那样原生支持方法重载的功能。</p>
<p>在 Python 中,我们通常使用以下技术来实现类似重载的效果:</p>
<ol>
<li><p>使用默认参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b, c=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment"># 输出: 3</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 输出: 6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用可变长参数列表:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">*args</span>):</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        total += arg</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment"># 输出: 3</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 输出: 6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用关键字参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">*, a, b, c=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(a=<span class="number">1</span>, b=<span class="number">2</span>))     <span class="comment"># 输出: 3</span></span><br><span class="line"><span class="built_in">print</span>(add(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)) <span class="comment"># 输出: 6</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>尽管 Python 没有像 Java 或 C++ 那样的原生重载支持,但通过上述技术,我们仍然可以实现类似的功能。这种方式更加灵活,可以根据需求进行选择。</p>
<h3 id="那么重载是否是有意义的呢？-重写就可以完成这些任务？"><a href="#那么重载是否是有意义的呢？-重写就可以完成这些任务？" class="headerlink" title="那么重载是否是有意义的呢？ 重写就可以完成这些任务？"></a>那么重载是否是有意义的呢？ 重写就可以完成这些任务？</h3><p>重载和重写在某种程度上确实可以实现相似的功能,那么重载是否真的有意义呢?</p>
<p>这个问题没有一个标准答案,主要取决于具体的应用场景和编程风格。但是,我们可以从以下几个方面来分析重载的意义:</p>
<ol>
<li><p>代码可读性和可维护性:</p>
<ul>
<li>重载可以让代码更加直观和易于理解。使用相同的方法名,但根据参数的不同执行不同的逻辑,可以让代码更加语义化。</li>
<li>这有助于提高代码的可维护性,因为开发人员不需要记住多个不同名称的方法,只需要记住一个方法名即可。</li>
</ul>
</li>
<li><p>灵活性和扩展性:</p>
<ul>
<li>重载可以让类具有更强的灵活性和扩展性。当需求发生变化时,可以通过添加新的重载方法来满足需求,而不需要修改原有的代码。</li>
<li>这在一些大型项目中尤其有用,可以更好地应对需求的变化。</li>
</ul>
</li>
<li><p>代码复用:</p>
<ul>
<li>通过重载,可以在一个方法中实现多种功能,减少代码重复。</li>
<li>这有助于提高代码的复用性,降低开发和维护的成本。</li>
</ul>
</li>
</ol>
<p>相比之下,重写主要是为了实现多态性,即子类对父类方法的特殊化实现。它更多地体现在继承关系中,而重载则更多地体现在同一个类中。</p>
<p>所以,重载和重写都有其独特的用途和优点。在实际开发中,根据具体需求,合理地使用这两种技术可以让代码更加优雅、可读性更强、扩展性更好。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>Rust所有权系统：深入剖析</title>
    <url>/2024/10/28/Rust-ownership-system-details/</url>
    <content><![CDATA[<h2 id="Rust所有权系统：深入剖析"><a href="#Rust所有权系统：深入剖析" class="headerlink" title="Rust所有权系统：深入剖析"></a>Rust所有权系统：深入剖析</h2><h3 id="一、Rust所有权系统是什么"><a href="#一、Rust所有权系统是什么" class="headerlink" title="一、Rust所有权系统是什么"></a>一、Rust所有权系统是什么</h3><p>Rust的所有权系统是该语言最为独特且核心的特性之一。它是一种用于管理内存的机制，在不需要垃圾回收（GC）机制的情况下，保障内存安全和运行效率。</p>
<p>在Rust中，每个值都有一个被称为其所有者（owner）的变量，并且这个值有且仅有一个所有者。例如，当创建一个变量来存储某个值时，这个变量就成为了该值的所有者。这一概念与其他编程语言中对内存管理的方式有很大的区别。像在C语言中，程序员需要手动管理内存的分配和释放，容易出现内存泄漏（如分配了内存却忘记释放）和悬空指针（访问已经释放的内存）等问题；而在有垃圾回收机制的语言如Java中，垃圾回收器自动管理内存，但会有一定的性能开销并且在某些情况下可能存在不可预测的暂停。</p>
<p>Rust的所有权系统则基于一些简单而严格的规则来运作。这些规则包括：每个值都有对应的所有者变量；在任何时刻，一个值只能有一个所有者；当所有者（变量）离开其作用域时，这个值将被自动丢弃（释放其占用的内存）。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s是&quot;hello&quot;这个字符串值的所有者</span></span><br><span class="line">    <span class="comment">// 在这个代码块内可以使用s</span></span><br><span class="line">&#125; <span class="comment">// 代码块结束，s离开作用域，&quot;hello&quot;字符串所占用的内存被释放</span></span><br></pre></td></tr></table></figure>
<h3 id="二、Rust所有权系统的特点"><a href="#二、Rust所有权系统的特点" class="headerlink" title="二、Rust所有权系统的特点"></a>二、Rust所有权系统的特点</h3><h4 id="（一）基于变量的所有权归属"><a href="#（一）基于变量的所有权归属" class="headerlink" title="（一）基于变量的所有权归属"></a>（一）基于变量的所有权归属</h4><ul>
<li>明确的所有权关系<br>在Rust中，所有权与变量紧密相连。一旦一个值被创建，它就被绑定到一个特定的变量上，这个变量就是该值的所有者。例如，当定义一个整数变量 let num &#x3D; 5;，变量 num 就拥有值 5 的所有权。这种明确的所有权关系使得内存管理的责任清晰地落在了变量上。<br>与其他语言相比，像C++ 虽然也有类似的概念，但Rust的所有权系统更加严格和系统化。在C++ 中，对象的生命周期管理可以通过构造函数、析构函数等机制来实现，但由于其灵活性，也容易出现错误，例如悬空指针的问题在不谨慎的编程中可能会出现。</li>
<li>单一所有者原则<br>Rust规定每个值在任何时候都只能有一个所有者。这一原则有助于避免数据竞争和内存管理的混乱。例如，如果有两个不同的变量试图同时成为同一个值的所有者，这在Rust中是不被允许的。<br>考虑这样一个场景：在多线程编程中，如果允许多个变量同时拥有对同一块内存的所有权，当一个线程试图修改这块内存，而另一个线程也在同时访问或修改它时，就会产生数据竞争。Rust通过单一所有者原则有效地防止了这种情况的发生。</li>
</ul>
<h4 id="（二）所有权的转移与生命周期管理"><a href="#（二）所有权的转移与生命周期管理" class="headerlink" title="（二）所有权的转移与生命周期管理"></a>（二）所有权的转移与生命周期管理</h4><ul>
<li>所有权转移<br>当进行变量赋值操作时，所有权会发生转移。例如：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1; </span><br><span class="line"><span class="comment">// 此时s1不再拥有&quot;rust&quot;字符串的所有权，s2成为新的所有者</span></span><br></pre></td></tr></table></figure>
这种所有权转移机制在函数调用中也同样适用。当把一个变量作为参数传递给函数时，所有权会转移到函数内部的参数变量。这一特性对于管理资源（如文件句柄、网络连接等）非常有用。例如，当一个函数打开一个文件并返回文件句柄，在Rust中可以通过所有权转移确保在函数外部不再对已经关闭的文件进行操作。</li>
<li>生命周期自动管理<br>Rust的所有权系统通过变量的作用域来自动管理值的生命周期。当一个变量离开其作用域时，其所拥有的值就会被自动释放内存。例如：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// v是向量[1, 2, 3]的所有者</span></span><br><span class="line">    <span class="comment">// 在这个代码块内可以对v进行操作</span></span><br><span class="line">&#125; <span class="comment">// 代码块结束，v离开作用域，向量[1, 2, 3]所占用的内存被释放</span></span><br></pre></td></tr></table></figure>
这一特点避免了常见的内存泄漏问题，因为程序员不需要手动去释放内存，编译器会根据所有权和作用域的规则自动处理。</li>
</ul>
<h4 id="（三）借用与引用的规则"><a href="#（三）借用与引用的规则" class="headerlink" title="（三）借用与引用的规则"></a>（三）借用与引用的规则</h4><ul>
<li>不可变借用（&amp;）<br>Rust允许创建不可变引用（&amp;）来借用一个值而不获取其所有权。这使得在不改变值的情况下，可以在多个地方共享对该值的访问。例如：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> <span class="variable">s_ref</span> = &amp;s; </span><br><span class="line"><span class="comment">// 这里s仍然拥有&quot;hello&quot;字符串的所有权，s_ref是对s的不可变引用</span></span><br></pre></td></tr></table></figure>
在任何给定时间，可以有多个不可变引用存在。这对于在函数之间传递数据进行只读操作非常方便，同时也保证了内存安全，因为这些引用不能修改原始值，不会引起数据竞争。</li>
<li>可变借用（&amp;mut）<br>可变引用（&amp;mut）允许对借用的值进行修改，但有严格的限制。在任何时候，对于一个值只能有一个可变引用或者多个不可变引用，但不能同时既有可变引用又有不可变引用。例如：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">let</span> <span class="variable">mut_ref</span> = &amp;<span class="keyword">mut</span> num; </span><br><span class="line"><span class="comment">// 此时只有mut_ref这一个可变引用可以修改num的值</span></span><br></pre></td></tr></table></figure>
这种限制确保了在修改数据时的独占性，避免了数据竞争和不一致性。如果违反了这个规则，编译器会报错。</li>
</ul>
<h3 id="三、Rust所有权系统的工作原理"><a href="#三、Rust所有权系统的工作原理" class="headerlink" title="三、Rust所有权系统的工作原理"></a>三、Rust所有权系统的工作原理</h3><h4 id="（一）基于堆栈的内存管理与所有权"><a href="#（一）基于堆栈的内存管理与所有权" class="headerlink" title="（一）基于堆栈的内存管理与所有权"></a>（一）基于堆栈的内存管理与所有权</h4><ul>
<li>堆栈基础<br>在Rust中，理解堆栈（Stack）和堆（Heap）的原理对于理解所有权系统的工作原理很有帮助。栈是一种按照后进先出（LIFO）原则存储数据的内存区域。当向栈中放入数据（进栈）时，数据按照顺序依次存放，而取出数据（出栈）则按照相反的顺序。栈中的数据大小在编译时必须是已知且固定的。例如，基本类型（如整数、布尔值等）通常存储在栈上，因为它们的大小是固定的。<br>堆则是用于存储在编译时大小未知或者可能会发生变化的数据。在堆上分配内存需要更多的工作，因为操作系统需要找到一块足够大的空闲空间，并进行一些管理记录。例如，字符串（String）类型在Rust中存储在堆上，因为字符串的长度在运行时可能会改变。</li>
<li>所有权与堆栈的关系<br>所有权系统与堆栈有着密切的关系。当一个值被创建时，根据其类型和存储需求，它会被分配到栈或者堆上。而所有权则决定了这个值在内存中的生命周期管理。例如，当一个变量在栈上被创建并且是其值的所有者时，当这个变量离开作用域时，栈上的空间会自动被回收，因为栈的管理方式是自动的。对于存储在堆上的值，所有权的转移和释放同样确保了内存的正确管理。例如，当一个字符串变量的所有权被转移或者变量离开作用域时，堆上分配给这个字符串的内存会被正确地释放。</li>
</ul>
<h4 id="（二）所有权规则的执行机制"><a href="#（二）所有权规则的执行机制" class="headerlink" title="（二）所有权规则的执行机制"></a>（二）所有权规则的执行机制</h4><ul>
<li>编译时检查<br>Rust的所有权规则是由编译器来强制执行的。在编译代码时，编译器会检查每个值是否有唯一的所有者，以及所有权的转移、借用等操作是否符合规则。例如，如果在代码中试图违反单一所有者原则，如创建两个同时拥有同一个值的变量，编译器会报错并指出错误的位置。<br>这种编译时检查机制使得在程序运行之前就能够发现许多潜在的内存安全问题，大大提高了程序的可靠性。与运行时进行内存管理检查（如一些有垃圾回收机制的语言）相比，编译时检查不会带来运行时的性能开销。</li>
<li>作用域与所有权转移的关联<br>变量的作用域在所有权系统中起着关键的作用。当一个变量进入其作用域时，它可以成为一个值的所有者（如果这个值是在该作用域内创建的），或者通过所有权转移成为一个值的新所有者。当变量离开其作用域时，其所拥有的值会被按照所有权规则进行处理（如释放内存）。例如：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>); </span><br><span class="line">    <span class="comment">// s在这个代码块内是&quot;rust&quot;的所有者</span></span><br><span class="line">&#125; <span class="comment">// 代码块结束，s离开作用域，&quot;rust&quot;字符串所占用的内存被释放</span></span><br></pre></td></tr></table></figure>
在函数调用中，参数的传递也涉及到所有权转移和作用域的变化。当把一个变量作为参数传递给函数时，这个变量在函数外部的作用域结束，而在函数内部，参数变量开始了新的作用域并成为传递值的所有者（如果是值传递）。</li>
</ul>
<h4 id="（三）借用检查机制"><a href="#（三）借用检查机制" class="headerlink" title="（三）借用检查机制"></a>（三）借用检查机制</h4><ul>
<li>借用规则的检查<br>Rust的编译器有一个借用检查器（borrow checker），它负责检查引用（借用）是否符合规则。当创建不可变引用（&amp;）或可变引用（&amp;mut）时，借用检查器会确保在同一时间内引用的规则得到遵守。例如，如果试图在已经存在一个可变引用的情况下再创建一个不可变引用，并且这两个引用的生命周期有重叠部分，编译器会报错。<br>这个检查机制确保了在程序运行过程中不会出现数据竞争和无效的内存访问。它是Rust在编译时保证内存安全的重要组成部分。</li>
<li>引用的生命周期管理<br>引用的生命周期必须是有效的，即引用不能超出其所指向的值的生命周期。编译器会检查引用的生命周期与被引用值的所有者的作用域是否匹配。例如，如果一个不可变引用试图在被引用值已经被释放（所有者离开作用域）之后继续使用，编译器会检测到这个问题并报错。这一机制防止了悬空引用（dangling reference）的产生，悬空引用是指引用指向已经被释放的内存区域，这在其他一些编程语言中可能会导致程序崩溃或者产生未定义的行为。</li>
</ul>
<h3 id="四、Rust所有权系统的优势"><a href="#四、Rust所有权系统的优势" class="headerlink" title="四、Rust所有权系统的优势"></a>四、Rust所有权系统的优势</h3><h4 id="（一）内存安全保障"><a href="#（一）内存安全保障" class="headerlink" title="（一）内存安全保障"></a>（一）内存安全保障</h4><ul>
<li>避免内存泄漏<br>Rust的所有权系统通过自动管理内存的生命周期，有效地避免了内存泄漏。当一个值的所有者（变量）离开其作用域时，该值所占用的内存会被自动释放。例如，在处理动态分配的内存（如在堆上分配的字符串、向量等）时，不需要像在C或C++ 中那样手动释放内存。在C语言中，如果忘记释放动态分配的内存，就会导致内存泄漏，随着程序的运行，内存会被不断占用，最终可能导致程序崩溃或者系统性能下降。而在Rust中，这种情况不会发生。<br>考虑一个函数，它在内部创建了一个大的向量（vec）来存储数据：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">create_vector</span>() <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line">    <span class="comment">// 当函数结束时，v离开作用域，向量v所占用的内存被自动释放</span></span><br><span class="line">    v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>防止悬空指针<br>由于所有权系统对引用（借用）的严格管理，特别是通过借用检查器防止引用超出被引用值的生命周期，从而避免了悬空指针的出现。在Rust中，不可能出现一个引用指向已经被释放的内存区域的情况。<br>对比C语言中的情况，例如：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">int *<span class="title function_ invoke__">func</span>() &#123;</span><br><span class="line">    int a = <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">return</span> &amp;a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在这个C函数中，返回了局部变量 a 的地址，当函数结束后，局部变量 a 的内存被释放，但返回的指针仍然指向那块已经释放的内存，这就产生了悬空指针。而在Rust中，这种代码是无法通过编译的。</li>
</ul>
<h4 id="（二）高性能"><a href="#（二）高性能" class="headerlink" title="（二）高性能"></a>（二）高性能</h4><ul>
<li>减少运行时开销<br>Rust的所有权系统在编译时进行内存管理的检查，不需要像有垃圾回收机制的语言（如Java、Python等）那样在运行时进行垃圾回收的操作。垃圾回收器在运行时需要占用一定的系统资源来扫描内存、标记可回收对象等操作，这会导致程序运行时的性能开销，尤其是在处理大量数据或者对性能要求极高的场景下。而Rust在编译时就确定了内存的管理方式，避免了这种运行时的额外开销。<br>例如，在一个实时处理大量数据的系统中，如网络数据处理或者游戏开发中的实时渲染部分，Rust的这种无垃圾回收机制的所有权系统可以提供更高效的性能表现。</li>
<li>优化的内存布局与操作<br>由于所有权系统对值的生命周期和存储位置（栈或堆）有明确的管理，编译器可以更好地优化内存布局和操作。例如，对于存储在栈上的基本类型，访问速度通常比堆上的数据更快，因为栈的访问模式比较简单（按照后进先出的顺序）。Rust的编译器可以根据所有权和值的类型等信息，合理地安排数据在内存中的存储位置，从而提高程序的整体性能。<br>而且，在函数调用时，由于所有权的转移机制，参数传递可以更加高效。如果一个值是简单的基本类型并且实现了 Copy 特性（如整数类型），在函数调用时可以直接复制值而不需要复杂的操作；如果是较大的数据结构并且不实现 Copy 特性（如自定义的结构体包含堆上分配的数据），所有权转移可以确保在函数内部对数据的独占访问，避免不必要的数据复制。</li>
</ul>
<h4 id="（三）并发安全"><a href="#（三）并发安全" class="headerlink" title="（三）并发安全"></a>（三）并发安全</h4><ul>
<li>避免数据竞争<br>在多线程并发编程中，数据竞争是一个常见的问题，它指的是多个线程同时访问和修改同一块共享数据，从而导致程序结果的不确定性。Rust的所有权系统通过限制对数据的访问方式，有效地避免了数据竞争。<br>例如，在任何给定时间，对于一个值只能有一个可变引用（&amp;mut）或者多个不可变引用（&amp;），但不能同时既有可变引用又有不可变引用。这一规则确保了在多线程环境下，对共享数据的访问是有序和安全的。如果一个线程持有一个可变引用正在修改一个值，其他线程就不能同时对这个值进行修改或者创建另一个可变引用。</li>
<li>安全的资源共享<br>通过不可变引用（&amp;），可以在多个线程之间安全地共享数据进行只读操作。例如，多个线程可以同时拥有对一个不可变对象（如一个只读的配置文件数据结构）的不可变引用，而不会出现数据竞争。这种安全的资源共享机制使得在编写多线程程序时更加容易和可靠，不需要像在其他一些语言中那样使用复杂的锁机制来保护共享数据。</li>
</ul>
<h3 id="五、Rust所有权系统的应用场景"><a href="#五、Rust所有权系统的应用场景" class="headerlink" title="五、Rust所有权系统的应用场景"></a>五、Rust所有权系统的应用场景</h3><h4 id="（一）系统编程"><a href="#（一）系统编程" class="headerlink" title="（一）系统编程"></a>（一）系统编程</h4><ul>
<li>操作系统开发<br>在操作系统开发中，内存管理和资源控制是至关重要的。Rust的所有权系统能够确保对内存和系统资源（如设备驱动中的硬件资源）的精确管理。例如，在编写设备驱动程序时，对设备寄存器的访问和控制需要精确的内存操作。Rust的所有权系统可以防止对已经释放的寄存器地址进行访问（类似于防止悬空指针），并且可以确保在不同的模块或函数之间正确地传递和共享对设备资源的访问权。<br>而且，操作系统内核通常需要处理并发操作，如多任务处理和中断处理。Rust的所有权系统提供的并发安全特性，如避免数据竞争，使得在编写内核代码时可以更安全地处理并发情况，减少由于并发错误导致的系统崩溃或不稳定。</li>
<li>嵌入式系统开发<br>嵌入式系统通常资源有限，包括内存、处理器性能等。Rust的所有权系统可以在不使用垃圾回收机制的情况下确保内存安全，这对于嵌入式系统非常重要。例如，在一个微控制器上运行的嵌入式程序，内存空间非常有限，通过Rust的所有权系统可以精确地控制内存的使用，避免内存泄漏和不必要的内存占用。<br>同时，嵌入式系统也经常需要处理实时任务和并发操作。例如，一个传感器数据采集系统可能需要同时处理多个传感器的输入数据，并且要在规定的时间内完成数据处理和响应。Rust的所有权系统的并发安全特性可以帮助确保在处理这些并发任务时数据的准确性和系统的稳定性。</li>
</ul>
<h4 id="（二）网络编程"><a href="#（二）网络编程" class="headerlink" title="（二）网络编程"></a>（二）网络编程</h4><ul>
<li>服务器开发<br>在网络服务器开发中，需要处理大量的网络连接、数据传输和资源管理。Rust的所有权系统可以有效地管理网络连接对象的生命周期。例如，当一个客户端连接到服务器时，服务器为这个连接创建一个对应的资源对象（如套接字对象等），通过所有权系统可以确保当连接关闭或者超时后，相关的资源对象被正确地释放，避免资源泄漏。<br>同时，在多线程或异步网络服务器中，需要安全地共享和处理网络数据。Rust的所有权系统通过不可变引用和可变引用的规则，可以确保在多个任务或线程之间安全地共享网络数据进行读取和修改操作，避免数据竞争。例如，多个线程可以安全地读取服务器的配置数据（通过不可变引用），而在处理客户端请求时，可以在单个线程内安全地修改与该请求相关的状态数据（通过可变引用）。</li>
<li>网络协议实现<br>在实现网络协议时，需要精确地处理协议数据单元（PDU）的内存管理。Rust的所有权系统可以确保协议数据在各个处理阶段的正确内存管理。例如，在解析一个复杂的网络协议数据包时，</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>康威定律</title>
    <url>/2024/04/27/design-pattern/ConwaysLaw/</url>
    <content><![CDATA[<p>几乎所有我所青睐的软件架构从业者都对这个领域的任何一种一般法则都深表怀疑。好的软件架构是非常特定于上下文的，分析在各种环境中以不同方式解决的权衡。但是，如果他们都同意一件事，那就是康威定律的重要性和力量。它足够重要，足以影响我遇到的每个系统，也足够强大，如果你试图对抗它，你注定要失败。</p>
<p>该法律的作者可能最好将其表述为：</p>
<blockquote>
<p>Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure.<br>任何设计系统（广义定义）的组织都会产生一个设计，其结构是组织通信结构的副本。</p>
<p> ——梅尔文·康威</p>
</blockquote>
<p>康威定律本质上是这样一种观察，即软件系统的架构看起来与构建它的开发团队的组织非常相似。最初有人向我描述说，如果一个团队编写一个编译器，它将是一个单遍编译器，但如果团队分为两个，那么它将是一个双遍编译器。虽然我们通常在软件方面讨论它，但这种观察结果广泛适用于一般的系统。</p>
<p>正如我的同事克里斯·福特（Chris Ford）对我说的那样：“康威明白，软件耦合是由人类交流实现和鼓励的。如果我能轻松地与一些代码的作者交谈，那么我就更容易建立对该代码的丰富理解。这使我的代码更容易与该代码进行交互，从而与该代码耦合。不仅在显式函数调用方面，而且在隐含的共享假设和对问题域的思考方式方面。</p>
<p>我们经常看到对法律的忽视会扭曲系统架构。如果架构的设计与开发组织的结构不一致，那么软件结构中就会出现紧张关系。设计为简单明了的模块交互变得复杂，因为负责它们的团队不能很好地协同工作。甚至没有考虑有益的设计替代方案，因为必要的开发团队没有相互交流。</p>
<p>十几个人可以进行深入和非正式的交流，因此康威律师事务所表示他们将创建一个整体。这很好，所以康威定律不会影响我们对小型团队的思考。当人类需要组织时，康威定律应该影响决策。</p>
<p>处理康威定律的第一步是知道不要与之抗争。我还记得一位敏锐的技术领导者，他刚刚被任命为一个大型新项目的建筑师，该项目由世界各地不同城市的六个团队组成。“我做出了我的第一个建筑决定，”他告诉我。“将有六个主要的子系统。我不知道它们会是什么，但会有六个。</p>
<p>这个例子认识到了位置对人类交流的巨大影响。将团队放在同一栋楼的不同楼层足以大大减少沟通。将团队放在不同的城市和时区，进一步妨碍了常规对话。建筑师认识到了这一点，并意识到他需要从一开始就在技术设计中考虑到这一点。在不同时区开发的组件需要具有明确定义且有限的交互，因为它们的创建者无法轻松交谈。</p>
<p>与康威定律的一个常见不匹配是，面向活动的团队组织在跨目的下工作以进行功能开发。按软件层（例如前端、后端和数据库）组织的团队会导致占主导地位的 PresentationDomainDataLayering 结构，这是有问题的，因为每个功能都需要层之间的密切合作。同样，按照生命周期活动（分析、设计、编码、测试）划分人员意味着要获得从想法到生产的大量交接。</p>
<p>接受康威定律比忽视它要好，在过去的十年里，我们看到了第三种回应康威定律的方式。在这里，我们特意改变开发团队的组织结构，以鼓励所需的软件架构，这种方法被称为逆康威机动[4]。这种方法在微服务领域经常被谈论，倡导者建议建立小型的、长期存在的以业务能力为中心的团队，其中包含交付客户价值所需的所有技能。通过以这种方式组织自治团队，我们采用康威定律来鼓励类似的自治服务，这些服务可以相互独立地增强和部署。事实上，这就是为什么我将微服务描述为主要构建开发组织的工具。</p>
<p>|  |<br>|  |<br>| Ignore | Don’t take Conway’s Law into account, because you’ve never heard of it, or you don’t think it applies (narrator: it does)<br>不要考虑康威定律，因为你从未听说过它，或者你认为它不适用（旁白：确实如此） |<br>| Accept | Recognize the impact of Conway’s Law, and ensure your architecture doesn’t clash with designers’ communication patterns.<br>认识到康威定律的影响，并确保你的架构不会与设计师的沟通模式发生冲突。 |<br>| Inverse Conway Maneuver 逆康威机动 | Change the communication patterns of the designers to encourage the desired software architecture.<br>改变设计人员的沟通模式，以鼓励所需的软件架构。 |</p>
<p>虽然逆康威机动是一个有用的工具，但它并不是万能的。如果您有一个具有僵化架构的现有系统，并且想要更改，那么更改开发组织不会立即解决。相反，它更有可能导致开发人员和代码之间的不匹配，从而为进一步增强增加摩擦。对于这样的现有系统，康威定律的要点是，我们需要在更改组织和代码库时考虑它的存在。像往常一样，我建议采取一些小步骤，同时对反馈保持警惕。</p>
<p>领域驱动设计在康威定律中发挥着帮助定义组织结构的作用，因为 DDD 的一个关键部分是识别 BoundedContexts。边界上下文的一个关键特征是它有自己的 UbiquitousLanguage，由在该上下文中工作的一群人定义和理解。这样的背景形成了围绕一个主题对人们进行分组的方式，然后可以与价值流保持一致。</p>
<p>关于康威定律，要记住的关键是，系统的模块化分解和开发组织的分解必须一起完成。这不仅仅是在开始，架构的演变和人类组织的重组必须在企业的整个生命周期中齐头并进。</p>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>康威定律</title>
    <url>/2024/04/27/tech_essay/ConwaysLaw/</url>
    <content><![CDATA[<p>几乎所有我所青睐的软件架构从业者都对这个领域的任何一种一般法则都深表怀疑。好的软件架构是非常特定于上下文的，分析在各种环境中以不同方式解决的权衡。但是，如果他们都同意一件事，那就是康威定律的重要性和力量。它足够重要，足以影响我遇到的每个系统，也足够强大，如果你试图对抗它，你注定要失败。<br>该法律的作者可能最好将其表述为:<br>*Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure.<br>任何设计系统（广义定义）的组织都会产生一个设计，其结构是组织通信结构的副本。</p>
<p>– Melvin Conway ——梅尔文·康威</p>
]]></content>
      <categories>
        <category>tech_essay</category>
      </categories>
  </entry>
  <entry>
    <title>O(0)算法复杂度的终极目标：这个需求能不能不做？？？</title>
    <url>/2024/09/22/tech_essay/O0/</url>
    <content><![CDATA[<p>算法复杂度(Algorithmic complexity) – 所有人对它都有这样的一个概念就是要乐此不疲尽我所能地压缩以提高算法的性能。</p>
<p>你有个问题需要解决，并且得出一个解决方案，它是O(n^2)。你觉得做的不够好，需要做得更好。然后稍微调整一下，得到线性复杂度O(n)。你很高兴，因为事情看起来明朗起来了。</p>
<p>然而，你脑子里还绷着弦儿，晚上睡一觉醒来忽然又顿悟了，将算法的复杂度降低到对数O(log(n))，你自我感觉很好。在本周晚些时候，你读到一篇论文，并意识到你可以把它归结为恒定时间O(1)。你觉得现在就两个字：完美。你认为没有比这更好的方案了。</p>
<p>大错特错！<br>你还没尝试过O(0)。</p>
<div align="center"> <img src="/images/o-zero.webp"/></br></div>

<p>shong么？0时间复杂度？</p>
<div align="center"> <img src="/images/meitingshuoguo.webp"/>于谦：没听说过！</br></div>
<div align="center"> <img src="/images/bukeneng.jpeg"/>陈建斌：不可能！绝对不可能！</br></div>
 
<p>你的硬件计算机教授说过，恒定时间复杂度是最好的。在你的整个职业生涯都只听说过最佳的时间复杂度是O(1)。</p>
<p>它一直在那里，但它被称为其他东西。</p>
<p>有些代码根本不需要执行。有些工具可以扔掉。有些事情根本不需要做，如果你调整其他东西，你仍然能获得类似更好的结果。</p>
<p>你可能听过这样一句话：最快的代码是根本不被调用的代码？这不就是O(0)么！</p>
<p>作为一个合格的工程师你需要做到吾日三省吾身：”有没有办法不做这项工作的情况下完成某项工作？”。令人惊讶的答案是肯定的!</p>
<p>有时候，我们会做一些冗长又复杂的事情，什么都不做可能才是一个比较好的解决方案。有时候我们每分钟运行一次，然而实际上可能只需要每月运行一次就足够了。有时候我们会构建复杂的机制，这些机会会被使用，但也许这些复杂机制带来的好处并不是我们真正需要的。</p>
<p>你想成为一个10倍效率的工程师吗？有时候，决定不做某些事反而比做无用的事情会高效100倍。</p>
]]></content>
      <categories>
        <category>tech_essay</category>
      </categories>
  </entry>
  <entry>
    <title>详解：python中的with</title>
    <url>/2024/10/28/python/notes/with_in_python/</url>
    <content><![CDATA[<h2 id="详解-python中的with"><a href="#详解-python中的with" class="headerlink" title="详解: python中的with"></a>详解: python中的with</h2><p>一、基本概念与语法结构<br>在Python中，with语句是一种用于简化资源管理的控制流语句，它的语法结构如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expression [<span class="keyword">as</span> target(s)]: </span><br><span class="line">   ... <span class="keyword">with</span> - body...</span><br></pre></td></tr></table></figure>
<p>其中，context_expression可以是任意表达式，它的结果应该是一个支持上下文管理协议（Context Management Protocol）的对象。as target(s)是可选的部分，如果存在，with语句执行时会将__enter__()方法的返回值绑定到as后面指定的目标（可以是一个或多个变量）。</p>
<p>例如，在文件操作中，我们经常这样使用with：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>,  <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">    data = f.read() </span><br></pre></td></tr></table></figure>
<p>这里open(‘example.txt’,  ‘r’)就是context_expression，它返回一个文件对象（支持上下文管理协议），f就是as后面的目标变量，在with - body（这里是data &#x3D; f.read() ）中就可以使用这个文件对象进行操作。</p>
<p>二、支持的对象类型<br>很多对象都可以支持with语句，只要它们实现了上下文管理协议，也就是定义了__enter__()和__exit__()方法。</p>
<ul>
<li>文件对象</li>
</ul>
<p>文件对象是最常见的支持with语句的对象类型。当使用open()函数打开一个文件时，它返回的文件对象就可以直接用于with语句中。这是因为文件操作需要在使用完毕后关闭文件以释放资源，with语句可以确保无论在操作文件过程中是否发生异常，文件都会被正确关闭。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,  <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;Hello,  World!&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>: </span><br><span class="line">    f.close() </span><br></pre></td></tr></table></figure>
<p>这种写法比较繁琐，而使用with语句就简洁得多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,  <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">    f.write(<span class="string">&#x27;Hello,  World!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>锁对象（如在多线程编程中的锁）</li>
</ul>
<p>在多线程编程中，为了防止多个线程同时访问共享资源而导致数据不一致等问题，我们会使用锁。with语句可以用于自动获取和释放锁，例如在threading模块中的Lock对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_function</span>(): </span><br><span class="line">    <span class="keyword">with</span> lock: </span><br><span class="line">        <span class="comment"># 这里是对共享资源的操作，只有获取到锁的线程才能执行</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Thread is working&#x27;</span>) </span><br></pre></td></tr></table></figure>
<p>这里，with lock会自动获取锁，当with - body中的代码执行完毕后，会自动释放锁，避免了手动获取和释放锁时可能出现的忘记释放锁的问题。</p>
<ul>
<li>自定义对象</li>
</ul>
<p>我们也可以自定义支持with语句的对象。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContextManager</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Entering the context&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Exiting the context&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> MyContextManager() <span class="keyword">as</span> cm: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Inside the with block&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，MyContextManager类定义了__enter__()和__exit__()方法，所以可以用于with语句。<strong>enter</strong>()方法在进入with块时被调用，<strong>exit</strong>()方法在退出with块时被调用，无论是否发生异常。</p>
<h2 id="Python-with工作原理"><a href="#Python-with工作原理" class="headerlink" title="Python with工作原理"></a>Python with工作原理</h2><p>一、上下文管理协议的核心方法</p>
<ul>
<li><strong>enter</strong>()方法<br>当执行with语句时，首先会调用context_expression所返回对象的__enter__()方法。这个方法的主要作用是进行一些初始化操作，并返回一个值（如果有as target(s)部分，这个值会被绑定到目标变量上）。例如在文件对象中，<strong>enter</strong>()方法可能会打开文件并返回文件对象本身。<br>以一个自定义的上下文管理器类为例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContext</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__enter__ method is called&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;This is the return value&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__exit__ method is called&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> MyContext() <span class="keyword">as</span> result: </span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">在这个例子中，当执行<span class="keyword">with</span> MyContext()时，__enter__()方法被调用，它打印出__enter__ method <span class="keyword">is</span> called并返回This <span class="keyword">is</span> the <span class="keyword">return</span> value，这个返回值被绑定到result变量上，然后在<span class="keyword">with</span> - body中打印出来。</span><br><span class="line">* __exit__()方法</span><br><span class="line">__exit__()方法在<span class="keyword">with</span> - body执行完毕后被调用，无论<span class="keyword">with</span> - body中的代码是正常执行完毕还是发生了异常。它有四个参数：exc_type（异常类型，如果没有异常则为<span class="literal">None</span>）、exc_value（异常值，如果没有异常则为<span class="literal">None</span>）、traceback（异常的追溯信息，如果没有异常则为<span class="literal">None</span>）。</span><br><span class="line">它的主要功能是进行一些清理操作，比如关闭文件、释放锁等。如果在__exit__()方法中返回<span class="literal">True</span>，那么<span class="keyword">with</span> - body中发生的异常会被抑制，不会向上传播；如果返回<span class="literal">False</span>或者<span class="literal">None</span>（默认），异常会正常向上传播。例如：</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuppressError</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>): </span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Suppressing the error:&#x27;</span>, exc_type)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">with</span> SuppressError(): </span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br></pre></td></tr></table></figure>
在这个例子中，<strong>exit</strong>()方法检查到发生了ZeroDivisionError异常（exc_type不为None），然后打印出抑制错误的信息并返回True，所以这个异常不会导致程序崩溃。<br>二、与try - finally的等价关系<br>正常执行情况<br>在语义上，with语句等价于一个包含try - finally结构的代码块。例如：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    context_manager = context_expression</span><br><span class="line">    value = <span class="built_in">type</span>(context_manager).__enter__(context_manager)</span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        target = value</span><br><span class="line">        <span class="comment"># with - body </span></span><br><span class="line">    <span class="keyword">finally</span>: </span><br><span class="line">        <span class="built_in">type</span>(context_manager).__exit__(context_manager, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">except</span>: </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
当with - body正常执行时，<strong>enter</strong>()方法首先被调用，然后执行with - body中的代码，最后__exit__()方法被调用且传入的exc_type、exc_value、traceback都为None。</li>
<li>发生异常情况<br>如果在with - body中发生了异常，<strong>exit</strong>()方法会被调用，并且传入异常的类型、值和追溯信息。如果__exit__()方法返回True，异常被抑制，就好像在try - finally结构中在finally块中处理了异常并且不再向上传播；如果__exit__()方法返回False或者None，异常会像在普通的try - except结构中一样向上传播，由外部的异常处理机制来处理。例如：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    context_manager = context_expression</span><br><span class="line">    value = <span class="built_in">type</span>(context_manager).__enter__(context_manager)</span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        target = value</span><br><span class="line">        <span class="comment"># with - body中发生异常</span></span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;This is an error&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>: </span><br><span class="line">        exc = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">type</span>(context_manager).__exit__(context_manager, *sys.exc_info()):  </span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            exc = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">finally</span>: </span><br><span class="line">        <span class="keyword">if</span> exc: </span><br><span class="line">            <span class="built_in">type</span>(context_manager).__exit__(context_manager, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Python-with常见应用场景举例"><a href="#Python-with常见应用场景举例" class="headerlink" title="Python with常见应用场景举例"></a>Python with常见应用场景举例</h2><p>一、文件操作</p>
<ul>
<li>读取文件<br>在读取文件时，使用with语句可以确保文件在读取完毕后被正确关闭，即使在读取过程中发生了异常。例如：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>,  <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">    lines = f.readlines() </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines: </span><br><span class="line">        <span class="built_in">print</span>(line.strip()) </span><br></pre></td></tr></table></figure>
如果不使用with语句，我们需要使用try - finally结构来确保文件关闭：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>,  <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    lines = f.readlines() </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines: </span><br><span class="line">        <span class="built_in">print</span>(line.strip()) </span><br><span class="line"><span class="keyword">finally</span>: </span><br><span class="line">    f.close() </span><br></pre></td></tr></table></figure>
很明显，使用with语句的代码更加简洁。</li>
<li>写入文件<br>同样，在写入文件时，with语句也很方便。例如：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>,  <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">    f.write(<span class="string">&#x27;This  is a test.\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
这里，如果写入过程中出现问题（比如磁盘空间不足等），<strong>exit</strong>()方法会被调用，文件会被关闭，避免资源泄漏。<br>二、数据库连接</li>
<li>连接数据库并执行查询<br>在使用数据库连接时，如sqlite3数据库，我们可以这样使用with语句：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">with</span> sqlite3.connect(<span class="string">&#x27;example.db&#x27;</span>)  <span class="keyword">as</span> conn: </span><br><span class="line">    cursor = conn.cursor() </span><br><span class="line">    cursor.execute(<span class="string">&#x27;SELECT  * FROM users&#x27;</span>)</span><br><span class="line">    results = cursor.fetchall() </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> results: </span><br><span class="line">        <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>
当with - body执行完毕后，数据库连接会被正确关闭，释放相关资源。如果在查询过程中发生异常（比如数据库文件损坏等），<strong>exit</strong>()方法也会被调用进行清理操作。</li>
<li>事务处理<br>在数据库事务处理中，with语句也很有用。例如：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> sqlite3.connect(<span class="string">&#x27;example.db&#x27;</span>)  <span class="keyword">as</span> conn: </span><br><span class="line">    cursor = conn.cursor() </span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        cursor.execute(<span class="string">&#x27;BEGIN  TRANSACTION&#x27;</span>)</span><br><span class="line">        cursor.execute(<span class="string">&#x27;INSERT  INTO users (name, age) VALUES (?,?)&#x27;</span>, (<span class="string">&#x27;John&#x27;</span>, <span class="number">30</span>))</span><br><span class="line">        cursor.execute(<span class="string">&#x27;COMMIT&#x27;</span>) </span><br><span class="line">    <span class="keyword">except</span>: </span><br><span class="line">        cursor.execute(<span class="string">&#x27;ROLLBACK&#x27;</span>) </span><br></pre></td></tr></table></figure>
这里，with语句确保了数据库连接的正确管理，而在with - body中通过try - except结构处理事务的提交和回滚，如果没有异常则提交事务，如果发生异常则回滚事务。<br>三、多线程中的资源锁定</li>
<li>线程安全的计数器<br>考虑一个多线程环境下的计数器的例子。我们使用threading.Lock来确保计数器的操作是线程安全的：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>(): </span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="keyword">with</span> lock: </span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): </span><br><span class="line">    t = threading.Thread(target = increment)</span><br><span class="line">    threads.append(t) </span><br><span class="line">    t.start() </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads: </span><br><span class="line">    t.join() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Counter value:&#x27;</span>, counter)</span><br></pre></td></tr></table></figure>
在increment函数中，with lock会自动获取锁，使得只有一个线程能够执行counter +&#x3D; 1这个操作，从而保证了计数器在多线程环境下的正确性。当线程完成操作后，锁会被自动释放。</li>
<li>共享资源的访问控制<br>假设我们有一个共享的列表，多个线程可能会对其进行读写操作。我们可以使用with语句和锁来确保共享资源的正确访问：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">shared_list = []</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_to_list</span>(<span class="params">item</span>): </span><br><span class="line">    <span class="keyword">with</span> lock: </span><br><span class="line">        shared_list.append(item) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_from_list</span>(): </span><br><span class="line">    <span class="keyword">with</span> lock: </span><br><span class="line">        <span class="keyword">if</span> shared_list: </span><br><span class="line">            <span class="keyword">return</span> shared_list.pop() </span><br><span class="line">threads = []</span><br><span class="line"><span class="comment"># 创建一些添加元素的线程</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>): </span><br><span class="line">    t = threading.Thread(target = add_to_list, args = (i,))</span><br><span class="line">    threads.append(t) </span><br><span class="line">    t.start() </span><br><span class="line"><span class="comment"># 创建一些删除元素的线程</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): </span><br><span class="line">    t = threading.Thread(target = remove_from_list)</span><br><span class="line">    threads.append(t) </span><br><span class="line">    t.start() </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads: </span><br><span class="line">    t.join() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Shared list:&#x27;</span>, shared_list)</span><br></pre></td></tr></table></figure>
这里，add_to_list和remove_from_list函数中的with lock确保了在对共享列表进行操作时的线程安全性。</li>
</ul>
<h2 id="Python-with与其他类似机制的比较"><a href="#Python-with与其他类似机制的比较" class="headerlink" title="Python with与其他类似机制的比较"></a>Python with与其他类似机制的比较</h2><p>一、与try - finally的比较</p>
<ul>
<li>语法简洁性<br>with语句比try - finally更加简洁。例如在文件操作中，使用try - finally来确保文件关闭的代码如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,  <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    data = f.read() </span><br><span class="line">    <span class="comment"># 其他操作</span></span><br><span class="line"><span class="keyword">finally</span>: </span><br><span class="line">    f.close() </span><br><span class="line">而使用<span class="keyword">with</span>语句则是：</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,  <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">    data = f.read() </span><br><span class="line">    <span class="comment"># 其他操作</span></span><br></pre></td></tr></table></figure>
可以明显看出，with语句不需要显式地编写try和finally块，减少了代码的冗余。</li>
<li>异常处理逻辑<br>在try - finally中，如果想要在finally块中处理异常并根据情况决定是否重新抛出异常，逻辑会比较复杂。而在with语句中，通过__exit__()方法可以很方便地处理异常。例如：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContext</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>): </span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Caught an exception in __exit__:&#x27;</span>, exc_type)</span><br><span class="line">            <span class="comment"># 根据情况返回True或False来决定是否抑制异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">with</span> MyContext(): </span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;This is an error&#x27;</span>)</span><br></pre></td></tr></table></figure>
在这个with语句的例子中，<strong>exit</strong>()方法可以直接处理异常，而在try - finally中，需要在finally块中额外的逻辑来处理异常并决定是否重新抛出。</li>
<li>代码可读性<br>with语句的代码可读性更高，因为它将资源管理和操作代码更加紧密地结合在一起。try - finally结构中，资源管理（finally块）和正常操作（try块）的代码是分开的，对于复杂的逻辑，可能会使代码的理解变得困难。例如在数据库连接的操作中，with语句使得连接的获取、操作和释放更加直观：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> sqlite3.connect(<span class="string">&#x27;db.sqlite&#x27;</span>)  <span class="keyword">as</span> conn: </span><br><span class="line">    cursor = conn.cursor() </span><br><span class="line">    cursor.execute(<span class="string">&#x27;SELECT  * FROM table&#x27;</span>)</span><br></pre></td></tr></table></figure>
而使用try - finally结构会使代码的结构更加分散。<br>二、与装饰器的比较（在资源管理方面）</li>
<li>功能侧重点<br>装饰器主要用于在不修改原函数代码的情况下，对函数的功能进行扩展，如添加日志记录、性能检测等功能。而with语句主要用于资源管理，确保资源的正确获取和释放。例如，一个简单的日志记录装饰器：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log_decorator</span>(<span class="params">func</span>): </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Calling function <span class="subst">&#123;func.__name__&#125;</span>&#x27;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Function <span class="subst">&#123;func.__name__&#125;</span> finished&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@log_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;This is my function&#x27;</span>)</span><br><span class="line">my_function()</span><br></pre></td></tr></table></figure>
这个装饰器主要是在函数调用前后添加了日志记录功能，与资源管理没有直接关系。而with语句则专注于资源的生命周期管理，如文件、数据库连接等资源。</li>
<li>使用方式<br>装饰器是通过在函数定义前添加@符号和装饰器函数名来使用的，它会自动包装被装饰的函数。而with语句是在需要管理资源的代码块前直接使用的。例如，对于一个需要在函数执行前后进行资源管理的情况，如果使用装饰器，需要定义一个专门的装饰器来处理资源管理，而使用with语句则可以直接在函数内部相关代码块使用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resource_heavy_function</span>(): </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>,  <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">        data = f.read() </span><br><span class="line">    <span class="comment"># 对读取的数据进行操作</span></span><br></pre></td></tr></table></figure>
如果使用装饰器来实现类似的资源管理，会更加复杂，需要更多的代码来处理资源的获取、释放和函数的执行逻辑。</li>
</ul>
<h2 id="Python-with错误处理方法"><a href="#Python-with错误处理方法" class="headerlink" title="Python with错误处理方法"></a>Python with错误处理方法</h2><p>一、<strong>exit</strong>()方法中的异常处理<br>接收异常信息<br>当with - body中发生异常时，<strong>exit</strong>()方法会接收到异常的类型（exc_type）、异常的值（exc_value）和异常的追溯信息（traceback）。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorHandler</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>): </span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Caught an exception: <span class="subst">&#123;exc_type&#125;</span>, <span class="subst">&#123;exc_value&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> ErrorHandler(): </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
</search>
